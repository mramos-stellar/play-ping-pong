package models.rails


// AUTO-GENERATED Slick data model
/** Stand-alone Slick data model for immediate use */
object Tables extends {
  val profile = slick.driver.MySQLDriver
} with Tables

/** Slick data model trait for extension, choice of backend or usage in the cake pattern. (Make sure to initialize this late.) */
trait Tables {
  val profile: slick.driver.JdbcProfile
  import profile.api._
  import slick.model.ForeignKeyAction
  import slick.collection.heterogeneous._
  import slick.collection.heterogeneous.syntax._
  // NOTE: GetResult mappers for plain SQL are only generated for tables where Slick knows how to map the types of all columns.
  import slick.jdbc.{GetResult => GR}
  /** DDL for all tables. Call .create to execute. */
  lazy val schema: profile.SchemaDescription = Array(ActionInstances.schema, ActivityTypes.schema, Addresses.schema, Admins.schema, ApplicationLocations.schema, Assignments.schema, Attachments.schema, AudienceFactors.schema, Awards.schema, BackgroundJobs.schema, BadgeGrantRules.schema, BadgeLevels.schema, BadgeLocations.schema, Badges.schema, BadgeSegments.schema, BeaconLocations.schema, Beacons.schema, BigdataQueries.schema, BigdataQueryKpis.schema, BigdataQueryParameters.schema, BookingClasses.schema, CabinClasses.schema, CalculationRules.schema, CampaignLocations.schema, CampaignMemberConditions.schema, CampaignOfferConditions.schema, CampaignRules.schema, Campaigns.schema, CampaignSegments.schema, Categories.schema, Certificates.schema, ChallengeActions.schema, ChallengeAssets.schema, ChallengeDefinitionOptions.schema, ChallengeDefinitions.schema, ChallengeLocations.schema, ChallengePrizes.schema, ChallengeResponseItems.schema, ChallengeResponsePrizes.schema, ChallengeResponses.schema, Challenges.schema, ChallengeSegments.schema, ChartPlotbands.schema, ChartThemes.schema, ClassifiableAttributeMappings.schema, ClassifiableAttributeOptionProperties.schema, ClassificationAttributeOptions.schema, ClassificationAttributes.schema, ClassificationMappings.schema, Classifications.schema, ClientEventOffers.schema, ClientEvents.schema, ClientEventTargets.schema, CodeEntries.schema, CodeResponses.schema, Codes.schema, CodeSegments.schema, CodeValues.schema, CombinationValues.schema, CombinedGroups.schema, Comments.schema, ComponentGroupDefinitions.schema, Conditions.schema, ContentBlocks.schema, ContentPages.schema, Contents.schema, ContentSettings.schema, ContentTokens.schema, ContestActions.schema, ContestLocations.schema, ContestPrizes.schema, ContestResponsePrizes.schema, ContestResponses.schema, Contests.schema, ContestSegments.schema, DashboardKpis.schema, DashboardPanels.schema, Dashboards.schema, Deployments.schema, DiscountTransactions.schema, Edges.schema, EntityPlacements.schema, EventLocations.schema, EventMembers.schema, EventResponses.schema, Events.schema, EventSegments.schema, ExportDefinitions.schema, ExportJobs.schema, Exports.schema, FailedActivities.schema, Features.schema, Flaggings.schema, FlightSegments.schema, GalleryItems.schema, GiftcardClasses.schema, Giftcards.schema, GiftcardTransactions.schema, Identities.schema, ImportDefinitions.schema, Imports.schema, JobResults.schema, Jobs.schema, LocationHierarchies.schema, Locations.schema, LookupParameters.schema, Lookups.schema, LookupValues.schema, ManageScores.schema, MemberAttributes.schema, MemberBadges.schema, MemberClasses.schema, MemberDocuments.schema, MemberFunctions.schema, MemberLinks.schema, MemberPreferences.schema, Members.schema, MessageActions.schema, MessageLocations.schema, MessageResponses.schema, Messages.schema, MessageSegments.schema, Metrics.schema, NewsFeedLocations.schema, NewsFeeds.schema, NewsFeedSegments.schema, OauthAccessGrants.schema, OauthAccessTokens.schema, OauthApplications.schema, ObjectiveFactors.schema, OfferActions.schema, OfferCertificates.schema, OfferLocations.schema, OfferResponses.schema, Offers.schema, OfferSegments.schema, OptionCombinations.schema, Permissions.schema, Placements.schema, Posts.schema, ProductActions.schema, ProductEdges.schema, ProductHierarchies.schema, ProductLocations.schema, Products.schema, ProductSegments.schema, Programs.schema, ProgramSettings.schema, Properties.schema, PunchCards.schema, PunchCardTransactions.schema, PunchCardTypes.schema, ReceiptItems.schema, Receipts.schema, Redemptions.schema, ReferralCodes.schema, ResponseTypes.schema, RewardActions.schema, RewardLocations.schema, RewardPrizes.schema, RewardResponsePrizes.schema, Rewards.schema, RewardSegments.schema, RuleGroupCombinations.schema, RuleGroups.schema, SchemaMigrations.schema, ScoreBoards.schema, ScoringRules.schema, Segments.schema, SetEntities.schema, SetEntityConditions.schema, SetMemberConditions.schema, SetOverrideEntities.schema, SetOverrides.schema, SetRules.schema, SocialSources.schema, StellarCategories.schema, StellarCategoryMappings.schema, Taggings.schema, Tags.schema, TargetingSets.schema, TemplateSets.schema, TemplateSetVersions.schema, TierActionEvents.schema, TierColumnMetrics.schema, TierColumns.schema, TierColumnValues.schema, TierRules.schema, Tiers.schema, TrackingCodes.schema, TriggeredActionParameters.schema, TriggeredActions.schema, TriggerGroups.schema, Triggers.schema, UserAddresses.schema, UserConnects.schema, UserDevices.schema, UserFriends.schema, UserMessages.schema, UserMetrics.schema, UserReferrals.schema, UserSegments.schema, Versions.schema, Votes.schema, WallPostAttachments.schema, WallPosts.schema).reduceLeft(_ ++ _)
  @deprecated("Use .schema instead of .ddl", "3.0")
  def ddl = schema

  /** Entity class storing rows of table ActionInstances
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param actionClass Database column action_class SqlType(VARCHAR), Length(255,true)
   *  @param parameters Database column parameters SqlType(TEXT), Default(None)
   *  @param actionInstanceId Database column action_instance_id SqlType(INT), Default(None)
   *  @param ownerId Database column owner_id SqlType(INT), Default(None)
   *  @param ownerType Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param subjectId Database column subject_id SqlType(INT), Default(None)
   *  @param subjectType Database column subject_type SqlType(INT), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param version Database column version SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ActionInstancesRow(id: Int, name: String, actionClass: String, parameters: Option[String] = None, actionInstanceId: Option[Int] = None, ownerId: Option[Int] = None, ownerType: Option[String] = None, subjectId: Option[Int] = None, subjectType: Option[Int] = None, programId: Option[Int] = None, version: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ActionInstancesRow objects using plain SQL queries */
  implicit def GetResultActionInstancesRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[ActionInstancesRow] = GR{
    prs => import prs._
    ActionInstancesRow.tupled((<<[Int], <<[String], <<[String], <<?[String], <<?[Int], <<?[Int], <<?[String], <<?[Int], <<?[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table action_instances. Objects of this class serve as prototypes for rows in queries. */
  class ActionInstances(_tableTag: Tag) extends Table[ActionInstancesRow](_tableTag, "action_instances") {
    def * = (id, name, actionClass, parameters, actionInstanceId, ownerId, ownerType, subjectId, subjectType, programId, version, createdAt, updatedAt) <> (ActionInstancesRow.tupled, ActionInstancesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(actionClass), parameters, actionInstanceId, ownerId, ownerType, subjectId, subjectType, programId, version, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ActionInstancesRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column action_class SqlType(VARCHAR), Length(255,true) */
    val actionClass: Rep[String] = column[String]("action_class", O.Length(255,varying=true))
    /** Database column parameters SqlType(TEXT), Default(None) */
    val parameters: Rep[Option[String]] = column[Option[String]]("parameters", O.Default(None))
    /** Database column action_instance_id SqlType(INT), Default(None) */
    val actionInstanceId: Rep[Option[Int]] = column[Option[Int]]("action_instance_id", O.Default(None))
    /** Database column owner_id SqlType(INT), Default(None) */
    val ownerId: Rep[Option[Int]] = column[Option[Int]]("owner_id", O.Default(None))
    /** Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ownerType: Rep[Option[String]] = column[Option[String]]("owner_type", O.Length(255,varying=true), O.Default(None))
    /** Database column subject_id SqlType(INT), Default(None) */
    val subjectId: Rep[Option[Int]] = column[Option[Int]]("subject_id", O.Default(None))
    /** Database column subject_type SqlType(INT), Default(None) */
    val subjectType: Rep[Option[Int]] = column[Option[Int]]("subject_type", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column version SqlType(INT), Default(None) */
    val version: Rep[Option[Int]] = column[Option[Int]]("version", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ActionInstances */
  lazy val ActionInstances = new TableQuery(tag => new ActionInstances(tag))

  /** Entity class storing rows of table ActivityTypes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(10,true), Default(None)
   *  @param aggregateType Database column aggregate_type SqlType(VARCHAR), Length(15,true), Default(None)
   *  @param displayText Database column display_text SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param allowMemberSubmission Database column allow_member_submission SqlType(BIT), Default(false)
   *  @param apiVisible Database column api_visible SqlType(BIT), Default(true) */
  case class ActivityTypesRow(id: Int, name: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Option[Int] = None, label: Option[String] = None, code: Option[String] = None, aggregateType: Option[String] = None, displayText: Option[String] = None, allowMemberSubmission: Boolean = false, apiVisible: Boolean = true)
  /** GetResult implicit for fetching ActivityTypesRow objects using plain SQL queries */
  implicit def GetResultActivityTypesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]], e4: GR[Boolean]): GR[ActivityTypesRow] = GR{
    prs => import prs._
    ActivityTypesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<[Boolean], <<[Boolean]))
  }
  /** Table description of table activity_types. Objects of this class serve as prototypes for rows in queries. */
  class ActivityTypes(_tableTag: Tag) extends Table[ActivityTypesRow](_tableTag, "activity_types") {
    def * = (id, name, description, createdAt, updatedAt, programId, label, code, aggregateType, displayText, allowMemberSubmission, apiVisible) <> (ActivityTypesRow.tupled, ActivityTypesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, createdAt, updatedAt, programId, label, code, aggregateType, displayText, Rep.Some(allowMemberSubmission), Rep.Some(apiVisible)).shaped.<>({r=>import r._; _1.map(_=> ActivityTypesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11.get, _12.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(10,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(10,varying=true), O.Default(None))
    /** Database column aggregate_type SqlType(VARCHAR), Length(15,true), Default(None) */
    val aggregateType: Rep[Option[String]] = column[Option[String]]("aggregate_type", O.Length(15,varying=true), O.Default(None))
    /** Database column display_text SqlType(VARCHAR), Length(255,true), Default(None) */
    val displayText: Rep[Option[String]] = column[Option[String]]("display_text", O.Length(255,varying=true), O.Default(None))
    /** Database column allow_member_submission SqlType(BIT), Default(false) */
    val allowMemberSubmission: Rep[Boolean] = column[Boolean]("allow_member_submission", O.Default(false))
    /** Database column api_visible SqlType(BIT), Default(true) */
    val apiVisible: Rep[Boolean] = column[Boolean]("api_visible", O.Default(true))

    /** Uniqueness Index over (name) (database name index_activity_types_on_name) */
    val index1 = index("index_activity_types_on_name", name, unique=true)
  }
  /** Collection-like TableQuery object for table ActivityTypes */
  lazy val ActivityTypes = new TableQuery(tag => new ActivityTypes(tag))

  /** Entity class storing rows of table Addresses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param streetAddress Database column street_address SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param city Database column city SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param zipCode Database column zip_code SqlType(VARCHAR), Length(16,true), Default(None)
   *  @param state Database column state SqlType(VARCHAR), Length(30,true), Default(None)
   *  @param countryCode Database column country_code SqlType(VARCHAR), Length(5,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class AddressesRow(id: Int, streetAddress: Option[String] = None, city: Option[String] = None, zipCode: Option[String] = None, state: Option[String] = None, countryCode: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching AddressesRow objects using plain SQL queries */
  implicit def GetResultAddressesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]]): GR[AddressesRow] = GR{
    prs => import prs._
    AddressesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table addresses. Objects of this class serve as prototypes for rows in queries. */
  class Addresses(_tableTag: Tag) extends Table[AddressesRow](_tableTag, "addresses") {
    def * = (id, streetAddress, city, zipCode, state, countryCode, createdAt, updatedAt) <> (AddressesRow.tupled, AddressesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), streetAddress, city, zipCode, state, countryCode, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> AddressesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column street_address SqlType(VARCHAR), Length(255,true), Default(None) */
    val streetAddress: Rep[Option[String]] = column[Option[String]]("street_address", O.Length(255,varying=true), O.Default(None))
    /** Database column city SqlType(VARCHAR), Length(100,true), Default(None) */
    val city: Rep[Option[String]] = column[Option[String]]("city", O.Length(100,varying=true), O.Default(None))
    /** Database column zip_code SqlType(VARCHAR), Length(16,true), Default(None) */
    val zipCode: Rep[Option[String]] = column[Option[String]]("zip_code", O.Length(16,varying=true), O.Default(None))
    /** Database column state SqlType(VARCHAR), Length(30,true), Default(None) */
    val state: Rep[Option[String]] = column[Option[String]]("state", O.Length(30,varying=true), O.Default(None))
    /** Database column country_code SqlType(VARCHAR), Length(5,true), Default(None) */
    val countryCode: Rep[Option[String]] = column[Option[String]]("country_code", O.Length(5,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table Addresses */
  lazy val Addresses = new TableQuery(tag => new Addresses(tag))

  /** Row type of table Admins */
  type AdminsRow = HCons[Int,HCons[String,HCons[String,HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Int,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for AdminsRow providing default values if available in the database schema. */
  def AdminsRow(id: Int, email: String = "", encryptedPassword: String = "", resetPasswordToken: Option[String] = None, resetPasswordSentAt: Option[java.sql.Timestamp] = None, rememberCreatedAt: Option[java.sql.Timestamp] = None, signInCount: Int = 0, currentSignInAt: Option[java.sql.Timestamp] = None, lastSignInAt: Option[java.sql.Timestamp] = None, currentSignInIp: Option[String] = None, lastSignInIp: Option[String] = None, name: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, publicName: Option[String] = None, publicAvatarFileName: Option[String] = None, publicAvatarContentType: Option[String] = None, publicAvatarFileSize: Option[Int] = None, publicAvatarUpdatedAt: Option[java.sql.Timestamp] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, notes: Option[String] = None): AdminsRow = {
    id :: email :: encryptedPassword :: resetPasswordToken :: resetPasswordSentAt :: rememberCreatedAt :: signInCount :: currentSignInAt :: lastSignInAt :: currentSignInIp :: lastSignInIp :: name :: createdAt :: updatedAt :: publicName :: publicAvatarFileName :: publicAvatarContentType :: publicAvatarFileSize :: publicAvatarUpdatedAt :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: notes :: HNil
  }
  /** GetResult implicit for fetching AdminsRow objects using plain SQL queries */
  implicit def GetResultAdminsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Int]]): GR[AdminsRow] = GR{
    prs => import prs._
    <<[Int] :: <<[String] :: <<[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[String] :: HNil
  }
  /** Table description of table admins. Objects of this class serve as prototypes for rows in queries. */
  class Admins(_tableTag: Tag) extends Table[AdminsRow](_tableTag, "admins") {
    def * = id :: email :: encryptedPassword :: resetPasswordToken :: resetPasswordSentAt :: rememberCreatedAt :: signInCount :: currentSignInAt :: lastSignInAt :: currentSignInIp :: lastSignInIp :: name :: createdAt :: updatedAt :: publicName :: publicAvatarFileName :: publicAvatarContentType :: publicAvatarFileSize :: publicAvatarUpdatedAt :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: notes :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column email SqlType(VARCHAR), Length(255,true), Default() */
    val email: Rep[String] = column[String]("email", O.Length(255,varying=true), O.Default(""))
    /** Database column encrypted_password SqlType(VARCHAR), Length(255,true), Default() */
    val encryptedPassword: Rep[String] = column[String]("encrypted_password", O.Length(255,varying=true), O.Default(""))
    /** Database column reset_password_token SqlType(VARCHAR), Length(255,true), Default(None) */
    val resetPasswordToken: Rep[Option[String]] = column[Option[String]]("reset_password_token", O.Length(255,varying=true), O.Default(None))
    /** Database column reset_password_sent_at SqlType(DATETIME), Default(None) */
    val resetPasswordSentAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("reset_password_sent_at", O.Default(None))
    /** Database column remember_created_at SqlType(DATETIME), Default(None) */
    val rememberCreatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("remember_created_at", O.Default(None))
    /** Database column sign_in_count SqlType(INT), Default(0) */
    val signInCount: Rep[Int] = column[Int]("sign_in_count", O.Default(0))
    /** Database column current_sign_in_at SqlType(DATETIME), Default(None) */
    val currentSignInAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("current_sign_in_at", O.Default(None))
    /** Database column last_sign_in_at SqlType(DATETIME), Default(None) */
    val lastSignInAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("last_sign_in_at", O.Default(None))
    /** Database column current_sign_in_ip SqlType(VARCHAR), Length(255,true), Default(None) */
    val currentSignInIp: Rep[Option[String]] = column[Option[String]]("current_sign_in_ip", O.Length(255,varying=true), O.Default(None))
    /** Database column last_sign_in_ip SqlType(VARCHAR), Length(255,true), Default(None) */
    val lastSignInIp: Rep[Option[String]] = column[Option[String]]("last_sign_in_ip", O.Length(255,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column public_name SqlType(VARCHAR), Length(100,true), Default(None) */
    val publicName: Rep[Option[String]] = column[Option[String]]("public_name", O.Length(100,varying=true), O.Default(None))
    /** Database column public_avatar_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val publicAvatarFileName: Rep[Option[String]] = column[Option[String]]("public_avatar_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column public_avatar_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val publicAvatarContentType: Rep[Option[String]] = column[Option[String]]("public_avatar_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column public_avatar_file_size SqlType(INT), Default(None) */
    val publicAvatarFileSize: Rep[Option[Int]] = column[Option[Int]]("public_avatar_file_size", O.Default(None))
    /** Database column public_avatar_updated_at SqlType(DATETIME), Default(None) */
    val publicAvatarUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("public_avatar_updated_at", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column notes SqlType(TEXT), Default(None) */
    val notes: Rep[Option[String]] = column[Option[String]]("notes", O.Default(None))

    /** Uniqueness Index over (email) (database name index_admins_on_email) */
    val index1 = index("index_admins_on_email", email :: HNil, unique=true)
    /** Uniqueness Index over (resetPasswordToken) (database name index_admins_on_reset_password_token) */
    val index2 = index("index_admins_on_reset_password_token", resetPasswordToken :: HNil, unique=true)
  }
  /** Collection-like TableQuery object for table Admins */
  lazy val Admins = new TableQuery(tag => new Admins(tag))

  /** Entity class storing rows of table ApplicationLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param applicationId Database column application_id SqlType(INT), Default(None)
   *  @param locationId Database column location_id SqlType(INT), Default(None)
   *  @param storeSalt Database column store_salt SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ApplicationLocationsRow(id: Int, applicationId: Option[Int] = None, locationId: Option[Int] = None, storeSalt: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ApplicationLocationsRow objects using plain SQL queries */
  implicit def GetResultApplicationLocationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ApplicationLocationsRow] = GR{
    prs => import prs._
    ApplicationLocationsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table application_locations. Objects of this class serve as prototypes for rows in queries. */
  class ApplicationLocations(_tableTag: Tag) extends Table[ApplicationLocationsRow](_tableTag, "application_locations") {
    def * = (id, applicationId, locationId, storeSalt, createdAt, updatedAt) <> (ApplicationLocationsRow.tupled, ApplicationLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), applicationId, locationId, storeSalt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ApplicationLocationsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column application_id SqlType(INT), Default(None) */
    val applicationId: Rep[Option[Int]] = column[Option[Int]]("application_id", O.Default(None))
    /** Database column location_id SqlType(INT), Default(None) */
    val locationId: Rep[Option[Int]] = column[Option[Int]]("location_id", O.Default(None))
    /** Database column store_salt SqlType(VARCHAR), Length(255,true), Default(None) */
    val storeSalt: Rep[Option[String]] = column[Option[String]]("store_salt", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (applicationId) (database name index_application_locations_on_application_id) */
    val index1 = index("index_application_locations_on_application_id", applicationId)
    /** Uniqueness Index over (applicationId,locationId) (database name index_application_locations_on_application_id_and_location_id) */
    val index2 = index("index_application_locations_on_application_id_and_location_id", (applicationId, locationId), unique=true)
    /** Index over (locationId) (database name index_application_locations_on_location_id) */
    val index3 = index("index_application_locations_on_location_id", locationId)
  }
  /** Collection-like TableQuery object for table ApplicationLocations */
  lazy val ApplicationLocations = new TableQuery(tag => new ApplicationLocations(tag))

  /** Entity class storing rows of table Assignments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param adminId Database column admin_id SqlType(INT)
   *  @param assignableId Database column assignable_id SqlType(INT)
   *  @param assignableType Database column assignable_type SqlType(VARCHAR), Length(255,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class AssignmentsRow(id: Int, adminId: Int, assignableId: Int, assignableType: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching AssignmentsRow objects using plain SQL queries */
  implicit def GetResultAssignmentsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[java.sql.Timestamp]]): GR[AssignmentsRow] = GR{
    prs => import prs._
    AssignmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table assignments. Objects of this class serve as prototypes for rows in queries. */
  class Assignments(_tableTag: Tag) extends Table[AssignmentsRow](_tableTag, "assignments") {
    def * = (id, adminId, assignableId, assignableType, createdAt, updatedAt) <> (AssignmentsRow.tupled, AssignmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(adminId), Rep.Some(assignableId), Rep.Some(assignableType), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> AssignmentsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column admin_id SqlType(INT) */
    val adminId: Rep[Int] = column[Int]("admin_id")
    /** Database column assignable_id SqlType(INT) */
    val assignableId: Rep[Int] = column[Int]("assignable_id")
    /** Database column assignable_type SqlType(VARCHAR), Length(255,true) */
    val assignableType: Rep[String] = column[String]("assignable_type", O.Length(255,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (adminId) (database name index_assignments_on_admin_id) */
    val index1 = index("index_assignments_on_admin_id", adminId)
  }
  /** Collection-like TableQuery object for table Assignments */
  lazy val Assignments = new TableQuery(tag => new Assignments(tag))

  /** Entity class storing rows of table Attachments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileName Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileContentType Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileSize Database column file_file_size SqlType(INT), Default(None)
   *  @param fileUpdatedAt Database column file_updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param ownerId Database column owner_id SqlType(INT), Default(None)
   *  @param ownerType Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None) */
  case class AttachmentsRow(id: Int, name: Option[String] = None, fileFileName: Option[String] = None, fileContentType: Option[String] = None, fileFileSize: Option[Int] = None, fileUpdatedAt: Option[java.sql.Timestamp] = None, programId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, `type`: Option[String] = None, ownerId: Option[Int] = None, ownerType: Option[String] = None, label: Option[String] = None, description: Option[String] = None)
  /** GetResult implicit for fetching AttachmentsRow objects using plain SQL queries */
  implicit def GetResultAttachmentsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]]): GR[AttachmentsRow] = GR{
    prs => import prs._
    AttachmentsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[String]))
  }
  /** Table description of table attachments. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Attachments(_tableTag: Tag) extends Table[AttachmentsRow](_tableTag, "attachments") {
    def * = (id, name, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, programId, createdAt, updatedAt, `type`, ownerId, ownerType, label, description) <> (AttachmentsRow.tupled, AttachmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, programId, createdAt, updatedAt, `type`, ownerId, ownerType, label, description).shaped.<>({r=>import r._; _1.map(_=> AttachmentsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileFileName: Rep[Option[String]] = column[Option[String]]("file_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileContentType: Rep[Option[String]] = column[Option[String]]("file_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_size SqlType(INT), Default(None) */
    val fileFileSize: Rep[Option[Int]] = column[Option[Int]]("file_file_size", O.Default(None))
    /** Database column file_updated_at SqlType(DATETIME), Default(None) */
    val fileUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("file_updated_at", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column owner_id SqlType(INT), Default(None) */
    val ownerId: Rep[Option[Int]] = column[Option[Int]]("owner_id", O.Default(None))
    /** Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ownerType: Rep[Option[String]] = column[Option[String]]("owner_type", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))

    /** Index over (ownerId,ownerType) (database name index_attachments_on_owner_id_and_owner_type) */
    val index1 = index("index_attachments_on_owner_id_and_owner_type", (ownerId, ownerType))
    /** Index over (programId) (database name index_attachments_on_program_id) */
    val index2 = index("index_attachments_on_program_id", programId)
  }
  /** Collection-like TableQuery object for table Attachments */
  lazy val Attachments = new TableQuery(tag => new Attachments(tag))

  /** Entity class storing rows of table AudienceFactors
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param templateValues Database column template_values SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param objective Database column objective SqlType(BIT), Default(Some(false)) */
  case class AudienceFactorsRow(id: Int, entityId: Option[Int] = None, entityType: Option[String] = None, `type`: Option[String] = None, templateValues: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, objective: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching AudienceFactorsRow objects using plain SQL queries */
  implicit def GetResultAudienceFactorsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]]): GR[AudienceFactorsRow] = GR{
    prs => import prs._
    AudienceFactorsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean]))
  }
  /** Table description of table audience_factors. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class AudienceFactors(_tableTag: Tag) extends Table[AudienceFactorsRow](_tableTag, "audience_factors") {
    def * = (id, entityId, entityType, `type`, templateValues, createdAt, updatedAt, objective) <> (AudienceFactorsRow.tupled, AudienceFactorsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), entityId, entityType, `type`, templateValues, createdAt, updatedAt, objective).shaped.<>({r=>import r._; _1.map(_=> AudienceFactorsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column template_values SqlType(TEXT), Default(None) */
    val templateValues: Rep[Option[String]] = column[Option[String]]("template_values", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column objective SqlType(BIT), Default(Some(false)) */
    val objective: Rep[Option[Boolean]] = column[Option[Boolean]]("objective", O.Default(Some(false)))
  }
  /** Collection-like TableQuery object for table AudienceFactors */
  lazy val AudienceFactors = new TableQuery(tag => new AudienceFactors(tag))

  /** Entity class storing rows of table Awards
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param awardableId Database column awardable_id SqlType(INT), Default(None)
   *  @param awardableType Database column awardable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param awardedAt Database column awarded_at SqlType(DATETIME), Default(None)
   *  @param claimedAt Database column claimed_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param adminId Database column admin_id SqlType(INT), Default(None)
   *  @param reason Database column reason SqlType(TEXT), Default(None) */
  case class AwardsRow(id: Int, awardableId: Option[Int] = None, awardableType: Option[String] = None, memberId: Option[Int] = None, status: Option[String] = None, code: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, awardedAt: Option[java.sql.Timestamp] = None, claimedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, adminId: Option[Int] = None, reason: Option[String] = None)
  /** GetResult implicit for fetching AwardsRow objects using plain SQL queries */
  implicit def GetResultAwardsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[AwardsRow] = GR{
    prs => import prs._
    AwardsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String]))
  }
  /** Table description of table awards. Objects of this class serve as prototypes for rows in queries. */
  class Awards(_tableTag: Tag) extends Table[AwardsRow](_tableTag, "awards") {
    def * = (id, awardableId, awardableType, memberId, status, code, effectivityStart, effectivityEnd, effectivityTimezone, awardedAt, claimedAt, createdAt, updatedAt, adminId, reason) <> (AwardsRow.tupled, AwardsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), awardableId, awardableType, memberId, status, code, effectivityStart, effectivityEnd, effectivityTimezone, awardedAt, claimedAt, createdAt, updatedAt, adminId, reason).shaped.<>({r=>import r._; _1.map(_=> AwardsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column awardable_id SqlType(INT), Default(None) */
    val awardableId: Rep[Option[Int]] = column[Option[Int]]("awardable_id", O.Default(None))
    /** Database column awardable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val awardableType: Rep[Option[String]] = column[Option[String]]("awardable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(50,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(50,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column awarded_at SqlType(DATETIME), Default(None) */
    val awardedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("awarded_at", O.Default(None))
    /** Database column claimed_at SqlType(DATETIME), Default(None) */
    val claimedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("claimed_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column admin_id SqlType(INT), Default(None) */
    val adminId: Rep[Option[Int]] = column[Option[Int]]("admin_id", O.Default(None))
    /** Database column reason SqlType(TEXT), Default(None) */
    val reason: Rep[Option[String]] = column[Option[String]]("reason", O.Default(None))

    /** Index over (adminId) (database name index_awards_on_admin_id) */
    val index1 = index("index_awards_on_admin_id", adminId)
    /** Index over (awardableId,awardableType) (database name index_awards_on_awardable_id_and_awardable_type) */
    val index2 = index("index_awards_on_awardable_id_and_awardable_type", (awardableId, awardableType))
    /** Index over (memberId) (database name index_awards_on_member_id) */
    val index3 = index("index_awards_on_member_id", memberId)
  }
  /** Collection-like TableQuery object for table Awards */
  lazy val Awards = new TableQuery(tag => new Awards(tag))

  /** Entity class storing rows of table BackgroundJobs
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param subjectId Database column subject_id SqlType(INT), Default(None)
   *  @param subjectType Database column subject_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param startedAt Database column started_at SqlType(DATETIME), Default(None)
   *  @param finishedAt Database column finished_at SqlType(DATETIME), Default(None)
   *  @param worker Database column worker SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param messageId Database column message_id SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param queue Database column queue SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param lastMessage Database column last_message SqlType(TEXT), Default(None)
   *  @param logFileName Database column log_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param logContentType Database column log_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param logFileSize Database column log_file_size SqlType(INT), Default(None)
   *  @param logUpdatedAt Database column log_updated_at SqlType(DATETIME), Default(None) */
  case class BackgroundJobsRow(id: Int, subjectId: Option[Int] = None, subjectType: Option[String] = None, status: Option[String] = None, startedAt: Option[java.sql.Timestamp] = None, finishedAt: Option[java.sql.Timestamp] = None, worker: Option[String] = None, messageId: Option[String] = None, queue: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, lastMessage: Option[String] = None, logFileName: Option[String] = None, logContentType: Option[String] = None, logFileSize: Option[Int] = None, logUpdatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BackgroundJobsRow objects using plain SQL queries */
  implicit def GetResultBackgroundJobsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[BackgroundJobsRow] = GR{
    prs => import prs._
    BackgroundJobsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp]))
  }
  /** Table description of table background_jobs. Objects of this class serve as prototypes for rows in queries. */
  class BackgroundJobs(_tableTag: Tag) extends Table[BackgroundJobsRow](_tableTag, "background_jobs") {
    def * = (id, subjectId, subjectType, status, startedAt, finishedAt, worker, messageId, queue, createdAt, updatedAt, lastMessage, logFileName, logContentType, logFileSize, logUpdatedAt) <> (BackgroundJobsRow.tupled, BackgroundJobsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), subjectId, subjectType, status, startedAt, finishedAt, worker, messageId, queue, createdAt, updatedAt, lastMessage, logFileName, logContentType, logFileSize, logUpdatedAt).shaped.<>({r=>import r._; _1.map(_=> BackgroundJobsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column subject_id SqlType(INT), Default(None) */
    val subjectId: Rep[Option[Int]] = column[Option[Int]]("subject_id", O.Default(None))
    /** Database column subject_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val subjectType: Rep[Option[String]] = column[Option[String]]("subject_type", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(None))
    /** Database column started_at SqlType(DATETIME), Default(None) */
    val startedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("started_at", O.Default(None))
    /** Database column finished_at SqlType(DATETIME), Default(None) */
    val finishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("finished_at", O.Default(None))
    /** Database column worker SqlType(VARCHAR), Length(255,true), Default(None) */
    val worker: Rep[Option[String]] = column[Option[String]]("worker", O.Length(255,varying=true), O.Default(None))
    /** Database column message_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val messageId: Rep[Option[String]] = column[Option[String]]("message_id", O.Length(255,varying=true), O.Default(None))
    /** Database column queue SqlType(VARCHAR), Length(255,true), Default(None) */
    val queue: Rep[Option[String]] = column[Option[String]]("queue", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column last_message SqlType(TEXT), Default(None) */
    val lastMessage: Rep[Option[String]] = column[Option[String]]("last_message", O.Default(None))
    /** Database column log_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val logFileName: Rep[Option[String]] = column[Option[String]]("log_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column log_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val logContentType: Rep[Option[String]] = column[Option[String]]("log_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column log_file_size SqlType(INT), Default(None) */
    val logFileSize: Rep[Option[Int]] = column[Option[Int]]("log_file_size", O.Default(None))
    /** Database column log_updated_at SqlType(DATETIME), Default(None) */
    val logUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("log_updated_at", O.Default(None))

    /** Index over (subjectId,subjectType) (database name index_background_jobs_on_subject_id_and_subject_type) */
    val index1 = index("index_background_jobs_on_subject_id_and_subject_type", (subjectId, subjectType))
  }
  /** Collection-like TableQuery object for table BackgroundJobs */
  lazy val BackgroundJobs = new TableQuery(tag => new BackgroundJobs(tag))

  /** Entity class storing rows of table BadgeGrantRules
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param badgeLevelId Database column badge_level_id SqlType(INT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class BadgeGrantRulesRow(id: Int, badgeLevelId: Option[Int] = None, `type`: Option[String] = None, definition: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BadgeGrantRulesRow objects using plain SQL queries */
  implicit def GetResultBadgeGrantRulesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[BadgeGrantRulesRow] = GR{
    prs => import prs._
    BadgeGrantRulesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table badge_grant_rules. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class BadgeGrantRules(_tableTag: Tag) extends Table[BadgeGrantRulesRow](_tableTag, "badge_grant_rules") {
    def * = (id, badgeLevelId, `type`, definition, description, createdAt, updatedAt) <> (BadgeGrantRulesRow.tupled, BadgeGrantRulesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), badgeLevelId, `type`, definition, description, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> BadgeGrantRulesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column badge_level_id SqlType(INT), Default(None) */
    val badgeLevelId: Rep[Option[Int]] = column[Option[Int]]("badge_level_id", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(100,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(100,varying=true), O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (badgeLevelId) (database name index_badge_grant_rules_on_badge_level_id) */
    val index1 = index("index_badge_grant_rules_on_badge_level_id", badgeLevelId)
  }
  /** Collection-like TableQuery object for table BadgeGrantRules */
  lazy val BadgeGrantRules = new TableQuery(tag => new BadgeGrantRules(tag))

  /** Entity class storing rows of table BadgeLevels
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param badgeId Database column badge_id SqlType(INT), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class BadgeLevelsRow(id: Int, name: String, label: String, programId: Option[Int] = None, badgeId: Option[Int] = None, description: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, rowOrder: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BadgeLevelsRow objects using plain SQL queries */
  implicit def GetResultBadgeLevelsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[Int]], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]]): GR[BadgeLevelsRow] = GR{
    prs => import prs._
    BadgeLevelsRow.tupled((<<[Int], <<[String], <<[String], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table badge_levels. Objects of this class serve as prototypes for rows in queries. */
  class BadgeLevels(_tableTag: Tag) extends Table[BadgeLevelsRow](_tableTag, "badge_levels") {
    def * = (id, name, label, programId, badgeId, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, rowOrder, createdAt, updatedAt) <> (BadgeLevelsRow.tupled, BadgeLevelsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), programId, badgeId, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, rowOrder, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> BadgeLevelsRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column badge_id SqlType(INT), Default(None) */
    val badgeId: Rep[Option[Int]] = column[Option[Int]]("badge_id", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (badgeId,rowOrder) (database name index_badge_levels_on_badge_id_and_row_order) */
    val index1 = index("index_badge_levels_on_badge_id_and_row_order", (badgeId, rowOrder), unique=true)
  }
  /** Collection-like TableQuery object for table BadgeLevels */
  lazy val BadgeLevels = new TableQuery(tag => new BadgeLevels(tag))

  /** Entity class storing rows of table BadgeLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param locationId Database column location_id SqlType(INT), Default(None)
   *  @param badgeId Database column badge_id SqlType(INT), Default(None)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(false))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class BadgeLocationsRow(id: Int, locationId: Option[Int] = None, badgeId: Option[Int] = None, locationType: Option[String] = None, included: Option[Boolean] = Some(false), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BadgeLocationsRow objects using plain SQL queries */
  implicit def GetResultBadgeLocationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]], e4: GR[Option[java.sql.Timestamp]]): GR[BadgeLocationsRow] = GR{
    prs => import prs._
    BadgeLocationsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table badge_locations. Objects of this class serve as prototypes for rows in queries. */
  class BadgeLocations(_tableTag: Tag) extends Table[BadgeLocationsRow](_tableTag, "badge_locations") {
    def * = (id, locationId, badgeId, locationType, included, createdAt, updatedAt) <> (BadgeLocationsRow.tupled, BadgeLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), locationId, badgeId, locationType, included, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> BadgeLocationsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column location_id SqlType(INT), Default(None) */
    val locationId: Rep[Option[Int]] = column[Option[Int]]("location_id", O.Default(None))
    /** Database column badge_id SqlType(INT), Default(None) */
    val badgeId: Rep[Option[Int]] = column[Option[Int]]("badge_id", O.Default(None))
    /** Database column location_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val locationType: Rep[Option[String]] = column[Option[String]]("location_type", O.Length(25,varying=true), O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(false)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(false)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (badgeId,locationId) (database name index_badge_locations_on_badge_id_and_location_id) */
    val index1 = index("index_badge_locations_on_badge_id_and_location_id", (badgeId, locationId), unique=true)
    /** Index over (locationId) (database name index_badge_locations_on_location_id) */
    val index2 = index("index_badge_locations_on_location_id", locationId)
  }
  /** Collection-like TableQuery object for table BadgeLocations */
  lazy val BadgeLocations = new TableQuery(tag => new BadgeLocations(tag))

  /** Entity class storing rows of table Badges
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param programId Database column program_id SqlType(INT)
   *  @param `type` Database column type SqlType(VARCHAR), Length(30,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param levels Database column levels SqlType(INT), Default(Some(1))
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None)
   *  @param rewardId Database column reward_id SqlType(INT), Default(None)
   *  @param expirationInterval Database column expiration_interval SqlType(INT), Default(None)
   *  @param expirationIntervalPeriod Database column expiration_interval_period SqlType(VARCHAR), Length(10,true), Default(None)
   *  @param newsFeedId Database column news_feed_id SqlType(INT), Default(None)
   *  @param shareOnNewsFeed Database column share_on_news_feed SqlType(VARCHAR), Length(255,true), Default(None) */
  case class BadgesRow(id: Int, name: String, label: String, description: Option[String] = None, programId: Int, `type`: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, levels: Option[Int] = Some(1), publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, rewardId: Option[Int] = None, expirationInterval: Option[Int] = None, expirationIntervalPeriod: Option[String] = None, newsFeedId: Option[Int] = None, shareOnNewsFeed: Option[String] = None)
  /** GetResult implicit for fetching BadgesRow objects using plain SQL queries */
  implicit def GetResultBadgesRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Int]], e5: GR[Option[Boolean]]): GR[BadgesRow] = GR{
    prs => import prs._
    BadgesRow.tupled((<<[Int], <<[String], <<[String], <<?[String], <<[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[java.sql.Timestamp], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Boolean], <<?[String], <<?[Int], <<?[Int], <<?[String], <<?[Int], <<?[String]))
  }
  /** Table description of table badges. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Badges(_tableTag: Tag) extends Table[BadgesRow](_tableTag, "badges") {
    def * = (id, name, label, description, programId, `type`, createdAt, updatedAt, levels, publishedAt, status, effectivityStart, effectivityEnd, effectivityTimezone, recurring, recurringSchedule, rewardId, expirationInterval, expirationIntervalPeriod, newsFeedId, shareOnNewsFeed) <> (BadgesRow.tupled, BadgesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), description, Rep.Some(programId), `type`, createdAt, updatedAt, levels, publishedAt, Rep.Some(status), effectivityStart, effectivityEnd, effectivityTimezone, recurring, recurringSchedule, rewardId, expirationInterval, expirationIntervalPeriod, newsFeedId, shareOnNewsFeed).shaped.<>({r=>import r._; _1.map(_=> BadgesRow.tupled((_1.get, _2.get, _3.get, _4, _5.get, _6, _7, _8, _9, _10, _11.get, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column program_id SqlType(INT) */
    val programId: Rep[Int] = column[Int]("program_id")
    /** Database column type SqlType(VARCHAR), Length(30,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(30,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column levels SqlType(INT), Default(Some(1)) */
    val levels: Rep[Option[Int]] = column[Option[Int]]("levels", O.Default(Some(1)))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column reward_id SqlType(INT), Default(None) */
    val rewardId: Rep[Option[Int]] = column[Option[Int]]("reward_id", O.Default(None))
    /** Database column expiration_interval SqlType(INT), Default(None) */
    val expirationInterval: Rep[Option[Int]] = column[Option[Int]]("expiration_interval", O.Default(None))
    /** Database column expiration_interval_period SqlType(VARCHAR), Length(10,true), Default(None) */
    val expirationIntervalPeriod: Rep[Option[String]] = column[Option[String]]("expiration_interval_period", O.Length(10,varying=true), O.Default(None))
    /** Database column news_feed_id SqlType(INT), Default(None) */
    val newsFeedId: Rep[Option[Int]] = column[Option[Int]]("news_feed_id", O.Default(None))
    /** Database column share_on_news_feed SqlType(VARCHAR), Length(255,true), Default(None) */
    val shareOnNewsFeed: Rep[Option[String]] = column[Option[String]]("share_on_news_feed", O.Length(255,varying=true), O.Default(None))
  }
  /** Collection-like TableQuery object for table Badges */
  lazy val Badges = new TableQuery(tag => new Badges(tag))

  /** Entity class storing rows of table BadgeSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param badgeId Database column badge_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(Some(true))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class BadgeSegmentsRow(id: Int, segmentId: Int, badgeId: Int, included: Option[Boolean] = Some(true), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BadgeSegmentsRow objects using plain SQL queries */
  implicit def GetResultBadgeSegmentsRow(implicit e0: GR[Int], e1: GR[Option[Boolean]], e2: GR[Option[java.sql.Timestamp]]): GR[BadgeSegmentsRow] = GR{
    prs => import prs._
    BadgeSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table badge_segments. Objects of this class serve as prototypes for rows in queries. */
  class BadgeSegments(_tableTag: Tag) extends Table[BadgeSegmentsRow](_tableTag, "badge_segments") {
    def * = (id, segmentId, badgeId, included, createdAt, updatedAt) <> (BadgeSegmentsRow.tupled, BadgeSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(segmentId), Rep.Some(badgeId), included, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> BadgeSegmentsRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column badge_id SqlType(INT) */
    val badgeId: Rep[Int] = column[Int]("badge_id")
    /** Database column included SqlType(BIT), Default(Some(true)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(true)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (badgeId,segmentId) (database name index_badge_segments_on_badge_id_and_segment_id) */
    val index1 = index("index_badge_segments_on_badge_id_and_segment_id", (badgeId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_badge_segments_on_segment_id) */
    val index2 = index("index_badge_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table BadgeSegments */
  lazy val BadgeSegments = new TableQuery(tag => new BadgeSegments(tag))

  /** Entity class storing rows of table BeaconLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param beaconId Database column beacon_id SqlType(INT), Default(None)
   *  @param locationId Database column location_id SqlType(INT), Default(None)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param x Database column x SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param y Database column y SqlType(VARCHAR), Length(25,true), Default(None) */
  case class BeaconLocationsRow(id: Int, beaconId: Option[Int] = None, locationId: Option[Int] = None, locationType: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, x: Option[String] = None, y: Option[String] = None)
  /** GetResult implicit for fetching BeaconLocationsRow objects using plain SQL queries */
  implicit def GetResultBeaconLocationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[BeaconLocationsRow] = GR{
    prs => import prs._
    BeaconLocationsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String]))
  }
  /** Table description of table beacon_locations. Objects of this class serve as prototypes for rows in queries. */
  class BeaconLocations(_tableTag: Tag) extends Table[BeaconLocationsRow](_tableTag, "beacon_locations") {
    def * = (id, beaconId, locationId, locationType, createdAt, updatedAt, x, y) <> (BeaconLocationsRow.tupled, BeaconLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), beaconId, locationId, locationType, createdAt, updatedAt, x, y).shaped.<>({r=>import r._; _1.map(_=> BeaconLocationsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column beacon_id SqlType(INT), Default(None) */
    val beaconId: Rep[Option[Int]] = column[Option[Int]]("beacon_id", O.Default(None))
    /** Database column location_id SqlType(INT), Default(None) */
    val locationId: Rep[Option[Int]] = column[Option[Int]]("location_id", O.Default(None))
    /** Database column location_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val locationType: Rep[Option[String]] = column[Option[String]]("location_type", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column x SqlType(VARCHAR), Length(25,true), Default(None) */
    val x: Rep[Option[String]] = column[Option[String]]("x", O.Length(25,varying=true), O.Default(None))
    /** Database column y SqlType(VARCHAR), Length(25,true), Default(None) */
    val y: Rep[Option[String]] = column[Option[String]]("y", O.Length(25,varying=true), O.Default(None))

    /** Uniqueness Index over (beaconId,locationId) (database name index_beacon_locations_on_beacon_id_and_location_id) */
    val index1 = index("index_beacon_locations_on_beacon_id_and_location_id", (beaconId, locationId), unique=true)
    /** Index over (locationId) (database name index_beacon_locations_on_location_id) */
    val index2 = index("index_beacon_locations_on_location_id", locationId)
  }
  /** Collection-like TableQuery object for table BeaconLocations */
  lazy val BeaconLocations = new TableQuery(tag => new BeaconLocations(tag))

  /** Entity class storing rows of table Beacons
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param uuid Database column uuid SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param major Database column major SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param minor Database column minor SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(75,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
  case class BeaconsRow(id: Int, programId: Option[Int] = None, uuid: Option[String] = None, major: Option[String] = None, minor: Option[String] = None, name: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, label: Option[String] = None)
  /** GetResult implicit for fetching BeaconsRow objects using plain SQL queries */
  implicit def GetResultBeaconsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[BeaconsRow] = GR{
    prs => import prs._
    BeaconsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table beacons. Objects of this class serve as prototypes for rows in queries. */
  class Beacons(_tableTag: Tag) extends Table[BeaconsRow](_tableTag, "beacons") {
    def * = (id, programId, uuid, major, minor, name, createdAt, updatedAt, label) <> (BeaconsRow.tupled, BeaconsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), programId, uuid, major, minor, name, createdAt, updatedAt, label).shaped.<>({r=>import r._; _1.map(_=> BeaconsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column uuid SqlType(VARCHAR), Length(100,true), Default(None) */
    val uuid: Rep[Option[String]] = column[Option[String]]("uuid", O.Length(100,varying=true), O.Default(None))
    /** Database column major SqlType(VARCHAR), Length(50,true), Default(None) */
    val major: Rep[Option[String]] = column[Option[String]]("major", O.Length(50,varying=true), O.Default(None))
    /** Database column minor SqlType(VARCHAR), Length(50,true), Default(None) */
    val minor: Rep[Option[String]] = column[Option[String]]("minor", O.Length(50,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(75,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(75,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))

    /** Uniqueness Index over (name) (database name index_beacons_on_name) */
    val index1 = index("index_beacons_on_name", name, unique=true)
    /** Uniqueness Index over (uuid,major,minor) (database name index_beacons_on_uuid_and_major_and_minor) */
    val index2 = index("index_beacons_on_uuid_and_major_and_minor", (uuid, major, minor), unique=true)
  }
  /** Collection-like TableQuery object for table Beacons */
  lazy val Beacons = new TableQuery(tag => new Beacons(tag))

  /** Entity class storing rows of table BigdataQueries
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param queryType Database column query_type SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param sparkQueryString Database column spark_query_string SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param visualization Database column visualization SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param queryFile Database column query_file SqlType(BIT), Default(Some(false))
   *  @param spreadsheetFileName Database column spreadsheet_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param spreadsheetContentType Database column spreadsheet_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param spreadsheetFileSize Database column spreadsheet_file_size SqlType(INT), Default(None)
   *  @param spreadsheetUpdatedAt Database column spreadsheet_updated_at SqlType(DATETIME), Default(None)
   *  @param executionType Database column execution_type SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param phoenixQueryString Database column phoenix_query_string SqlType(TEXT), Default(None)
   *  @param sqlQueryString Database column sql_query_string SqlType(TEXT), Default(None)
   *  @param ownerType Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param ownerId Database column owner_id SqlType(INT), Default(None) */
  case class BigdataQueriesRow(id: Int, name: Option[String] = None, label: String, description: Option[String] = None, queryType: Option[String] = None, sparkQueryString: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, visualization: Option[String] = None, queryFile: Option[Boolean] = Some(false), spreadsheetFileName: Option[String] = None, spreadsheetContentType: Option[String] = None, spreadsheetFileSize: Option[Int] = None, spreadsheetUpdatedAt: Option[java.sql.Timestamp] = None, executionType: Option[String] = None, phoenixQueryString: Option[String] = None, sqlQueryString: Option[String] = None, ownerType: Option[String] = None, ownerId: Option[Int] = None)
  /** GetResult implicit for fetching BigdataQueriesRow objects using plain SQL queries */
  implicit def GetResultBigdataQueriesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[String], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]], e5: GR[Option[Int]]): GR[BigdataQueriesRow] = GR{
    prs => import prs._
    BigdataQueriesRow.tupled((<<[Int], <<?[String], <<[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Boolean], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int]))
  }
  /** Table description of table bigdata_queries. Objects of this class serve as prototypes for rows in queries. */
  class BigdataQueries(_tableTag: Tag) extends Table[BigdataQueriesRow](_tableTag, "bigdata_queries") {
    def * = (id, name, label, description, queryType, sparkQueryString, createdAt, updatedAt, visualization, queryFile, spreadsheetFileName, spreadsheetContentType, spreadsheetFileSize, spreadsheetUpdatedAt, executionType, phoenixQueryString, sqlQueryString, ownerType, ownerId) <> (BigdataQueriesRow.tupled, BigdataQueriesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, Rep.Some(label), description, queryType, sparkQueryString, createdAt, updatedAt, visualization, queryFile, spreadsheetFileName, spreadsheetContentType, spreadsheetFileSize, spreadsheetUpdatedAt, executionType, phoenixQueryString, sqlQueryString, ownerType, ownerId).shaped.<>({r=>import r._; _1.map(_=> BigdataQueriesRow.tupled((_1.get, _2, _3.get, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(100,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(100,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column query_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val queryType: Rep[Option[String]] = column[Option[String]]("query_type", O.Length(25,varying=true), O.Default(None))
    /** Database column spark_query_string SqlType(TEXT), Default(None) */
    val sparkQueryString: Rep[Option[String]] = column[Option[String]]("spark_query_string", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column visualization SqlType(VARCHAR), Length(25,true), Default(None) */
    val visualization: Rep[Option[String]] = column[Option[String]]("visualization", O.Length(25,varying=true), O.Default(None))
    /** Database column query_file SqlType(BIT), Default(Some(false)) */
    val queryFile: Rep[Option[Boolean]] = column[Option[Boolean]]("query_file", O.Default(Some(false)))
    /** Database column spreadsheet_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val spreadsheetFileName: Rep[Option[String]] = column[Option[String]]("spreadsheet_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column spreadsheet_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val spreadsheetContentType: Rep[Option[String]] = column[Option[String]]("spreadsheet_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column spreadsheet_file_size SqlType(INT), Default(None) */
    val spreadsheetFileSize: Rep[Option[Int]] = column[Option[Int]]("spreadsheet_file_size", O.Default(None))
    /** Database column spreadsheet_updated_at SqlType(DATETIME), Default(None) */
    val spreadsheetUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("spreadsheet_updated_at", O.Default(None))
    /** Database column execution_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val executionType: Rep[Option[String]] = column[Option[String]]("execution_type", O.Length(25,varying=true), O.Default(None))
    /** Database column phoenix_query_string SqlType(TEXT), Default(None) */
    val phoenixQueryString: Rep[Option[String]] = column[Option[String]]("phoenix_query_string", O.Default(None))
    /** Database column sql_query_string SqlType(TEXT), Default(None) */
    val sqlQueryString: Rep[Option[String]] = column[Option[String]]("sql_query_string", O.Default(None))
    /** Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ownerType: Rep[Option[String]] = column[Option[String]]("owner_type", O.Length(255,varying=true), O.Default(None))
    /** Database column owner_id SqlType(INT), Default(None) */
    val ownerId: Rep[Option[Int]] = column[Option[Int]]("owner_id", O.Default(None))
  }
  /** Collection-like TableQuery object for table BigdataQueries */
  lazy val BigdataQueries = new TableQuery(tag => new BigdataQueries(tag))

  /** Entity class storing rows of table BigdataQueryKpis
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param bigdataQueryId Database column bigdata_query_id SqlType(INT), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param rowKey Database column row_key SqlType(VARCHAR), Length(50,true)
   *  @param columnKey Database column column_key SqlType(VARCHAR), Length(50,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class BigdataQueryKpisRow(id: Int, bigdataQueryId: Option[Int] = None, name: String, label: String, rowKey: String, columnKey: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BigdataQueryKpisRow objects using plain SQL queries */
  implicit def GetResultBigdataQueryKpisRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[java.sql.Timestamp]]): GR[BigdataQueryKpisRow] = GR{
    prs => import prs._
    BigdataQueryKpisRow.tupled((<<[Int], <<?[Int], <<[String], <<[String], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table bigdata_query_kpis. Objects of this class serve as prototypes for rows in queries. */
  class BigdataQueryKpis(_tableTag: Tag) extends Table[BigdataQueryKpisRow](_tableTag, "bigdata_query_kpis") {
    def * = (id, bigdataQueryId, name, label, rowKey, columnKey, createdAt, updatedAt) <> (BigdataQueryKpisRow.tupled, BigdataQueryKpisRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), bigdataQueryId, Rep.Some(name), Rep.Some(label), Rep.Some(rowKey), Rep.Some(columnKey), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> BigdataQueryKpisRow.tupled((_1.get, _2, _3.get, _4.get, _5.get, _6.get, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column bigdata_query_id SqlType(INT), Default(None) */
    val bigdataQueryId: Rep[Option[Int]] = column[Option[Int]]("bigdata_query_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column row_key SqlType(VARCHAR), Length(50,true) */
    val rowKey: Rep[String] = column[String]("row_key", O.Length(50,varying=true))
    /** Database column column_key SqlType(VARCHAR), Length(50,true) */
    val columnKey: Rep[String] = column[String]("column_key", O.Length(50,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (bigdataQueryId) (database name index_bigdata_query_kpis_on_bigdata_query_id) */
    val index1 = index("index_bigdata_query_kpis_on_bigdata_query_id", bigdataQueryId)
  }
  /** Collection-like TableQuery object for table BigdataQueryKpis */
  lazy val BigdataQueryKpis = new TableQuery(tag => new BigdataQueryKpis(tag))

  /** Entity class storing rows of table BigdataQueryParameters
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param bigdataQueryId Database column bigdata_query_id SqlType(INT), Default(None)
   *  @param key Database column key SqlType(VARCHAR), Length(50,true)
   *  @param default Database column default SqlType(VARCHAR), Length(50,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class BigdataQueryParametersRow(id: Int, bigdataQueryId: Option[Int] = None, key: String, default: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BigdataQueryParametersRow objects using plain SQL queries */
  implicit def GetResultBigdataQueryParametersRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[java.sql.Timestamp]]): GR[BigdataQueryParametersRow] = GR{
    prs => import prs._
    BigdataQueryParametersRow.tupled((<<[Int], <<?[Int], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table bigdata_query_parameters. Objects of this class serve as prototypes for rows in queries. */
  class BigdataQueryParameters(_tableTag: Tag) extends Table[BigdataQueryParametersRow](_tableTag, "bigdata_query_parameters") {
    def * = (id, bigdataQueryId, key, default, createdAt, updatedAt) <> (BigdataQueryParametersRow.tupled, BigdataQueryParametersRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), bigdataQueryId, Rep.Some(key), Rep.Some(default), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> BigdataQueryParametersRow.tupled((_1.get, _2, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column bigdata_query_id SqlType(INT), Default(None) */
    val bigdataQueryId: Rep[Option[Int]] = column[Option[Int]]("bigdata_query_id", O.Default(None))
    /** Database column key SqlType(VARCHAR), Length(50,true) */
    val key: Rep[String] = column[String]("key", O.Length(50,varying=true))
    /** Database column default SqlType(VARCHAR), Length(50,true) */
    val default: Rep[String] = column[String]("default", O.Length(50,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (bigdataQueryId) (database name index_bigdata_query_parameters_on_bigdata_query_id) */
    val index1 = index("index_bigdata_query_parameters_on_bigdata_query_id", bigdataQueryId)
  }
  /** Collection-like TableQuery object for table BigdataQueryParameters */
  lazy val BigdataQueryParameters = new TableQuery(tag => new BigdataQueryParameters(tag))

  /** Entity class storing rows of table BookingClasses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param cabinClassId Database column cabin_class_id SqlType(INT), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param string Database column string SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(None)
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None)
   *  @param partner Database column partner SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class BookingClassesRow(id: Int, label: Option[String] = None, name: Option[String] = None, code: Option[String] = None, cabinClassId: Option[Int] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, status: String = "draft", string: String = "draft", publishedAt: Option[java.sql.Timestamp] = None, recurring: Option[Boolean] = None, recurringSchedule: Option[String] = None, partner: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching BookingClassesRow objects using plain SQL queries */
  implicit def GetResultBookingClassesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String], e5: GR[Option[Boolean]]): GR[BookingClassesRow] = GR{
    prs => import prs._
    BookingClassesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[Boolean], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table booking_classes. Objects of this class serve as prototypes for rows in queries. */
  class BookingClasses(_tableTag: Tag) extends Table[BookingClassesRow](_tableTag, "booking_classes") {
    def * = (id, label, name, code, cabinClassId, effectivityStart, effectivityEnd, effectivityTimezone, status, string, publishedAt, recurring, recurringSchedule, partner, createdAt, updatedAt) <> (BookingClassesRow.tupled, BookingClassesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), label, name, code, cabinClassId, effectivityStart, effectivityEnd, effectivityTimezone, Rep.Some(status), Rep.Some(string), publishedAt, recurring, recurringSchedule, partner, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> BookingClassesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9.get, _10.get, _11, _12, _13, _14, _15, _16)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(255,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(255,varying=true), O.Default(None))
    /** Database column cabin_class_id SqlType(INT), Default(None) */
    val cabinClassId: Rep[Option[Int]] = column[Option[Int]]("cabin_class_id", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(255,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column string SqlType(VARCHAR), Length(50,true), Default(draft) */
    val string: Rep[String] = column[String]("string", O.Length(50,varying=true), O.Default("draft"))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(None) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(None))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column partner SqlType(VARCHAR), Length(255,true), Default(None) */
    val partner: Rep[Option[String]] = column[Option[String]]("partner", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table BookingClasses */
  lazy val BookingClasses = new TableQuery(tag => new BookingClasses(tag))

  /** Entity class storing rows of table CabinClasses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CabinClassesRow(id: Int, label: Option[String] = None, name: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CabinClassesRow objects using plain SQL queries */
  implicit def GetResultCabinClassesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]]): GR[CabinClassesRow] = GR{
    prs => import prs._
    CabinClassesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table cabin_classes. Objects of this class serve as prototypes for rows in queries. */
  class CabinClasses(_tableTag: Tag) extends Table[CabinClassesRow](_tableTag, "cabin_classes") {
    def * = (id, label, name, createdAt, updatedAt) <> (CabinClassesRow.tupled, CabinClassesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), label, name, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CabinClassesRow.tupled((_1.get, _2, _3, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table CabinClasses */
  lazy val CabinClasses = new TableQuery(tag => new CabinClasses(tag))

  /** Entity class storing rows of table CalculationRules
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param ruleGroupId Database column rule_group_id SqlType(INT), Default(Some(0))
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param expression Database column expression SqlType(TEXT), Default(None)
   *  @param authoringMode Database column authoring_mode SqlType(INT), Default(Some(0))
   *  @param programId Database column program_id SqlType(INT)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param activityTypeName Database column activity_type_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None)
   *  @param activityTypeList Database column activity_type_list SqlType(TEXT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class CalculationRulesRow(id: Int, name: String, description: Option[String] = None, ruleGroupId: Option[Int] = Some(0), effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, expression: Option[String] = None, authoringMode: Option[Int] = Some(0), programId: Int, label: Option[String] = None, status: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, metricName: Option[String] = None, activityTypeName: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, activityTypeList: Option[String] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching CalculationRulesRow objects using plain SQL queries */
  implicit def GetResultCalculationRulesRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]]): GR[CalculationRulesRow] = GR{
    prs => import prs._
    CalculationRulesRow.tupled((<<[Int], <<[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Boolean], <<?[String], <<?[String], <<?[Int]))
  }
  /** Table description of table calculation_rules. Objects of this class serve as prototypes for rows in queries. */
  class CalculationRules(_tableTag: Tag) extends Table[CalculationRulesRow](_tableTag, "calculation_rules") {
    def * = (id, name, description, ruleGroupId, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, expression, authoringMode, programId, label, status, publishedAt, metricName, activityTypeName, recurring, recurringSchedule, activityTypeList, rowOrder) <> (CalculationRulesRow.tupled, CalculationRulesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), description, ruleGroupId, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, expression, authoringMode, Rep.Some(programId), label, status, publishedAt, metricName, activityTypeName, recurring, recurringSchedule, activityTypeList, rowOrder).shaped.<>({r=>import r._; _1.map(_=> CalculationRulesRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12.get, _13, _14, _15, _16, _17, _18, _19, _20, _21)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column rule_group_id SqlType(INT), Default(Some(0)) */
    val ruleGroupId: Rep[Option[Int]] = column[Option[Int]]("rule_group_id", O.Default(Some(0)))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column expression SqlType(TEXT), Default(None) */
    val expression: Rep[Option[String]] = column[Option[String]]("expression", O.Default(None))
    /** Database column authoring_mode SqlType(INT), Default(Some(0)) */
    val authoringMode: Rep[Option[Int]] = column[Option[Int]]("authoring_mode", O.Default(Some(0)))
    /** Database column program_id SqlType(INT) */
    val programId: Rep[Int] = column[Int]("program_id")
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(100,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(100,varying=true), O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column activity_type_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val activityTypeName: Rep[Option[String]] = column[Option[String]]("activity_type_name", O.Length(255,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column activity_type_list SqlType(TEXT), Default(None) */
    val activityTypeList: Rep[Option[String]] = column[Option[String]]("activity_type_list", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))

    /** Index over (ruleGroupId) (database name index_calculation_rules_on_rule_group_id) */
    val index1 = index("index_calculation_rules_on_rule_group_id", ruleGroupId)
  }
  /** Collection-like TableQuery object for table CalculationRules */
  lazy val CalculationRules = new TableQuery(tag => new CalculationRules(tag))

  /** Entity class storing rows of table CampaignLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param campaignId Database column campaign_id SqlType(INT)
   *  @param locationId Database column location_id SqlType(INT)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(255,true)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CampaignLocationsRow(id: Int, campaignId: Int, locationId: Int, locationType: String, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CampaignLocationsRow objects using plain SQL queries */
  implicit def GetResultCampaignLocationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Boolean], e3: GR[Option[java.sql.Timestamp]]): GR[CampaignLocationsRow] = GR{
    prs => import prs._
    CampaignLocationsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table campaign_locations. Objects of this class serve as prototypes for rows in queries. */
  class CampaignLocations(_tableTag: Tag) extends Table[CampaignLocationsRow](_tableTag, "campaign_locations") {
    def * = (id, campaignId, locationId, locationType, included, createdAt, updatedAt) <> (CampaignLocationsRow.tupled, CampaignLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(campaignId), Rep.Some(locationId), Rep.Some(locationType), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CampaignLocationsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column campaign_id SqlType(INT) */
    val campaignId: Rep[Int] = column[Int]("campaign_id")
    /** Database column location_id SqlType(INT) */
    val locationId: Rep[Int] = column[Int]("location_id")
    /** Database column location_type SqlType(VARCHAR), Length(255,true) */
    val locationType: Rep[String] = column[String]("location_type", O.Length(255,varying=true))
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (campaignId,locationId) (database name index_campaign_locations_on_campaign_id_and_location_id) */
    val index1 = index("index_campaign_locations_on_campaign_id_and_location_id", (campaignId, locationId), unique=true)
    /** Index over (locationId) (database name index_campaign_locations_on_location_id) */
    val index2 = index("index_campaign_locations_on_location_id", locationId)
  }
  /** Collection-like TableQuery object for table CampaignLocations */
  lazy val CampaignLocations = new TableQuery(tag => new CampaignLocations(tag))

  /** Entity class storing rows of table CampaignMemberConditions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param campaignRuleId Database column campaign_rule_id SqlType(INT), Default(None)
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param entityLabel Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param operator Database column operator SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param operatorType Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param conditionType Database column condition_type SqlType(VARCHAR), Length(100,true)
   *  @param matchValue Database column match_value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param active Database column active SqlType(BIT), Default(Some(true))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CampaignMemberConditionsRow(id: Int, campaignRuleId: Option[Int] = None, entityId: Option[Int] = None, entityType: Option[String] = None, entityLabel: Option[String] = None, operator: Option[String] = None, operatorType: Option[String] = None, conditionType: String, matchValue: Option[String] = None, active: Option[Boolean] = Some(true), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CampaignMemberConditionsRow objects using plain SQL queries */
  implicit def GetResultCampaignMemberConditionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[String], e4: GR[Option[Boolean]], e5: GR[Option[java.sql.Timestamp]]): GR[CampaignMemberConditionsRow] = GR{
    prs => import prs._
    CampaignMemberConditionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<[String], <<?[String], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table campaign_member_conditions. Objects of this class serve as prototypes for rows in queries. */
  class CampaignMemberConditions(_tableTag: Tag) extends Table[CampaignMemberConditionsRow](_tableTag, "campaign_member_conditions") {
    def * = (id, campaignRuleId, entityId, entityType, entityLabel, operator, operatorType, conditionType, matchValue, active, createdAt, updatedAt) <> (CampaignMemberConditionsRow.tupled, CampaignMemberConditionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), campaignRuleId, entityId, entityType, entityLabel, operator, operatorType, Rep.Some(conditionType), matchValue, active, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CampaignMemberConditionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8.get, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column campaign_rule_id SqlType(INT), Default(None) */
    val campaignRuleId: Rep[Option[Int]] = column[Option[Int]]("campaign_rule_id", O.Default(None))
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityLabel: Rep[Option[String]] = column[Option[String]]("entity_label", O.Length(255,varying=true), O.Default(None))
    /** Database column operator SqlType(VARCHAR), Length(100,true), Default(None) */
    val operator: Rep[Option[String]] = column[Option[String]]("operator", O.Length(100,varying=true), O.Default(None))
    /** Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None) */
    val operatorType: Rep[Option[String]] = column[Option[String]]("operator_type", O.Length(100,varying=true), O.Default(None))
    /** Database column condition_type SqlType(VARCHAR), Length(100,true) */
    val conditionType: Rep[String] = column[String]("condition_type", O.Length(100,varying=true))
    /** Database column match_value SqlType(VARCHAR), Length(255,true), Default(None) */
    val matchValue: Rep[Option[String]] = column[Option[String]]("match_value", O.Length(255,varying=true), O.Default(None))
    /** Database column active SqlType(BIT), Default(Some(true)) */
    val active: Rep[Option[Boolean]] = column[Option[Boolean]]("active", O.Default(Some(true)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (campaignRuleId) (database name index_campaign_member_conditions_on_campaign_rule_id) */
    val index1 = index("index_campaign_member_conditions_on_campaign_rule_id", campaignRuleId)
  }
  /** Collection-like TableQuery object for table CampaignMemberConditions */
  lazy val CampaignMemberConditions = new TableQuery(tag => new CampaignMemberConditions(tag))

  /** Entity class storing rows of table CampaignOfferConditions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param campaignRuleId Database column campaign_rule_id SqlType(INT), Default(None)
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param entityLabel Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param conditionType Database column condition_type SqlType(VARCHAR), Length(100,true)
   *  @param active Database column active SqlType(BIT), Default(Some(true))
   *  @param operator Database column operator SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param operatorType Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CampaignOfferConditionsRow(id: Int, campaignRuleId: Option[Int] = None, entityId: Option[Int] = None, entityType: Option[String] = None, entityLabel: Option[String] = None, conditionType: String, active: Option[Boolean] = Some(true), operator: Option[String] = None, operatorType: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CampaignOfferConditionsRow objects using plain SQL queries */
  implicit def GetResultCampaignOfferConditionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[String], e4: GR[Option[Boolean]], e5: GR[Option[java.sql.Timestamp]]): GR[CampaignOfferConditionsRow] = GR{
    prs => import prs._
    CampaignOfferConditionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<[String], <<?[Boolean], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table campaign_offer_conditions. Objects of this class serve as prototypes for rows in queries. */
  class CampaignOfferConditions(_tableTag: Tag) extends Table[CampaignOfferConditionsRow](_tableTag, "campaign_offer_conditions") {
    def * = (id, campaignRuleId, entityId, entityType, entityLabel, conditionType, active, operator, operatorType, createdAt, updatedAt) <> (CampaignOfferConditionsRow.tupled, CampaignOfferConditionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), campaignRuleId, entityId, entityType, entityLabel, Rep.Some(conditionType), active, operator, operatorType, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CampaignOfferConditionsRow.tupled((_1.get, _2, _3, _4, _5, _6.get, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column campaign_rule_id SqlType(INT), Default(None) */
    val campaignRuleId: Rep[Option[Int]] = column[Option[Int]]("campaign_rule_id", O.Default(None))
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityLabel: Rep[Option[String]] = column[Option[String]]("entity_label", O.Length(255,varying=true), O.Default(None))
    /** Database column condition_type SqlType(VARCHAR), Length(100,true) */
    val conditionType: Rep[String] = column[String]("condition_type", O.Length(100,varying=true))
    /** Database column active SqlType(BIT), Default(Some(true)) */
    val active: Rep[Option[Boolean]] = column[Option[Boolean]]("active", O.Default(Some(true)))
    /** Database column operator SqlType(VARCHAR), Length(100,true), Default(None) */
    val operator: Rep[Option[String]] = column[Option[String]]("operator", O.Length(100,varying=true), O.Default(None))
    /** Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None) */
    val operatorType: Rep[Option[String]] = column[Option[String]]("operator_type", O.Length(100,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (campaignRuleId) (database name index_campaign_offer_conditions_on_campaign_rule_id) */
    val index1 = index("index_campaign_offer_conditions_on_campaign_rule_id", campaignRuleId)
    /** Index over (entityId) (database name index_campaign_offer_conditions_on_entity_id) */
    val index2 = index("index_campaign_offer_conditions_on_entity_id", entityId)
  }
  /** Collection-like TableQuery object for table CampaignOfferConditions */
  lazy val CampaignOfferConditions = new TableQuery(tag => new CampaignOfferConditions(tag))

  /** Entity class storing rows of table CampaignRules
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param campaignId Database column campaign_id SqlType(INT), Default(None)
   *  @param score Database column score SqlType(INT), Default(None)
   *  @param memberMatchingRule Database column member_matching_rule SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param offerMatchingRule Database column offer_matching_rule SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CampaignRulesRow(id: Int, campaignId: Option[Int] = None, score: Option[Int] = None, memberMatchingRule: Option[String] = None, offerMatchingRule: Option[String] = None, rowOrder: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CampaignRulesRow objects using plain SQL queries */
  implicit def GetResultCampaignRulesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[CampaignRulesRow] = GR{
    prs => import prs._
    CampaignRulesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table campaign_rules. Objects of this class serve as prototypes for rows in queries. */
  class CampaignRules(_tableTag: Tag) extends Table[CampaignRulesRow](_tableTag, "campaign_rules") {
    def * = (id, campaignId, score, memberMatchingRule, offerMatchingRule, rowOrder, createdAt, updatedAt) <> (CampaignRulesRow.tupled, CampaignRulesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), campaignId, score, memberMatchingRule, offerMatchingRule, rowOrder, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CampaignRulesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column campaign_id SqlType(INT), Default(None) */
    val campaignId: Rep[Option[Int]] = column[Option[Int]]("campaign_id", O.Default(None))
    /** Database column score SqlType(INT), Default(None) */
    val score: Rep[Option[Int]] = column[Option[Int]]("score", O.Default(None))
    /** Database column member_matching_rule SqlType(VARCHAR), Length(100,true), Default(None) */
    val memberMatchingRule: Rep[Option[String]] = column[Option[String]]("member_matching_rule", O.Length(100,varying=true), O.Default(None))
    /** Database column offer_matching_rule SqlType(VARCHAR), Length(100,true), Default(None) */
    val offerMatchingRule: Rep[Option[String]] = column[Option[String]]("offer_matching_rule", O.Length(100,varying=true), O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (campaignId) (database name index_campaign_rules_on_campaign_id) */
    val index1 = index("index_campaign_rules_on_campaign_id", campaignId)
  }
  /** Collection-like TableQuery object for table CampaignRules */
  lazy val CampaignRules = new TableQuery(tag => new CampaignRules(tag))

  /** Row type of table Campaigns */
  type CampaignsRow = HCons[Int,HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[String,HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[String,HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for CampaignsRow providing default values if available in the database schema. */
  def CampaignsRow(id: Int, programId: Option[Int] = None, `type`: Option[String] = None, description: Option[String] = None, name: String, label: String, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, winnerSelectionCount: Option[Int] = None, winnerSelectionMetric: Option[String] = None, ranking: Option[String] = Some("manual"), multipleMatchRule: Option[String] = None, tieBreakerRule: Option[String] = None, setType: Option[String] = Some("static"), audienceIncludeVisitors: Option[Boolean] = Some(true), audienceIncludeSuspendedEmails: Option[Boolean] = Some(true), objectiveDescription: Option[String] = None, targetNumber: Option[Int] = Some(0), valuePerMember: Option[scala.math.BigDecimal] = None, costPerMember: Option[scala.math.BigDecimal] = None, fixedCost: Option[scala.math.BigDecimal] = None, controlGroupSize: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00"))): CampaignsRow = {
    id :: programId :: `type` :: description :: name :: label :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: publishedAt :: status :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: createdAt :: updatedAt :: winnerSelectionCount :: winnerSelectionMetric :: ranking :: multipleMatchRule :: tieBreakerRule :: setType :: audienceIncludeVisitors :: audienceIncludeSuspendedEmails :: objectiveDescription :: targetNumber :: valuePerMember :: costPerMember :: fixedCost :: controlGroupSize :: HNil
  }
  /** GetResult implicit for fetching CampaignsRow objects using plain SQL queries */
  implicit def GetResultCampaignsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[String], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]], e6: GR[Option[scala.math.BigDecimal]]): GR[CampaignsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: HNil
  }
  /** Table description of table campaigns. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Campaigns(_tableTag: Tag) extends Table[CampaignsRow](_tableTag, "campaigns") {
    def * = id :: programId :: `type` :: description :: name :: label :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: publishedAt :: status :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: createdAt :: updatedAt :: winnerSelectionCount :: winnerSelectionMetric :: ranking :: multipleMatchRule :: tieBreakerRule :: setType :: audienceIncludeVisitors :: audienceIncludeSuspendedEmails :: objectiveDescription :: targetNumber :: valuePerMember :: costPerMember :: fixedCost :: controlGroupSize :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(150,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(150,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column winner_selection_count SqlType(INT), Default(None) */
    val winnerSelectionCount: Rep[Option[Int]] = column[Option[Int]]("winner_selection_count", O.Default(None))
    /** Database column winner_selection_metric SqlType(VARCHAR), Length(50,true), Default(None) */
    val winnerSelectionMetric: Rep[Option[String]] = column[Option[String]]("winner_selection_metric", O.Length(50,varying=true), O.Default(None))
    /** Database column ranking SqlType(VARCHAR), Length(100,true), Default(Some(manual)) */
    val ranking: Rep[Option[String]] = column[Option[String]]("ranking", O.Length(100,varying=true), O.Default(Some("manual")))
    /** Database column multiple_match_rule SqlType(VARCHAR), Length(100,true), Default(None) */
    val multipleMatchRule: Rep[Option[String]] = column[Option[String]]("multiple_match_rule", O.Length(100,varying=true), O.Default(None))
    /** Database column tie_breaker_rule SqlType(VARCHAR), Length(100,true), Default(None) */
    val tieBreakerRule: Rep[Option[String]] = column[Option[String]]("tie_breaker_rule", O.Length(100,varying=true), O.Default(None))
    /** Database column set_type SqlType(VARCHAR), Length(100,true), Default(Some(static)) */
    val setType: Rep[Option[String]] = column[Option[String]]("set_type", O.Length(100,varying=true), O.Default(Some("static")))
    /** Database column audience_include_visitors SqlType(BIT), Default(Some(true)) */
    val audienceIncludeVisitors: Rep[Option[Boolean]] = column[Option[Boolean]]("audience_include_visitors", O.Default(Some(true)))
    /** Database column audience_include_suspended_emails SqlType(BIT), Default(Some(true)) */
    val audienceIncludeSuspendedEmails: Rep[Option[Boolean]] = column[Option[Boolean]]("audience_include_suspended_emails", O.Default(Some(true)))
    /** Database column objective_description SqlType(TEXT), Default(None) */
    val objectiveDescription: Rep[Option[String]] = column[Option[String]]("objective_description", O.Default(None))
    /** Database column target_number SqlType(INT), Default(Some(0)) */
    val targetNumber: Rep[Option[Int]] = column[Option[Int]]("target_number", O.Default(Some(0)))
    /** Database column value_per_member SqlType(DECIMAL), Default(None) */
    val valuePerMember: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("value_per_member", O.Default(None))
    /** Database column cost_per_member SqlType(DECIMAL), Default(None) */
    val costPerMember: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("cost_per_member", O.Default(None))
    /** Database column fixed_cost SqlType(DECIMAL), Default(None) */
    val fixedCost: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("fixed_cost", O.Default(None))
    /** Database column control_group_size SqlType(DECIMAL), Default(Some(0.00)) */
    val controlGroupSize: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("control_group_size", O.Default(Some(BigDecimal("0.00"))))
  }
  /** Collection-like TableQuery object for table Campaigns */
  lazy val Campaigns = new TableQuery(tag => new Campaigns(tag))

  /** Entity class storing rows of table CampaignSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param segmentId Database column segment_id SqlType(INT), Default(None)
   *  @param campaignId Database column campaign_id SqlType(INT), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(true))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CampaignSegmentsRow(id: Int, segmentId: Option[Int] = None, campaignId: Option[Int] = None, included: Option[Boolean] = Some(true), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CampaignSegmentsRow objects using plain SQL queries */
  implicit def GetResultCampaignSegmentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[Boolean]], e3: GR[Option[java.sql.Timestamp]]): GR[CampaignSegmentsRow] = GR{
    prs => import prs._
    CampaignSegmentsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table campaign_segments. Objects of this class serve as prototypes for rows in queries. */
  class CampaignSegments(_tableTag: Tag) extends Table[CampaignSegmentsRow](_tableTag, "campaign_segments") {
    def * = (id, segmentId, campaignId, included, createdAt, updatedAt) <> (CampaignSegmentsRow.tupled, CampaignSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), segmentId, campaignId, included, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CampaignSegmentsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column segment_id SqlType(INT), Default(None) */
    val segmentId: Rep[Option[Int]] = column[Option[Int]]("segment_id", O.Default(None))
    /** Database column campaign_id SqlType(INT), Default(None) */
    val campaignId: Rep[Option[Int]] = column[Option[Int]]("campaign_id", O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(true)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(true)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (campaignId,segmentId) (database name index_campaign_segments_on_campaign_id_and_segment_id) */
    val index1 = index("index_campaign_segments_on_campaign_id_and_segment_id", (campaignId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_campaign_segments_on_segment_id) */
    val index2 = index("index_campaign_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table CampaignSegments */
  lazy val CampaignSegments = new TableQuery(tag => new CampaignSegments(tag))

  /** Entity class storing rows of table Categories
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param parentId Database column parent_id SqlType(INT), Default(None)
   *  @param lft Database column lft SqlType(INT), Default(None)
   *  @param rgt Database column rgt SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CategoriesRow(id: Int, name: Option[String] = None, parentId: Option[Int] = None, lft: Option[Int] = None, rgt: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CategoriesRow objects using plain SQL queries */
  implicit def GetResultCategoriesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]]): GR[CategoriesRow] = GR{
    prs => import prs._
    CategoriesRow.tupled((<<[Int], <<?[String], <<?[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table categories. Objects of this class serve as prototypes for rows in queries. */
  class Categories(_tableTag: Tag) extends Table[CategoriesRow](_tableTag, "categories") {
    def * = (id, name, parentId, lft, rgt, createdAt, updatedAt) <> (CategoriesRow.tupled, CategoriesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, parentId, lft, rgt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CategoriesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column parent_id SqlType(INT), Default(None) */
    val parentId: Rep[Option[Int]] = column[Option[Int]]("parent_id", O.Default(None))
    /** Database column lft SqlType(INT), Default(None) */
    val lft: Rep[Option[Int]] = column[Option[Int]]("lft", O.Default(None))
    /** Database column rgt SqlType(INT), Default(None) */
    val rgt: Rep[Option[Int]] = column[Option[Int]]("rgt", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (lft) (database name index_categories_on_lft) */
    val index1 = index("index_categories_on_lft", lft)
    /** Index over (name) (database name index_categories_on_name) */
    val index2 = index("index_categories_on_name", name)
    /** Index over (parentId) (database name index_categories_on_parent_id) */
    val index3 = index("index_categories_on_parent_id", parentId)
    /** Index over (rgt) (database name index_categories_on_rgt) */
    val index4 = index("index_categories_on_rgt", rgt)
  }
  /** Collection-like TableQuery object for table Categories */
  lazy val Categories = new TableQuery(tag => new Categories(tag))

  /** Entity class storing rows of table Certificates
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param rewardId Database column reward_id SqlType(INT)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param rewardResponseId Database column reward_response_id SqlType(INT), Default(None)
   *  @param awardId Database column award_id SqlType(INT), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param secondaryCodes Database column secondary_codes SqlType(TEXT), Default(None)
   *  @param couponUrl Database column coupon_url SqlType(TEXT), Default(None) */
  case class CertificatesRow(id: Int, rewardId: Int, memberId: Option[Int] = None, rewardResponseId: Option[Int] = None, awardId: Option[Int] = None, code: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, status: Option[String] = None, secondaryCodes: Option[String] = None, couponUrl: Option[String] = None)
  /** GetResult implicit for fetching CertificatesRow objects using plain SQL queries */
  implicit def GetResultCertificatesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[CertificatesRow] = GR{
    prs => import prs._
    CertificatesRow.tupled((<<[Int], <<[Int], <<?[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String]))
  }
  /** Table description of table certificates. Objects of this class serve as prototypes for rows in queries. */
  class Certificates(_tableTag: Tag) extends Table[CertificatesRow](_tableTag, "certificates") {
    def * = (id, rewardId, memberId, rewardResponseId, awardId, code, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, status, secondaryCodes, couponUrl) <> (CertificatesRow.tupled, CertificatesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(rewardId), memberId, rewardResponseId, awardId, code, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, status, secondaryCodes, couponUrl).shaped.<>({r=>import r._; _1.map(_=> CertificatesRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column reward_id SqlType(INT) */
    val rewardId: Rep[Int] = column[Int]("reward_id")
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column reward_response_id SqlType(INT), Default(None) */
    val rewardResponseId: Rep[Option[Int]] = column[Option[Int]]("reward_response_id", O.Default(None))
    /** Database column award_id SqlType(INT), Default(None) */
    val awardId: Rep[Option[Int]] = column[Option[Int]]("award_id", O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(255,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(255,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column secondary_codes SqlType(TEXT), Default(None) */
    val secondaryCodes: Rep[Option[String]] = column[Option[String]]("secondary_codes", O.Default(None))
    /** Database column coupon_url SqlType(TEXT), Default(None) */
    val couponUrl: Rep[Option[String]] = column[Option[String]]("coupon_url", O.Default(None))

    /** Index over (awardId,rewardId) (database name index_certificates_on_award_id_and_reward_id) */
    val index1 = index("index_certificates_on_award_id_and_reward_id", (awardId, rewardId))
    /** Index over (code,rewardId) (database name index_certificates_on_code_and_reward_id) */
    val index2 = index("index_certificates_on_code_and_reward_id", (code, rewardId))
    /** Index over (memberId) (database name index_certificates_on_member_id) */
    val index3 = index("index_certificates_on_member_id", memberId)
    /** Index over (rewardId) (database name index_certificates_on_reward_id) */
    val index4 = index("index_certificates_on_reward_id", rewardId)
    /** Index over (rewardId,status) (database name index_certificates_on_reward_id_and_status) */
    val index5 = index("index_certificates_on_reward_id_and_status", (rewardId, status))
    /** Index over (rewardResponseId,rewardId) (database name index_certificates_on_reward_response_id_and_reward_id) */
    val index6 = index("index_certificates_on_reward_response_id_and_reward_id", (rewardResponseId, rewardId))
  }
  /** Collection-like TableQuery object for table Certificates */
  lazy val Certificates = new TableQuery(tag => new Certificates(tag))

  /** Entity class storing rows of table ChallengeActions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param challengeId Database column challenge_id SqlType(INT), Default(None)
   *  @param viewedAt Database column viewed_at SqlType(DATETIME), Default(None)
   *  @param respondedAt Database column responded_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ChallengeActionsRow(id: Int, memberId: Option[Int] = None, challengeId: Option[Int] = None, viewedAt: Option[java.sql.Timestamp] = None, respondedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ChallengeActionsRow objects using plain SQL queries */
  implicit def GetResultChallengeActionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[ChallengeActionsRow] = GR{
    prs => import prs._
    ChallengeActionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table challenge_actions. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeActions(_tableTag: Tag) extends Table[ChallengeActionsRow](_tableTag, "challenge_actions") {
    def * = (id, memberId, challengeId, viewedAt, respondedAt, createdAt, updatedAt) <> (ChallengeActionsRow.tupled, ChallengeActionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, challengeId, viewedAt, respondedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ChallengeActionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column viewed_at SqlType(DATETIME), Default(None) */
    val viewedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("viewed_at", O.Default(None))
    /** Database column responded_at SqlType(DATETIME), Default(None) */
    val respondedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("responded_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (challengeId) (database name index_challenge_actions_on_challenge_id) */
    val index1 = index("index_challenge_actions_on_challenge_id", challengeId)
    /** Uniqueness Index over (memberId,challengeId) (database name index_challenge_actions_on_member_id_and_challenge_id) */
    val index2 = index("index_challenge_actions_on_member_id_and_challenge_id", (memberId, challengeId), unique=true)
  }
  /** Collection-like TableQuery object for table ChallengeActions */
  lazy val ChallengeActions = new TableQuery(tag => new ChallengeActions(tag))

  /** Entity class storing rows of table ChallengeAssets
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param challengeId Database column challenge_id SqlType(INT), Default(None)
   *  @param assetFileName Database column asset_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param assetContentType Database column asset_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param assetFileSize Database column asset_file_size SqlType(INT), Default(None)
   *  @param assetUpdatedAt Database column asset_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ChallengeAssetsRow(id: Int, challengeId: Option[Int] = None, assetFileName: Option[String] = None, assetContentType: Option[String] = None, assetFileSize: Option[Int] = None, assetUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ChallengeAssetsRow objects using plain SQL queries */
  implicit def GetResultChallengeAssetsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ChallengeAssetsRow] = GR{
    prs => import prs._
    ChallengeAssetsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table challenge_assets. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeAssets(_tableTag: Tag) extends Table[ChallengeAssetsRow](_tableTag, "challenge_assets") {
    def * = (id, challengeId, assetFileName, assetContentType, assetFileSize, assetUpdatedAt, createdAt, updatedAt) <> (ChallengeAssetsRow.tupled, ChallengeAssetsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), challengeId, assetFileName, assetContentType, assetFileSize, assetUpdatedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ChallengeAssetsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column asset_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val assetFileName: Rep[Option[String]] = column[Option[String]]("asset_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column asset_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val assetContentType: Rep[Option[String]] = column[Option[String]]("asset_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column asset_file_size SqlType(INT), Default(None) */
    val assetFileSize: Rep[Option[Int]] = column[Option[Int]]("asset_file_size", O.Default(None))
    /** Database column asset_updated_at SqlType(DATETIME), Default(None) */
    val assetUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("asset_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (challengeId) (database name index_challenge_assets_on_challenge_id) */
    val index1 = index("index_challenge_assets_on_challenge_id", challengeId)
  }
  /** Collection-like TableQuery object for table ChallengeAssets */
  lazy val ChallengeAssets = new TableQuery(tag => new ChallengeAssets(tag))

  /** Entity class storing rows of table ChallengeDefinitionOptions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param challengeDefinitionId Database column challenge_definition_id SqlType(INT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param attachmentFileName Database column attachment_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param attachmentContentType Database column attachment_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param attachmentFileSize Database column attachment_file_size SqlType(INT), Default(None)
   *  @param attachmentUpdatedAt Database column attachment_updated_at SqlType(DATETIME), Default(None) */
  case class ChallengeDefinitionOptionsRow(id: Int, challengeDefinitionId: Option[Int] = None, rowOrder: Option[Int] = None, label: Option[String] = None, attachmentFileName: Option[String] = None, attachmentContentType: Option[String] = None, attachmentFileSize: Option[Int] = None, attachmentUpdatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ChallengeDefinitionOptionsRow objects using plain SQL queries */
  implicit def GetResultChallengeDefinitionOptionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ChallengeDefinitionOptionsRow] = GR{
    prs => import prs._
    ChallengeDefinitionOptionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp]))
  }
  /** Table description of table challenge_definition_options. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeDefinitionOptions(_tableTag: Tag) extends Table[ChallengeDefinitionOptionsRow](_tableTag, "challenge_definition_options") {
    def * = (id, challengeDefinitionId, rowOrder, label, attachmentFileName, attachmentContentType, attachmentFileSize, attachmentUpdatedAt) <> (ChallengeDefinitionOptionsRow.tupled, ChallengeDefinitionOptionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), challengeDefinitionId, rowOrder, label, attachmentFileName, attachmentContentType, attachmentFileSize, attachmentUpdatedAt).shaped.<>({r=>import r._; _1.map(_=> ChallengeDefinitionOptionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_definition_id SqlType(INT), Default(None) */
    val challengeDefinitionId: Rep[Option[Int]] = column[Option[Int]]("challenge_definition_id", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(100,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(100,varying=true), O.Default(None))
    /** Database column attachment_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentFileName: Rep[Option[String]] = column[Option[String]]("attachment_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentContentType: Rep[Option[String]] = column[Option[String]]("attachment_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_file_size SqlType(INT), Default(None) */
    val attachmentFileSize: Rep[Option[Int]] = column[Option[Int]]("attachment_file_size", O.Default(None))
    /** Database column attachment_updated_at SqlType(DATETIME), Default(None) */
    val attachmentUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("attachment_updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ChallengeDefinitionOptions */
  lazy val ChallengeDefinitionOptions = new TableQuery(tag => new ChallengeDefinitionOptions(tag))

  /** Entity class storing rows of table ChallengeDefinitions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param challengeId Database column challenge_id SqlType(INT), Default(None)
   *  @param definitions Database column definitions SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param assetFileName Database column asset_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param assetContentType Database column asset_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param assetFileSize Database column asset_file_size SqlType(INT), Default(None)
   *  @param assetUpdatedAt Database column asset_updated_at SqlType(DATETIME), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class ChallengeDefinitionsRow(id: Int, challengeId: Option[Int] = None, definitions: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, assetFileName: Option[String] = None, assetContentType: Option[String] = None, assetFileSize: Option[Int] = None, assetUpdatedAt: Option[java.sql.Timestamp] = None, name: Option[String] = None, `type`: String, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching ChallengeDefinitionsRow objects using plain SQL queries */
  implicit def GetResultChallengeDefinitionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String]): GR[ChallengeDefinitionsRow] = GR{
    prs => import prs._
    ChallengeDefinitionsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<[String], <<?[Int]))
  }
  /** Table description of table challenge_definitions. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class ChallengeDefinitions(_tableTag: Tag) extends Table[ChallengeDefinitionsRow](_tableTag, "challenge_definitions") {
    def * = (id, challengeId, definitions, createdAt, updatedAt, assetFileName, assetContentType, assetFileSize, assetUpdatedAt, name, `type`, rowOrder) <> (ChallengeDefinitionsRow.tupled, ChallengeDefinitionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), challengeId, definitions, createdAt, updatedAt, assetFileName, assetContentType, assetFileSize, assetUpdatedAt, name, Rep.Some(`type`), rowOrder).shaped.<>({r=>import r._; _1.map(_=> ChallengeDefinitionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11.get, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column definitions SqlType(TEXT), Default(None) */
    val definitions: Rep[Option[String]] = column[Option[String]]("definitions", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column asset_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val assetFileName: Rep[Option[String]] = column[Option[String]]("asset_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column asset_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val assetContentType: Rep[Option[String]] = column[Option[String]]("asset_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column asset_file_size SqlType(INT), Default(None) */
    val assetFileSize: Rep[Option[Int]] = column[Option[Int]]("asset_file_size", O.Default(None))
    /** Database column asset_updated_at SqlType(DATETIME), Default(None) */
    val assetUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("asset_updated_at", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[String] = column[String]("type", O.Length(255,varying=true))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))

    /** Index over (challengeId) (database name index_challenge_definitions_on_challenge_id) */
    val index1 = index("index_challenge_definitions_on_challenge_id", challengeId)
    /** Uniqueness Index over (name,challengeId) (database name index_challenge_definitions_on_name_and_challenge_id) */
    val index2 = index("index_challenge_definitions_on_name_and_challenge_id", (name, challengeId), unique=true)
  }
  /** Collection-like TableQuery object for table ChallengeDefinitions */
  lazy val ChallengeDefinitions = new TableQuery(tag => new ChallengeDefinitions(tag))

  /** Entity class storing rows of table ChallengeLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param locationId Database column location_id SqlType(INT), Default(None)
   *  @param challengeId Database column challenge_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(false)) */
  case class ChallengeLocationsRow(id: Int, locationId: Option[Int] = None, challengeId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, locationType: Option[String] = None, included: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching ChallengeLocationsRow objects using plain SQL queries */
  implicit def GetResultChallengeLocationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]], e4: GR[Option[Boolean]]): GR[ChallengeLocationsRow] = GR{
    prs => import prs._
    ChallengeLocationsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Boolean]))
  }
  /** Table description of table challenge_locations. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeLocations(_tableTag: Tag) extends Table[ChallengeLocationsRow](_tableTag, "challenge_locations") {
    def * = (id, locationId, challengeId, createdAt, updatedAt, locationType, included) <> (ChallengeLocationsRow.tupled, ChallengeLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), locationId, challengeId, createdAt, updatedAt, locationType, included).shaped.<>({r=>import r._; _1.map(_=> ChallengeLocationsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column location_id SqlType(INT), Default(None) */
    val locationId: Rep[Option[Int]] = column[Option[Int]]("location_id", O.Default(None))
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column location_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val locationType: Rep[Option[String]] = column[Option[String]]("location_type", O.Length(25,varying=true), O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(false)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(false)))

    /** Uniqueness Index over (challengeId,locationId) (database name index_challenge_locations_on_challenge_id_and_location_id) */
    val index1 = index("index_challenge_locations_on_challenge_id_and_location_id", (challengeId, locationId), unique=true)
    /** Index over (locationId) (database name index_challenge_locations_on_location_id) */
    val index2 = index("index_challenge_locations_on_location_id", locationId)
  }
  /** Collection-like TableQuery object for table ChallengeLocations */
  lazy val ChallengeLocations = new TableQuery(tag => new ChallengeLocations(tag))

  /** Entity class storing rows of table ChallengePrizes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param challengeId Database column challenge_id SqlType(INT), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeId Database column prize_id SqlType(INT), Default(None)
   *  @param prizeMetricAmount Database column prize_metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeMetricName Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param prizeFrequency Database column prize_frequency SqlType(INT), Default(None)
   *  @param prizeProbability Database column prize_probability SqlType(INT), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ChallengePrizesRow(id: Int, challengeId: Option[Int] = None, name: String, label: String, description: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, prizeType: Option[String] = None, prizeId: Option[Int] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeMetricName: Option[String] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[Int] = None, properties: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ChallengePrizesRow objects using plain SQL queries */
  implicit def GetResultChallengePrizesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[scala.math.BigDecimal]]): GR[ChallengePrizesRow] = GR{
    prs => import prs._
    ChallengePrizesRow.tupled((<<[Int], <<?[Int], <<[String], <<[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[scala.math.BigDecimal], <<?[String], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table challenge_prizes. Objects of this class serve as prototypes for rows in queries. */
  class ChallengePrizes(_tableTag: Tag) extends Table[ChallengePrizesRow](_tableTag, "challenge_prizes") {
    def * = (id, challengeId, name, label, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, prizeType, prizeId, prizeMetricAmount, prizeMetricName, prizeFrequency, prizeProbability, properties, createdAt, updatedAt) <> (ChallengePrizesRow.tupled, ChallengePrizesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), challengeId, Rep.Some(name), Rep.Some(label), description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, prizeType, prizeId, prizeMetricAmount, prizeMetricName, prizeFrequency, prizeProbability, properties, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ChallengePrizesRow.tupled((_1.get, _2, _3.get, _4.get, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(INT), Default(None) */
    val prizeProbability: Rep[Option[Int]] = column[Option[Int]]("prize_probability", O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (challengeId) (database name index_challenge_prizes_on_challenge_id) */
    val index1 = index("index_challenge_prizes_on_challenge_id", challengeId)
  }
  /** Collection-like TableQuery object for table ChallengePrizes */
  lazy val ChallengePrizes = new TableQuery(tag => new ChallengePrizes(tag))

  /** Entity class storing rows of table ChallengeResponseItems
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param challengeResponseId Database column challenge_response_id SqlType(INT), Default(None)
   *  @param challengeDefinitionId Database column challenge_definition_id SqlType(INT), Default(None)
   *  @param response Database column response SqlType(TEXT), Default(None)
   *  @param attachmentFileName Database column attachment_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param attachmentContentType Database column attachment_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param attachmentFileSize Database column attachment_file_size SqlType(INT), Default(None)
   *  @param attachmentUpdatedAt Database column attachment_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param challengeDefinitionOptionId Database column challenge_definition_option_id SqlType(INT), Default(None) */
  case class ChallengeResponseItemsRow(id: Int, challengeResponseId: Option[Int] = None, challengeDefinitionId: Option[Int] = None, response: Option[String] = None, attachmentFileName: Option[String] = None, attachmentContentType: Option[String] = None, attachmentFileSize: Option[Int] = None, attachmentUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, challengeDefinitionOptionId: Option[Int] = None)
  /** GetResult implicit for fetching ChallengeResponseItemsRow objects using plain SQL queries */
  implicit def GetResultChallengeResponseItemsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ChallengeResponseItemsRow] = GR{
    prs => import prs._
    ChallengeResponseItemsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table challenge_response_items. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeResponseItems(_tableTag: Tag) extends Table[ChallengeResponseItemsRow](_tableTag, "challenge_response_items") {
    def * = (id, challengeResponseId, challengeDefinitionId, response, attachmentFileName, attachmentContentType, attachmentFileSize, attachmentUpdatedAt, createdAt, updatedAt, challengeDefinitionOptionId) <> (ChallengeResponseItemsRow.tupled, ChallengeResponseItemsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), challengeResponseId, challengeDefinitionId, response, attachmentFileName, attachmentContentType, attachmentFileSize, attachmentUpdatedAt, createdAt, updatedAt, challengeDefinitionOptionId).shaped.<>({r=>import r._; _1.map(_=> ChallengeResponseItemsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_response_id SqlType(INT), Default(None) */
    val challengeResponseId: Rep[Option[Int]] = column[Option[Int]]("challenge_response_id", O.Default(None))
    /** Database column challenge_definition_id SqlType(INT), Default(None) */
    val challengeDefinitionId: Rep[Option[Int]] = column[Option[Int]]("challenge_definition_id", O.Default(None))
    /** Database column response SqlType(TEXT), Default(None) */
    val response: Rep[Option[String]] = column[Option[String]]("response", O.Default(None))
    /** Database column attachment_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentFileName: Rep[Option[String]] = column[Option[String]]("attachment_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentContentType: Rep[Option[String]] = column[Option[String]]("attachment_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_file_size SqlType(INT), Default(None) */
    val attachmentFileSize: Rep[Option[Int]] = column[Option[Int]]("attachment_file_size", O.Default(None))
    /** Database column attachment_updated_at SqlType(DATETIME), Default(None) */
    val attachmentUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("attachment_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column challenge_definition_option_id SqlType(INT), Default(None) */
    val challengeDefinitionOptionId: Rep[Option[Int]] = column[Option[Int]]("challenge_definition_option_id", O.Default(None))

    /** Index over (challengeDefinitionOptionId) (database name index_challenge_response_items_on_challenge_definition_option_id) */
    val index1 = index("index_challenge_response_items_on_challenge_definition_option_id", challengeDefinitionOptionId)
  }
  /** Collection-like TableQuery object for table ChallengeResponseItems */
  lazy val ChallengeResponseItems = new TableQuery(tag => new ChallengeResponseItems(tag))

  /** Entity class storing rows of table ChallengeResponsePrizes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param challengeResponseId Database column challenge_response_id SqlType(INT), Default(None)
   *  @param challengePrizeId Database column challenge_prize_id SqlType(INT), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeMetricName Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param prizeMetricAmount Database column prize_metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeId Database column prize_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ChallengeResponsePrizesRow(id: Int, challengeResponseId: Option[Int] = None, challengePrizeId: Option[Int] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ChallengeResponsePrizesRow objects using plain SQL queries */
  implicit def GetResultChallengeResponsePrizesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]]): GR[ChallengeResponsePrizesRow] = GR{
    prs => import prs._
    ChallengeResponsePrizesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table challenge_response_prizes. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeResponsePrizes(_tableTag: Tag) extends Table[ChallengeResponsePrizesRow](_tableTag, "challenge_response_prizes") {
    def * = (id, challengeResponseId, challengePrizeId, prizeType, prizeMetricName, prizeMetricAmount, prizeId, createdAt, updatedAt) <> (ChallengeResponsePrizesRow.tupled, ChallengeResponsePrizesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), challengeResponseId, challengePrizeId, prizeType, prizeMetricName, prizeMetricAmount, prizeId, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ChallengeResponsePrizesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_response_id SqlType(INT), Default(None) */
    val challengeResponseId: Rep[Option[Int]] = column[Option[Int]]("challenge_response_id", O.Default(None))
    /** Database column challenge_prize_id SqlType(INT), Default(None) */
    val challengePrizeId: Rep[Option[Int]] = column[Option[Int]]("challenge_prize_id", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (challengePrizeId) (database name index_challenge_response_prizes_on_challenge_prize_id) */
    val index1 = index("index_challenge_response_prizes_on_challenge_prize_id", challengePrizeId)
  }
  /** Collection-like TableQuery object for table ChallengeResponsePrizes */
  lazy val ChallengeResponsePrizes = new TableQuery(tag => new ChallengeResponsePrizes(tag))

  /** Row type of table ChallengeResponses */
  type ChallengeResponsesRow = HCons[Int,HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[scala.math.BigDecimal,HCons[Option[String],HCons[Option[Int],HCons[Option[Int],HNil]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for ChallengeResponsesRow providing default values if available in the database schema. */
  def ChallengeResponsesRow(id: Int, challengeId: Option[Int] = None, memberId: Option[Int] = None, response: Option[String] = None, status: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, attachmentFileName: Option[String] = None, attachmentContentType: Option[String] = None, attachmentFileSize: Option[Int] = None, attachmentUpdatedAt: Option[java.sql.Timestamp] = None, showInGallery: Option[String] = Some("no"), guid: Option[String] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeId: Option[Int] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), activityContext: Option[String] = None, messageId: Option[Int] = None, messageActionId: Option[Int] = None): ChallengeResponsesRow = {
    id :: challengeId :: memberId :: response :: status :: createdAt :: updatedAt :: attachmentFileName :: attachmentContentType :: attachmentFileSize :: attachmentUpdatedAt :: showInGallery :: guid :: prizeType :: prizeMetricName :: prizeMetricAmount :: prizeId :: metricName :: metricAmount :: businessValue :: activityContext :: messageId :: messageActionId :: HNil
  }
  /** GetResult implicit for fetching ChallengeResponsesRow objects using plain SQL queries */
  implicit def GetResultChallengeResponsesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[scala.math.BigDecimal]], e5: GR[scala.math.BigDecimal]): GR[ChallengeResponsesRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[Int] :: HNil
  }
  /** Table description of table challenge_responses. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeResponses(_tableTag: Tag) extends Table[ChallengeResponsesRow](_tableTag, "challenge_responses") {
    def * = id :: challengeId :: memberId :: response :: status :: createdAt :: updatedAt :: attachmentFileName :: attachmentContentType :: attachmentFileSize :: attachmentUpdatedAt :: showInGallery :: guid :: prizeType :: prizeMetricName :: prizeMetricAmount :: prizeId :: metricName :: metricAmount :: businessValue :: activityContext :: messageId :: messageActionId :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column response SqlType(TEXT), Default(None) */
    val response: Rep[Option[String]] = column[Option[String]]("response", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column attachment_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentFileName: Rep[Option[String]] = column[Option[String]]("attachment_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentContentType: Rep[Option[String]] = column[Option[String]]("attachment_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_file_size SqlType(INT), Default(None) */
    val attachmentFileSize: Rep[Option[Int]] = column[Option[Int]]("attachment_file_size", O.Default(None))
    /** Database column attachment_updated_at SqlType(DATETIME), Default(None) */
    val attachmentUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("attachment_updated_at", O.Default(None))
    /** Database column show_in_gallery SqlType(VARCHAR), Length(10,true), Default(Some(no)) */
    val showInGallery: Rep[Option[String]] = column[Option[String]]("show_in_gallery", O.Length(10,varying=true), O.Default(Some("no")))
    /** Database column guid SqlType(VARCHAR), Length(255,true), Default(None) */
    val guid: Rep[Option[String]] = column[Option[String]]("guid", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column activity_context SqlType(VARCHAR), Length(255,true), Default(None) */
    val activityContext: Rep[Option[String]] = column[Option[String]]("activity_context", O.Length(255,varying=true), O.Default(None))
    /** Database column message_id SqlType(INT), Default(None) */
    val messageId: Rep[Option[Int]] = column[Option[Int]]("message_id", O.Default(None))
    /** Database column message_action_id SqlType(INT), Default(None) */
    val messageActionId: Rep[Option[Int]] = column[Option[Int]]("message_action_id", O.Default(None))

    /** Index over (challengeId) (database name index_challenge_responses_on_challenge_id) */
    val index1 = index("index_challenge_responses_on_challenge_id", challengeId :: HNil)
    /** Index over (memberId,challengeId) (database name index_challenge_responses_on_member_id_and_challenge_id) */
    val index2 = index("index_challenge_responses_on_member_id_and_challenge_id", memberId :: challengeId :: HNil)
  }
  /** Collection-like TableQuery object for table ChallengeResponses */
  lazy val ChallengeResponses = new TableQuery(tag => new ChallengeResponses(tag))

  /** Row type of table Challenges */
  type ChallengesRow = HCons[Int,HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[String,HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[Int],HCons[Option[Boolean],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[Boolean],HCons[Option[String],HCons[scala.math.BigDecimal,HCons[Int,HCons[scala.math.BigDecimal,HCons[scala.math.BigDecimal,HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for ChallengesRow providing default values if available in the database schema. */
  def ChallengesRow(id: Int, programId: Option[Int] = None, name: Option[String] = None, description: Option[String] = None, eligibility: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, visibility: Option[String] = None, status: Option[String] = None, goal: Option[String] = None, responseType: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, showInGallery: Option[Boolean] = Some(true), showInChallenges: Option[Boolean] = Some(true), allowResponses: Option[Boolean] = Some(true), responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, responseTier: Option[String] = None, responseMaxPerMember: Option[Int] = None, responseMaxPerMemberUnit: Option[String] = None, responseInterval: Option[Int] = None, responseIntervalUnit: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, publishedAt: Option[java.sql.Timestamp] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, label: String, autoApprove: Option[Boolean] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, templateSetVersionId: Option[Int] = Some(0), showToPublic: Option[Boolean] = Some(false), newsFeedId: Option[Int] = None, shareOnNewsFeed: Option[String] = None, prizeType: Option[String] = None, prizeId: Option[Int] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeMetricName: Option[String] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[scala.math.BigDecimal] = None, showAsAlert: Option[Boolean] = Some(false), submissionMessage: Option[String] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), responsesCount: Int = 0, aggregatedBusinessValue: scala.math.BigDecimal = BigDecimal("0.00"), aggregatedMetricAmount: scala.math.BigDecimal = BigDecimal("0.00"), triggerActivityType: Option[String] = None, discountType: Option[String] = None, discountValue: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), discountMinSubtotal: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00"))): ChallengesRow = {
    id :: programId :: name :: description :: eligibility :: effectivityStart :: effectivityEnd :: effectivityTimezone :: visibility :: status :: goal :: responseType :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: showInGallery :: showInChallenges :: allowResponses :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: createdAt :: updatedAt :: publishedAt :: metricName :: metricAmount :: label :: autoApprove :: recurring :: recurringSchedule :: templateSetVersionId :: showToPublic :: newsFeedId :: shareOnNewsFeed :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: showAsAlert :: submissionMessage :: businessValue :: responsesCount :: aggregatedBusinessValue :: aggregatedMetricAmount :: triggerActivityType :: discountType :: discountValue :: discountMinSubtotal :: HNil
  }
  /** GetResult implicit for fetching ChallengesRow objects using plain SQL queries */
  implicit def GetResultChallengesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]], e5: GR[Option[scala.math.BigDecimal]], e6: GR[String], e7: GR[scala.math.BigDecimal]): GR[ChallengesRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[Int] :: <<?[Boolean] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[Boolean] :: <<?[String] :: <<[scala.math.BigDecimal] :: <<[Int] :: <<[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: HNil
  }
  /** Table description of table challenges. Objects of this class serve as prototypes for rows in queries. */
  class Challenges(_tableTag: Tag) extends Table[ChallengesRow](_tableTag, "challenges") {
    def * = id :: programId :: name :: description :: eligibility :: effectivityStart :: effectivityEnd :: effectivityTimezone :: visibility :: status :: goal :: responseType :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: showInGallery :: showInChallenges :: allowResponses :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: createdAt :: updatedAt :: publishedAt :: metricName :: metricAmount :: label :: autoApprove :: recurring :: recurringSchedule :: templateSetVersionId :: showToPublic :: newsFeedId :: shareOnNewsFeed :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: showAsAlert :: submissionMessage :: businessValue :: responsesCount :: aggregatedBusinessValue :: aggregatedMetricAmount :: triggerActivityType :: discountType :: discountValue :: discountMinSubtotal :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column eligibility SqlType(VARCHAR), Length(50,true), Default(None) */
    val eligibility: Rep[Option[String]] = column[Option[String]]("eligibility", O.Length(50,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column visibility SqlType(VARCHAR), Length(10,true), Default(None) */
    val visibility: Rep[Option[String]] = column[Option[String]]("visibility", O.Length(10,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column goal SqlType(VARCHAR), Length(50,true), Default(None) */
    val goal: Rep[Option[String]] = column[Option[String]]("goal", O.Length(50,varying=true), O.Default(None))
    /** Database column response_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val responseType: Rep[Option[String]] = column[Option[String]]("response_type", O.Length(50,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column show_in_gallery SqlType(BIT), Default(Some(true)) */
    val showInGallery: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_gallery", O.Default(Some(true)))
    /** Database column show_in_challenges SqlType(BIT), Default(Some(true)) */
    val showInChallenges: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_challenges", O.Default(Some(true)))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_per_member SqlType(INT), Default(None) */
    val responseMaxPerMember: Rep[Option[Int]] = column[Option[Int]]("response_max_per_member", O.Default(None))
    /** Database column response_max_per_member_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxPerMemberUnit: Rep[Option[String]] = column[Option[String]]("response_max_per_member_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_interval SqlType(INT), Default(None) */
    val responseInterval: Rep[Option[Int]] = column[Option[Int]]("response_interval", O.Default(None))
    /** Database column response_interval_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseIntervalUnit: Rep[Option[String]] = column[Option[String]]("response_interval_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column auto_approve SqlType(BIT), Default(None) */
    val autoApprove: Rep[Option[Boolean]] = column[Option[Boolean]]("auto_approve", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))
    /** Database column news_feed_id SqlType(INT), Default(None) */
    val newsFeedId: Rep[Option[Int]] = column[Option[Int]]("news_feed_id", O.Default(None))
    /** Database column share_on_news_feed SqlType(VARCHAR), Length(25,true), Default(None) */
    val shareOnNewsFeed: Rep[Option[String]] = column[Option[String]]("share_on_news_feed", O.Length(25,varying=true), O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(DECIMAL), Default(None) */
    val prizeProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_probability", O.Default(None))
    /** Database column show_as_alert SqlType(BIT), Default(Some(false)) */
    val showAsAlert: Rep[Option[Boolean]] = column[Option[Boolean]]("show_as_alert", O.Default(Some(false)))
    /** Database column submission_message SqlType(VARCHAR), Length(255,true), Default(None) */
    val submissionMessage: Rep[Option[String]] = column[Option[String]]("submission_message", O.Length(255,varying=true), O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column responses_count SqlType(INT), Default(0) */
    val responsesCount: Rep[Int] = column[Int]("responses_count", O.Default(0))
    /** Database column aggregated_business_value SqlType(DECIMAL), Default(0.00) */
    val aggregatedBusinessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_business_value", O.Default(BigDecimal("0.00")))
    /** Database column aggregated_metric_amount SqlType(DECIMAL), Default(0.00) */
    val aggregatedMetricAmount: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_metric_amount", O.Default(BigDecimal("0.00")))
    /** Database column trigger_activity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val triggerActivityType: Rep[Option[String]] = column[Option[String]]("trigger_activity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column discount_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val discountType: Rep[Option[String]] = column[Option[String]]("discount_type", O.Length(25,varying=true), O.Default(None))
    /** Database column discount_value SqlType(DECIMAL), Default(Some(0.00)) */
    val discountValue: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_value", O.Default(Some(BigDecimal("0.00"))))
    /** Database column discount_min_subtotal SqlType(DECIMAL), Default(Some(0.00)) */
    val discountMinSubtotal: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_min_subtotal", O.Default(Some(BigDecimal("0.00"))))

    /** Index over (newsFeedId) (database name index_challenges_on_news_feed_id) */
    val index1 = index("index_challenges_on_news_feed_id", newsFeedId :: HNil)
    /** Index over (templateSetVersionId) (database name index_challenges_on_template_set_version_id) */
    val index2 = index("index_challenges_on_template_set_version_id", templateSetVersionId :: HNil)
  }
  /** Collection-like TableQuery object for table Challenges */
  lazy val Challenges = new TableQuery(tag => new Challenges(tag))

  /** Entity class storing rows of table ChallengeSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param segmentId Database column segment_id SqlType(INT), Default(None)
   *  @param challengeId Database column challenge_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(true)) */
  case class ChallengeSegmentsRow(id: Int, segmentId: Option[Int] = None, challengeId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, included: Option[Boolean] = Some(true))
  /** GetResult implicit for fetching ChallengeSegmentsRow objects using plain SQL queries */
  implicit def GetResultChallengeSegmentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Boolean]]): GR[ChallengeSegmentsRow] = GR{
    prs => import prs._
    ChallengeSegmentsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean]))
  }
  /** Table description of table challenge_segments. Objects of this class serve as prototypes for rows in queries. */
  class ChallengeSegments(_tableTag: Tag) extends Table[ChallengeSegmentsRow](_tableTag, "challenge_segments") {
    def * = (id, segmentId, challengeId, createdAt, updatedAt, included) <> (ChallengeSegmentsRow.tupled, ChallengeSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), segmentId, challengeId, createdAt, updatedAt, included).shaped.<>({r=>import r._; _1.map(_=> ChallengeSegmentsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column segment_id SqlType(INT), Default(None) */
    val segmentId: Rep[Option[Int]] = column[Option[Int]]("segment_id", O.Default(None))
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(true)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(true)))

    /** Uniqueness Index over (challengeId,segmentId) (database name index_challenge_segments_on_challenge_id_and_segment_id) */
    val index1 = index("index_challenge_segments_on_challenge_id_and_segment_id", (challengeId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_challenge_segments_on_segment_id) */
    val index2 = index("index_challenge_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table ChallengeSegments */
  lazy val ChallengeSegments = new TableQuery(tag => new ChallengeSegments(tag))

  /** Entity class storing rows of table ChartPlotbands
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param dashboardPanelId Database column dashboard_panel_id SqlType(INT), Default(None)
   *  @param chartId Database column chart_id SqlType(INT), Default(None)
   *  @param boundary Database column boundary SqlType(DECIMAL), Default(None)
   *  @param color Database column color SqlType(VARCHAR), Length(10,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ChartPlotbandsRow(id: Int, dashboardPanelId: Option[Int] = None, chartId: Option[Int] = None, boundary: Option[scala.math.BigDecimal] = None, color: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ChartPlotbandsRow objects using plain SQL queries */
  implicit def GetResultChartPlotbandsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[scala.math.BigDecimal]], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]]): GR[ChartPlotbandsRow] = GR{
    prs => import prs._
    ChartPlotbandsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[scala.math.BigDecimal], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table chart_plotbands. Objects of this class serve as prototypes for rows in queries. */
  class ChartPlotbands(_tableTag: Tag) extends Table[ChartPlotbandsRow](_tableTag, "chart_plotbands") {
    def * = (id, dashboardPanelId, chartId, boundary, color, createdAt, updatedAt) <> (ChartPlotbandsRow.tupled, ChartPlotbandsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), dashboardPanelId, chartId, boundary, color, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ChartPlotbandsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column dashboard_panel_id SqlType(INT), Default(None) */
    val dashboardPanelId: Rep[Option[Int]] = column[Option[Int]]("dashboard_panel_id", O.Default(None))
    /** Database column chart_id SqlType(INT), Default(None) */
    val chartId: Rep[Option[Int]] = column[Option[Int]]("chart_id", O.Default(None))
    /** Database column boundary SqlType(DECIMAL), Default(None) */
    val boundary: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("boundary", O.Default(None))
    /** Database column color SqlType(VARCHAR), Length(10,true), Default(None) */
    val color: Rep[Option[String]] = column[Option[String]]("color", O.Length(10,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (dashboardPanelId) (database name index_chart_plotbands_on_dashboard_panel_id) */
    val index1 = index("index_chart_plotbands_on_dashboard_panel_id", dashboardPanelId)
  }
  /** Collection-like TableQuery object for table ChartPlotbands */
  lazy val ChartPlotbands = new TableQuery(tag => new ChartPlotbands(tag))

  /** Entity class storing rows of table ChartThemes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param value Database column value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ChartThemesRow(id: Int, name: String, label: String, value: Option[String] = None, rowOrder: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ChartThemesRow objects using plain SQL queries */
  implicit def GetResultChartThemesRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[ChartThemesRow] = GR{
    prs => import prs._
    ChartThemesRow.tupled((<<[Int], <<[String], <<[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table chart_themes. Objects of this class serve as prototypes for rows in queries. */
  class ChartThemes(_tableTag: Tag) extends Table[ChartThemesRow](_tableTag, "chart_themes") {
    def * = (id, name, label, value, rowOrder, createdAt, updatedAt) <> (ChartThemesRow.tupled, ChartThemesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), value, rowOrder, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ChartThemesRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column value SqlType(VARCHAR), Length(255,true), Default(None) */
    val value: Rep[Option[String]] = column[Option[String]]("value", O.Length(255,varying=true), O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ChartThemes */
  lazy val ChartThemes = new TableQuery(tag => new ChartThemes(tag))

  /** Entity class storing rows of table ClassifiableAttributeMappings
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param classificationAttributeId Database column classification_attribute_id SqlType(INT), Default(None)
   *  @param classifiableId Database column classifiable_id SqlType(INT), Default(None)
   *  @param classifiableType Database column classifiable_type SqlType(VARCHAR), Length(255,true), Default(None) */
  case class ClassifiableAttributeMappingsRow(id: Int, classificationAttributeId: Option[Int] = None, classifiableId: Option[Int] = None, classifiableType: Option[String] = None)
  /** GetResult implicit for fetching ClassifiableAttributeMappingsRow objects using plain SQL queries */
  implicit def GetResultClassifiableAttributeMappingsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]]): GR[ClassifiableAttributeMappingsRow] = GR{
    prs => import prs._
    ClassifiableAttributeMappingsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String]))
  }
  /** Table description of table classifiable_attribute_mappings. Objects of this class serve as prototypes for rows in queries. */
  class ClassifiableAttributeMappings(_tableTag: Tag) extends Table[ClassifiableAttributeMappingsRow](_tableTag, "classifiable_attribute_mappings") {
    def * = (id, classificationAttributeId, classifiableId, classifiableType) <> (ClassifiableAttributeMappingsRow.tupled, ClassifiableAttributeMappingsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), classificationAttributeId, classifiableId, classifiableType).shaped.<>({r=>import r._; _1.map(_=> ClassifiableAttributeMappingsRow.tupled((_1.get, _2, _3, _4)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column classification_attribute_id SqlType(INT), Default(None) */
    val classificationAttributeId: Rep[Option[Int]] = column[Option[Int]]("classification_attribute_id", O.Default(None))
    /** Database column classifiable_id SqlType(INT), Default(None) */
    val classifiableId: Rep[Option[Int]] = column[Option[Int]]("classifiable_id", O.Default(None))
    /** Database column classifiable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val classifiableType: Rep[Option[String]] = column[Option[String]]("classifiable_type", O.Length(255,varying=true), O.Default(None))

    /** Index over (classificationAttributeId) (database name idx_classifiable_attr_mappings_on_classification_attribute_id) */
    val index1 = index("idx_classifiable_attr_mappings_on_classification_attribute_id", classificationAttributeId)
  }
  /** Collection-like TableQuery object for table ClassifiableAttributeMappings */
  lazy val ClassifiableAttributeMappings = new TableQuery(tag => new ClassifiableAttributeMappings(tag))

  /** Entity class storing rows of table ClassifiableAttributeOptionProperties
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param classifiableAttributeMappingId Database column classifiable_attribute_mapping_id SqlType(INT), Default(None)
   *  @param classificationAttributeOptionId Database column classification_attribute_option_id SqlType(INT), Default(None)
   *  @param price Database column price SqlType(DECIMAL), Default(None)
   *  @param sku Database column sku SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None) */
  case class ClassifiableAttributeOptionPropertiesRow(id: Int, classifiableAttributeMappingId: Option[Int] = None, classificationAttributeOptionId: Option[Int] = None, price: Option[scala.math.BigDecimal] = None, sku: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ClassifiableAttributeOptionPropertiesRow objects using plain SQL queries */
  implicit def GetResultClassifiableAttributeOptionPropertiesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[scala.math.BigDecimal]], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]]): GR[ClassifiableAttributeOptionPropertiesRow] = GR{
    prs => import prs._
    ClassifiableAttributeOptionPropertiesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[scala.math.BigDecimal], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp]))
  }
  /** Table description of table classifiable_attribute_option_properties. Objects of this class serve as prototypes for rows in queries. */
  class ClassifiableAttributeOptionProperties(_tableTag: Tag) extends Table[ClassifiableAttributeOptionPropertiesRow](_tableTag, "classifiable_attribute_option_properties") {
    def * = (id, classifiableAttributeMappingId, classificationAttributeOptionId, price, sku, imageFileName, imageContentType, imageFileSize, imageUpdatedAt) <> (ClassifiableAttributeOptionPropertiesRow.tupled, ClassifiableAttributeOptionPropertiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), classifiableAttributeMappingId, classificationAttributeOptionId, price, sku, imageFileName, imageContentType, imageFileSize, imageUpdatedAt).shaped.<>({r=>import r._; _1.map(_=> ClassifiableAttributeOptionPropertiesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column classifiable_attribute_mapping_id SqlType(INT), Default(None) */
    val classifiableAttributeMappingId: Rep[Option[Int]] = column[Option[Int]]("classifiable_attribute_mapping_id", O.Default(None))
    /** Database column classification_attribute_option_id SqlType(INT), Default(None) */
    val classificationAttributeOptionId: Rep[Option[Int]] = column[Option[Int]]("classification_attribute_option_id", O.Default(None))
    /** Database column price SqlType(DECIMAL), Default(None) */
    val price: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("price", O.Default(None))
    /** Database column sku SqlType(VARCHAR), Length(255,true), Default(None) */
    val sku: Rep[Option[String]] = column[Option[String]]("sku", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ClassifiableAttributeOptionProperties */
  lazy val ClassifiableAttributeOptionProperties = new TableQuery(tag => new ClassifiableAttributeOptionProperties(tag))

  /** Entity class storing rows of table ClassificationAttributeOptions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param classificationAttributeId Database column classification_attribute_id SqlType(INT), Default(None)
   *  @param price Database column price SqlType(DECIMAL), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param default Database column default SqlType(VARCHAR), Length(5,true), Default(Some(no)) */
  case class ClassificationAttributeOptionsRow(id: Int, classificationAttributeId: Option[Int] = None, price: Option[scala.math.BigDecimal] = None, name: String, label: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, default: Option[String] = Some("no"))
  /** GetResult implicit for fetching ClassificationAttributeOptionsRow objects using plain SQL queries */
  implicit def GetResultClassificationAttributeOptionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[scala.math.BigDecimal]], e3: GR[String], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[String]]): GR[ClassificationAttributeOptionsRow] = GR{
    prs => import prs._
    ClassificationAttributeOptionsRow.tupled((<<[Int], <<?[Int], <<?[scala.math.BigDecimal], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table classification_attribute_options. Objects of this class serve as prototypes for rows in queries. */
  class ClassificationAttributeOptions(_tableTag: Tag) extends Table[ClassificationAttributeOptionsRow](_tableTag, "classification_attribute_options") {
    def * = (id, classificationAttributeId, price, name, label, createdAt, updatedAt, default) <> (ClassificationAttributeOptionsRow.tupled, ClassificationAttributeOptionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), classificationAttributeId, price, Rep.Some(name), Rep.Some(label), createdAt, updatedAt, default).shaped.<>({r=>import r._; _1.map(_=> ClassificationAttributeOptionsRow.tupled((_1.get, _2, _3, _4.get, _5.get, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column classification_attribute_id SqlType(INT), Default(None) */
    val classificationAttributeId: Rep[Option[Int]] = column[Option[Int]]("classification_attribute_id", O.Default(None))
    /** Database column price SqlType(DECIMAL), Default(None) */
    val price: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("price", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column default SqlType(VARCHAR), Length(5,true), Default(Some(no)) */
    val default: Rep[Option[String]] = column[Option[String]]("default", O.Length(5,varying=true), O.Default(Some("no")))

    /** Index over (classificationAttributeId) (database name idx_classification_attr_options_on_classification_attribute_id) */
    val index1 = index("idx_classification_attr_options_on_classification_attribute_id", classificationAttributeId)
  }
  /** Collection-like TableQuery object for table ClassificationAttributeOptions */
  lazy val ClassificationAttributeOptions = new TableQuery(tag => new ClassificationAttributeOptions(tag))

  /** Entity class storing rows of table ClassificationAttributes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param classificationId Database column classification_id SqlType(INT), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ClassificationAttributesRow(id: Int, classificationId: Option[Int] = None, name: String, label: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ClassificationAttributesRow objects using plain SQL queries */
  implicit def GetResultClassificationAttributesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[java.sql.Timestamp]]): GR[ClassificationAttributesRow] = GR{
    prs => import prs._
    ClassificationAttributesRow.tupled((<<[Int], <<?[Int], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table classification_attributes. Objects of this class serve as prototypes for rows in queries. */
  class ClassificationAttributes(_tableTag: Tag) extends Table[ClassificationAttributesRow](_tableTag, "classification_attributes") {
    def * = (id, classificationId, name, label, createdAt, updatedAt) <> (ClassificationAttributesRow.tupled, ClassificationAttributesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), classificationId, Rep.Some(name), Rep.Some(label), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ClassificationAttributesRow.tupled((_1.get, _2, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column classification_id SqlType(INT), Default(None) */
    val classificationId: Rep[Option[Int]] = column[Option[Int]]("classification_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (classificationId) (database name index_classification_attributes_on_classification_id) */
    val index1 = index("index_classification_attributes_on_classification_id", classificationId)
  }
  /** Collection-like TableQuery object for table ClassificationAttributes */
  lazy val ClassificationAttributes = new TableQuery(tag => new ClassificationAttributes(tag))

  /** Entity class storing rows of table ClassificationMappings
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param classificationId Database column classification_id SqlType(INT), Default(None)
   *  @param classifiableId Database column classifiable_id SqlType(INT), Default(None)
   *  @param classifiableType Database column classifiable_type SqlType(VARCHAR), Length(255,true), Default(None) */
  case class ClassificationMappingsRow(id: Int, classificationId: Option[Int] = None, classifiableId: Option[Int] = None, classifiableType: Option[String] = None)
  /** GetResult implicit for fetching ClassificationMappingsRow objects using plain SQL queries */
  implicit def GetResultClassificationMappingsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]]): GR[ClassificationMappingsRow] = GR{
    prs => import prs._
    ClassificationMappingsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String]))
  }
  /** Table description of table classification_mappings. Objects of this class serve as prototypes for rows in queries. */
  class ClassificationMappings(_tableTag: Tag) extends Table[ClassificationMappingsRow](_tableTag, "classification_mappings") {
    def * = (id, classificationId, classifiableId, classifiableType) <> (ClassificationMappingsRow.tupled, ClassificationMappingsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), classificationId, classifiableId, classifiableType).shaped.<>({r=>import r._; _1.map(_=> ClassificationMappingsRow.tupled((_1.get, _2, _3, _4)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column classification_id SqlType(INT), Default(None) */
    val classificationId: Rep[Option[Int]] = column[Option[Int]]("classification_id", O.Default(None))
    /** Database column classifiable_id SqlType(INT), Default(None) */
    val classifiableId: Rep[Option[Int]] = column[Option[Int]]("classifiable_id", O.Default(None))
    /** Database column classifiable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val classifiableType: Rep[Option[String]] = column[Option[String]]("classifiable_type", O.Length(255,varying=true), O.Default(None))

    /** Index over (classificationId) (database name index_classification_mappings_on_classification_id) */
    val index1 = index("index_classification_mappings_on_classification_id", classificationId)
  }
  /** Collection-like TableQuery object for table ClassificationMappings */
  lazy val ClassificationMappings = new TableQuery(tag => new ClassificationMappings(tag))

  /** Entity class storing rows of table Classifications
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None) */
  case class ClassificationsRow(id: Int, name: String, label: String, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, status: String = "draft", createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, description: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, `type`: Option[String] = None)
  /** GetResult implicit for fetching ClassificationsRow objects using plain SQL queries */
  implicit def GetResultClassificationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]], e4: GR[Option[Boolean]]): GR[ClassificationsRow] = GR{
    prs => import prs._
    ClassificationsRow.tupled((<<[Int], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Boolean], <<?[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table classifications. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Classifications(_tableTag: Tag) extends Table[ClassificationsRow](_tableTag, "classifications") {
    def * = (id, name, label, effectivityStart, effectivityEnd, effectivityTimezone, recurring, recurringSchedule, status, createdAt, updatedAt, description, publishedAt, `type`) <> (ClassificationsRow.tupled, ClassificationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), effectivityStart, effectivityEnd, effectivityTimezone, recurring, recurringSchedule, Rep.Some(status), createdAt, updatedAt, description, publishedAt, `type`).shaped.<>({r=>import r._; _1.map(_=> ClassificationsRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6, _7, _8, _9.get, _10, _11, _12, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
  }
  /** Collection-like TableQuery object for table Classifications */
  lazy val Classifications = new TableQuery(tag => new Classifications(tag))

  /** Entity class storing rows of table ClientEventOffers
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param clientEventId Database column client_event_id SqlType(INT), Default(None)
   *  @param offerId Database column offer_id SqlType(INT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param sequence Database column sequence SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ClientEventOffersRow(id: Int, clientEventId: Option[Int] = None, offerId: Option[Int] = None, rowOrder: Option[Int] = None, sequence: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ClientEventOffersRow objects using plain SQL queries */
  implicit def GetResultClientEventOffersRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[ClientEventOffersRow] = GR{
    prs => import prs._
    ClientEventOffersRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table client_event_offers. Objects of this class serve as prototypes for rows in queries. */
  class ClientEventOffers(_tableTag: Tag) extends Table[ClientEventOffersRow](_tableTag, "client_event_offers") {
    def * = (id, clientEventId, offerId, rowOrder, sequence, createdAt, updatedAt) <> (ClientEventOffersRow.tupled, ClientEventOffersRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), clientEventId, offerId, rowOrder, sequence, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ClientEventOffersRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column client_event_id SqlType(INT), Default(None) */
    val clientEventId: Rep[Option[Int]] = column[Option[Int]]("client_event_id", O.Default(None))
    /** Database column offer_id SqlType(INT), Default(None) */
    val offerId: Rep[Option[Int]] = column[Option[Int]]("offer_id", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column sequence SqlType(INT), Default(None) */
    val sequence: Rep[Option[Int]] = column[Option[Int]]("sequence", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ClientEventOffers */
  lazy val ClientEventOffers = new TableQuery(tag => new ClientEventOffers(tag))

  /** Row type of table ClientEvents */
  type ClientEventsRow = HCons[Int,HCons[String,HCons[String,HCons[Option[java.sql.Timestamp],HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HNil]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for ClientEventsRow providing default values if available in the database schema. */
  def ClientEventsRow(id: Int, name: String, label: String, publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, description: Option[String] = None, strategy: Option[String] = None, rowOrder: Option[Int] = None, sequence: Option[Int] = None, limitCount: Option[Int] = None, limitMetric: Option[String] = None, limitScope: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, eventType: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None): ClientEventsRow = {
    id :: name :: label :: publishedAt :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: description :: strategy :: rowOrder :: sequence :: limitCount :: limitMetric :: limitScope :: createdAt :: updatedAt :: eventType :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: HNil
  }
  /** GetResult implicit for fetching ClientEventsRow objects using plain SQL queries */
  implicit def GetResultClientEventsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]], e4: GR[Option[Boolean]], e5: GR[Option[Int]]): GR[ClientEventsRow] = GR{
    prs => import prs._
    <<[Int] :: <<[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: HNil
  }
  /** Table description of table client_events. Objects of this class serve as prototypes for rows in queries. */
  class ClientEvents(_tableTag: Tag) extends Table[ClientEventsRow](_tableTag, "client_events") {
    def * = id :: name :: label :: publishedAt :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: description :: strategy :: rowOrder :: sequence :: limitCount :: limitMetric :: limitScope :: createdAt :: updatedAt :: eventType :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column strategy SqlType(VARCHAR), Length(255,true), Default(None) */
    val strategy: Rep[Option[String]] = column[Option[String]]("strategy", O.Length(255,varying=true), O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column sequence SqlType(INT), Default(None) */
    val sequence: Rep[Option[Int]] = column[Option[Int]]("sequence", O.Default(None))
    /** Database column limit_count SqlType(INT), Default(None) */
    val limitCount: Rep[Option[Int]] = column[Option[Int]]("limit_count", O.Default(None))
    /** Database column limit_metric SqlType(VARCHAR), Length(255,true), Default(None) */
    val limitMetric: Rep[Option[String]] = column[Option[String]]("limit_metric", O.Length(255,varying=true), O.Default(None))
    /** Database column limit_scope SqlType(VARCHAR), Length(255,true), Default(None) */
    val limitScope: Rep[Option[String]] = column[Option[String]]("limit_scope", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column event_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val eventType: Rep[Option[String]] = column[Option[String]]("event_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ClientEvents */
  lazy val ClientEvents = new TableQuery(tag => new ClientEvents(tag))

  /** Entity class storing rows of table ClientEventTargets
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param clientEventId Database column client_event_id SqlType(INT), Default(None)
   *  @param targetId Database column target_id SqlType(INT), Default(None)
   *  @param targetType Database column target_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class ClientEventTargetsRow(id: Int, clientEventId: Option[Int] = None, targetId: Option[Int] = None, targetType: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching ClientEventTargetsRow objects using plain SQL queries */
  implicit def GetResultClientEventTargetsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ClientEventTargetsRow] = GR{
    prs => import prs._
    ClientEventTargetsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table client_event_targets. Objects of this class serve as prototypes for rows in queries. */
  class ClientEventTargets(_tableTag: Tag) extends Table[ClientEventTargetsRow](_tableTag, "client_event_targets") {
    def * = (id, clientEventId, targetId, targetType, createdAt, updatedAt, rowOrder) <> (ClientEventTargetsRow.tupled, ClientEventTargetsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), clientEventId, targetId, targetType, createdAt, updatedAt, rowOrder).shaped.<>({r=>import r._; _1.map(_=> ClientEventTargetsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column client_event_id SqlType(INT), Default(None) */
    val clientEventId: Rep[Option[Int]] = column[Option[Int]]("client_event_id", O.Default(None))
    /** Database column target_id SqlType(INT), Default(None) */
    val targetId: Rep[Option[Int]] = column[Option[Int]]("target_id", O.Default(None))
    /** Database column target_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val targetType: Rep[Option[String]] = column[Option[String]]("target_type", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
  }
  /** Collection-like TableQuery object for table ClientEventTargets */
  lazy val ClientEventTargets = new TableQuery(tag => new ClientEventTargets(tag))

  /** Entity class storing rows of table CodeEntries
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param codeId Database column code_id SqlType(INT), Default(None)
   *  @param value Database column value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param responsesCount Database column responses_count SqlType(INT), Default(Some(0))
   *  @param winning Database column winning SqlType(BIT), Default(Some(false))
   *  @param price Database column price SqlType(DECIMAL), Default(Some(0.00))
   *  @param retailer Database column retailer SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param cancelled Database column cancelled SqlType(BIT), Default(Some(false))
   *  @param terminal Database column terminal SqlType(VARCHAR), Length(255,true), Default(None) */
  case class CodeEntriesRow(id: Int, codeId: Option[Int] = None, value: Option[String] = None, status: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, responsesCount: Option[Int] = Some(0), winning: Option[Boolean] = Some(false), price: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), retailer: Option[String] = None, properties: Option[String] = None, cancelled: Option[Boolean] = Some(false), terminal: Option[String] = None)
  /** GetResult implicit for fetching CodeEntriesRow objects using plain SQL queries */
  implicit def GetResultCodeEntriesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]], e5: GR[Option[scala.math.BigDecimal]]): GR[CodeEntriesRow] = GR{
    prs => import prs._
    CodeEntriesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[Boolean], <<?[scala.math.BigDecimal], <<?[String], <<?[String], <<?[Boolean], <<?[String]))
  }
  /** Table description of table code_entries. Objects of this class serve as prototypes for rows in queries. */
  class CodeEntries(_tableTag: Tag) extends Table[CodeEntriesRow](_tableTag, "code_entries") {
    def * = (id, codeId, value, status, createdAt, updatedAt, responsesCount, winning, price, retailer, properties, cancelled, terminal) <> (CodeEntriesRow.tupled, CodeEntriesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), codeId, value, status, createdAt, updatedAt, responsesCount, winning, price, retailer, properties, cancelled, terminal).shaped.<>({r=>import r._; _1.map(_=> CodeEntriesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column code_id SqlType(INT), Default(None) */
    val codeId: Rep[Option[Int]] = column[Option[Int]]("code_id", O.Default(None))
    /** Database column value SqlType(VARCHAR), Length(255,true), Default(None) */
    val value: Rep[Option[String]] = column[Option[String]]("value", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column responses_count SqlType(INT), Default(Some(0)) */
    val responsesCount: Rep[Option[Int]] = column[Option[Int]]("responses_count", O.Default(Some(0)))
    /** Database column winning SqlType(BIT), Default(Some(false)) */
    val winning: Rep[Option[Boolean]] = column[Option[Boolean]]("winning", O.Default(Some(false)))
    /** Database column price SqlType(DECIMAL), Default(Some(0.00)) */
    val price: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("price", O.Default(Some(BigDecimal("0.00"))))
    /** Database column retailer SqlType(VARCHAR), Length(255,true), Default(None) */
    val retailer: Rep[Option[String]] = column[Option[String]]("retailer", O.Length(255,varying=true), O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column cancelled SqlType(BIT), Default(Some(false)) */
    val cancelled: Rep[Option[Boolean]] = column[Option[Boolean]]("cancelled", O.Default(Some(false)))
    /** Database column terminal SqlType(VARCHAR), Length(255,true), Default(None) */
    val terminal: Rep[Option[String]] = column[Option[String]]("terminal", O.Length(255,varying=true), O.Default(None))

    /** Uniqueness Index over (codeId,value) (database name index_code_entries_on_code_id_and_value) */
    val index1 = index("index_code_entries_on_code_id_and_value", (codeId, value), unique=true)
  }
  /** Collection-like TableQuery object for table CodeEntries */
  lazy val CodeEntries = new TableQuery(tag => new CodeEntries(tag))

  /** Entity class storing rows of table CodeResponses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param codeId Database column code_id SqlType(INT), Default(None)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param response Database column response SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeMetricName Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param prizeMetricAmount Database column prize_metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeId Database column prize_id SqlType(INT), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param metricAmount Database column metric_amount SqlType(DECIMAL), Default(None)
   *  @param codeEntryId Database column code_entry_id SqlType(INT), Default(None)
   *  @param businessValue Database column business_value SqlType(DECIMAL), Default(0.00)
   *  @param scannedCode Database column scanned_code SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param submittedValues Database column submitted_values SqlType(TEXT), Default(None) */
  case class CodeResponsesRow(id: Int, codeId: Option[Int] = None, memberId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, status: Option[String] = None, response: Option[String] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeId: Option[Int] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, codeEntryId: Option[Int] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), scannedCode: Option[String] = None, submittedValues: Option[String] = None)
  /** GetResult implicit for fetching CodeResponsesRow objects using plain SQL queries */
  implicit def GetResultCodeResponsesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]], e4: GR[Option[scala.math.BigDecimal]], e5: GR[scala.math.BigDecimal]): GR[CodeResponsesRow] = GR{
    prs => import prs._
    CodeResponsesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[Int], <<?[String], <<?[scala.math.BigDecimal], <<?[Int], <<[scala.math.BigDecimal], <<?[String], <<?[String]))
  }
  /** Table description of table code_responses. Objects of this class serve as prototypes for rows in queries. */
  class CodeResponses(_tableTag: Tag) extends Table[CodeResponsesRow](_tableTag, "code_responses") {
    def * = (id, codeId, memberId, createdAt, updatedAt, status, response, prizeType, prizeMetricName, prizeMetricAmount, prizeId, metricName, metricAmount, codeEntryId, businessValue, scannedCode, submittedValues) <> (CodeResponsesRow.tupled, CodeResponsesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), codeId, memberId, createdAt, updatedAt, status, response, prizeType, prizeMetricName, prizeMetricAmount, prizeId, metricName, metricAmount, codeEntryId, Rep.Some(businessValue), scannedCode, submittedValues).shaped.<>({r=>import r._; _1.map(_=> CodeResponsesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15.get, _16, _17)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column code_id SqlType(INT), Default(None) */
    val codeId: Rep[Option[Int]] = column[Option[Int]]("code_id", O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(None))
    /** Database column response SqlType(VARCHAR), Length(255,true), Default(None) */
    val response: Rep[Option[String]] = column[Option[String]]("response", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column code_entry_id SqlType(INT), Default(None) */
    val codeEntryId: Rep[Option[Int]] = column[Option[Int]]("code_entry_id", O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column scanned_code SqlType(VARCHAR), Length(255,true), Default(None) */
    val scannedCode: Rep[Option[String]] = column[Option[String]]("scanned_code", O.Length(255,varying=true), O.Default(None))
    /** Database column submitted_values SqlType(TEXT), Default(None) */
    val submittedValues: Rep[Option[String]] = column[Option[String]]("submitted_values", O.Default(None))

    /** Index over (codeEntryId) (database name index_code_responses_on_code_entry_id) */
    val index1 = index("index_code_responses_on_code_entry_id", codeEntryId)
    /** Index over (codeId) (database name index_code_responses_on_code_id) */
    val index2 = index("index_code_responses_on_code_id", codeId)
    /** Index over (memberId,codeId) (database name index_code_responses_on_member_id_and_code_id) */
    val index3 = index("index_code_responses_on_member_id_and_code_id", (memberId, codeId))
  }
  /** Collection-like TableQuery object for table CodeResponses */
  lazy val CodeResponses = new TableQuery(tag => new CodeResponses(tag))

  /** Row type of table Codes */
  type CodesRow = HCons[Int,HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[String,HCons[String,HCons[Option[java.sql.Timestamp],HCons[String,HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Int],HCons[scala.math.BigDecimal,HCons[scala.math.BigDecimal,HCons[Int,HCons[scala.math.BigDecimal,HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for CodesRow providing default values if available in the database schema. */
  def CodesRow(id: Int, upc: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, prizeType: Option[String] = None, prizeId: Option[Int] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeMetricName: Option[String] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[scala.math.BigDecimal] = None, name: String, label: String, publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", codeType: Option[String] = None, codeSharing: Option[String] = None, description: Option[String] = None, programId: Option[Int] = None, responseInterval: Option[Int] = None, responseIntervalUnit: Option[String] = None, responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, responseTier: Option[String] = None, responseMaxPerMember: Option[Int] = None, responseMaxPerMemberUnit: Option[String] = None, showInList: Option[Boolean] = Some(true), allowResponses: Option[Boolean] = Some(true), responseMaxOverallPerCodeEntry: Option[Int] = Some(1), businessValue: scala.math.BigDecimal = BigDecimal("0.00"), aggregatedBusinessValue: scala.math.BigDecimal = BigDecimal("0.00"), responsesCount: Int = 0, aggregatedMetricAmount: scala.math.BigDecimal = BigDecimal("0.00"), discountType: Option[String] = None, discountValue: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), discountMinSubtotal: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), hashKey: Option[String] = None, hashAlgorithm: Option[String] = None, `type`: Option[String] = None, price: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), vendor: Option[String] = None): CodesRow = {
    id :: upc :: createdAt :: updatedAt :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: metricName :: metricAmount :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: name :: label :: publishedAt :: status :: codeType :: codeSharing :: description :: programId :: responseInterval :: responseIntervalUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: showInList :: allowResponses :: responseMaxOverallPerCodeEntry :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: discountType :: discountValue :: discountMinSubtotal :: hashKey :: hashAlgorithm :: `type` :: price :: vendor :: HNil
  }
  /** GetResult implicit for fetching CodesRow objects using plain SQL queries */
  implicit def GetResultCodesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Boolean]], e4: GR[Option[scala.math.BigDecimal]], e5: GR[Option[Int]], e6: GR[String], e7: GR[scala.math.BigDecimal]): GR[CodesRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Int] :: <<[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<[Int] :: <<[scala.math.BigDecimal] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: HNil
  }
  /** Table description of table codes. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Codes(_tableTag: Tag) extends Table[CodesRow](_tableTag, "codes") {
    def * = id :: upc :: createdAt :: updatedAt :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: metricName :: metricAmount :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: name :: label :: publishedAt :: status :: codeType :: codeSharing :: description :: programId :: responseInterval :: responseIntervalUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: showInList :: allowResponses :: responseMaxOverallPerCodeEntry :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: discountType :: discountValue :: discountMinSubtotal :: hashKey :: hashAlgorithm :: `type` :: price :: vendor :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column upc SqlType(VARCHAR), Length(255,true), Default(None) */
    val upc: Rep[Option[String]] = column[Option[String]]("upc", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(DECIMAL), Default(None) */
    val prizeProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_probability", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column code_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val codeType: Rep[Option[String]] = column[Option[String]]("code_type", O.Length(25,varying=true), O.Default(None))
    /** Database column code_sharing SqlType(VARCHAR), Length(25,true), Default(None) */
    val codeSharing: Rep[Option[String]] = column[Option[String]]("code_sharing", O.Length(25,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column response_interval SqlType(INT), Default(None) */
    val responseInterval: Rep[Option[Int]] = column[Option[Int]]("response_interval", O.Default(None))
    /** Database column response_interval_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseIntervalUnit: Rep[Option[String]] = column[Option[String]]("response_interval_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_per_member SqlType(INT), Default(None) */
    val responseMaxPerMember: Rep[Option[Int]] = column[Option[Int]]("response_max_per_member", O.Default(None))
    /** Database column response_max_per_member_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxPerMemberUnit: Rep[Option[String]] = column[Option[String]]("response_max_per_member_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column show_in_list SqlType(BIT), Default(Some(true)) */
    val showInList: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_list", O.Default(Some(true)))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column response_max_overall_per_code_entry SqlType(INT), Default(Some(1)) */
    val responseMaxOverallPerCodeEntry: Rep[Option[Int]] = column[Option[Int]]("response_max_overall_per_code_entry", O.Default(Some(1)))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column aggregated_business_value SqlType(DECIMAL), Default(0.00) */
    val aggregatedBusinessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_business_value", O.Default(BigDecimal("0.00")))
    /** Database column responses_count SqlType(INT), Default(0) */
    val responsesCount: Rep[Int] = column[Int]("responses_count", O.Default(0))
    /** Database column aggregated_metric_amount SqlType(DECIMAL), Default(0.00) */
    val aggregatedMetricAmount: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_metric_amount", O.Default(BigDecimal("0.00")))
    /** Database column discount_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val discountType: Rep[Option[String]] = column[Option[String]]("discount_type", O.Length(25,varying=true), O.Default(None))
    /** Database column discount_value SqlType(DECIMAL), Default(Some(0.00)) */
    val discountValue: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_value", O.Default(Some(BigDecimal("0.00"))))
    /** Database column discount_min_subtotal SqlType(DECIMAL), Default(Some(0.00)) */
    val discountMinSubtotal: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_min_subtotal", O.Default(Some(BigDecimal("0.00"))))
    /** Database column hash_key SqlType(VARCHAR), Length(255,true), Default(None) */
    val hashKey: Rep[Option[String]] = column[Option[String]]("hash_key", O.Length(255,varying=true), O.Default(None))
    /** Database column hash_algorithm SqlType(VARCHAR), Length(255,true), Default(None) */
    val hashAlgorithm: Rep[Option[String]] = column[Option[String]]("hash_algorithm", O.Length(255,varying=true), O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column price SqlType(DECIMAL), Default(Some(0.00)) */
    val price: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("price", O.Default(Some(BigDecimal("0.00"))))
    /** Database column vendor SqlType(VARCHAR), Length(255,true), Default(None) */
    val vendor: Rep[Option[String]] = column[Option[String]]("vendor", O.Length(255,varying=true), O.Default(None))

    /** Index over (label) (database name index_codes_on_label) */
    val index1 = index("index_codes_on_label", label :: HNil)
    /** Uniqueness Index over (name) (database name index_codes_on_name) */
    val index2 = index("index_codes_on_name", name :: HNil, unique=true)
    /** Index over (status) (database name index_codes_on_status) */
    val index3 = index("index_codes_on_status", status :: HNil)
    /** Index over (upc) (database name index_codes_on_upc) */
    val index4 = index("index_codes_on_upc", upc :: HNil)
  }
  /** Collection-like TableQuery object for table Codes */
  lazy val Codes = new TableQuery(tag => new Codes(tag))

  /** Entity class storing rows of table CodeSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param codeId Database column code_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(Some(true))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CodeSegmentsRow(id: Int, segmentId: Int, codeId: Int, included: Option[Boolean] = Some(true), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CodeSegmentsRow objects using plain SQL queries */
  implicit def GetResultCodeSegmentsRow(implicit e0: GR[Int], e1: GR[Option[Boolean]], e2: GR[Option[java.sql.Timestamp]]): GR[CodeSegmentsRow] = GR{
    prs => import prs._
    CodeSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table code_segments. Objects of this class serve as prototypes for rows in queries. */
  class CodeSegments(_tableTag: Tag) extends Table[CodeSegmentsRow](_tableTag, "code_segments") {
    def * = (id, segmentId, codeId, included, createdAt, updatedAt) <> (CodeSegmentsRow.tupled, CodeSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(segmentId), Rep.Some(codeId), included, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CodeSegmentsRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column code_id SqlType(INT) */
    val codeId: Rep[Int] = column[Int]("code_id")
    /** Database column included SqlType(BIT), Default(Some(true)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(true)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (codeId,segmentId) (database name index_code_segments_on_code_id_and_segment_id) */
    val index1 = index("index_code_segments_on_code_id_and_segment_id", (codeId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_code_segments_on_segment_id) */
    val index2 = index("index_code_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table CodeSegments */
  lazy val CodeSegments = new TableQuery(tag => new CodeSegments(tag))

  /** Entity class storing rows of table CodeValues
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param codeId Database column code_id SqlType(INT), Default(None)
   *  @param value Database column value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param vendor Database column vendor SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CodeValuesRow(id: Int, codeId: Option[Int] = None, value: Option[String] = None, vendor: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CodeValuesRow objects using plain SQL queries */
  implicit def GetResultCodeValuesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[CodeValuesRow] = GR{
    prs => import prs._
    CodeValuesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table code_values. Objects of this class serve as prototypes for rows in queries. */
  class CodeValues(_tableTag: Tag) extends Table[CodeValuesRow](_tableTag, "code_values") {
    def * = (id, codeId, value, vendor, createdAt, updatedAt) <> (CodeValuesRow.tupled, CodeValuesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), codeId, value, vendor, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CodeValuesRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column code_id SqlType(INT), Default(None) */
    val codeId: Rep[Option[Int]] = column[Option[Int]]("code_id", O.Default(None))
    /** Database column value SqlType(VARCHAR), Length(255,true), Default(None) */
    val value: Rep[Option[String]] = column[Option[String]]("value", O.Length(255,varying=true), O.Default(None))
    /** Database column vendor SqlType(VARCHAR), Length(255,true), Default(None) */
    val vendor: Rep[Option[String]] = column[Option[String]]("vendor", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (codeId,vendor) (database name index_code_values_on_code_id_and_vendor) */
    val index1 = index("index_code_values_on_code_id_and_vendor", (codeId, vendor), unique=true)
    /** Index over (value) (database name index_code_values_on_value) */
    val index2 = index("index_code_values_on_value", value)
  }
  /** Collection-like TableQuery object for table CodeValues */
  lazy val CodeValues = new TableQuery(tag => new CodeValues(tag))

  /** Entity class storing rows of table CombinationValues
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param classifiableId Database column classifiable_id SqlType(INT), Default(None)
   *  @param classifiableType Database column classifiable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param sku Database column sku SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param metricAmount Database column metric_amount SqlType(DECIMAL), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CombinationValuesRow(id: Int, classifiableId: Option[Int] = None, classifiableType: Option[String] = None, sku: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, metricName: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CombinationValuesRow objects using plain SQL queries */
  implicit def GetResultCombinationValuesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]]): GR[CombinationValuesRow] = GR{
    prs => import prs._
    CombinationValuesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table combination_values. Objects of this class serve as prototypes for rows in queries. */
  class CombinationValues(_tableTag: Tag) extends Table[CombinationValuesRow](_tableTag, "combination_values") {
    def * = (id, classifiableId, classifiableType, sku, metricAmount, metricName, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt) <> (CombinationValuesRow.tupled, CombinationValuesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), classifiableId, classifiableType, sku, metricAmount, metricName, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CombinationValuesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column classifiable_id SqlType(INT), Default(None) */
    val classifiableId: Rep[Option[Int]] = column[Option[Int]]("classifiable_id", O.Default(None))
    /** Database column classifiable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val classifiableType: Rep[Option[String]] = column[Option[String]]("classifiable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column sku SqlType(VARCHAR), Length(100,true), Default(None) */
    val sku: Rep[Option[String]] = column[Option[String]]("sku", O.Length(100,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table CombinationValues */
  lazy val CombinationValues = new TableQuery(tag => new CombinationValues(tag))

  /** Entity class storing rows of table CombinedGroups
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param ruleGroupCombinationId Database column rule_group_combination_id SqlType(INT)
   *  @param ruleGroupId Database column rule_group_id SqlType(INT)
   *  @param order Database column order SqlType(INT), Default(Some(1))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class CombinedGroupsRow(id: Int, ruleGroupCombinationId: Int, ruleGroupId: Int, order: Option[Int] = Some(1), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching CombinedGroupsRow objects using plain SQL queries */
  implicit def GetResultCombinedGroupsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[CombinedGroupsRow] = GR{
    prs => import prs._
    CombinedGroupsRow.tupled((<<[Int], <<[Int], <<[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table combined_groups. Objects of this class serve as prototypes for rows in queries. */
  class CombinedGroups(_tableTag: Tag) extends Table[CombinedGroupsRow](_tableTag, "combined_groups") {
    def * = (id, ruleGroupCombinationId, ruleGroupId, order, createdAt, updatedAt) <> (CombinedGroupsRow.tupled, CombinedGroupsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(ruleGroupCombinationId), Rep.Some(ruleGroupId), order, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> CombinedGroupsRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column rule_group_combination_id SqlType(INT) */
    val ruleGroupCombinationId: Rep[Int] = column[Int]("rule_group_combination_id")
    /** Database column rule_group_id SqlType(INT) */
    val ruleGroupId: Rep[Int] = column[Int]("rule_group_id")
    /** Database column order SqlType(INT), Default(Some(1)) */
    val order: Rep[Option[Int]] = column[Option[Int]]("order", O.Default(Some(1)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (ruleGroupCombinationId,ruleGroupId) (database name idx_combined_groups_on_rule_group_comb_id_and_rule_group_id) */
    val index1 = index("idx_combined_groups_on_rule_group_comb_id_and_rule_group_id", (ruleGroupCombinationId, ruleGroupId), unique=true)
    /** Index over (ruleGroupId) (database name index_combined_groups_on_rule_group_id) */
    val index2 = index("index_combined_groups_on_rule_group_id", ruleGroupId)
  }
  /** Collection-like TableQuery object for table CombinedGroups */
  lazy val CombinedGroups = new TableQuery(tag => new CombinedGroups(tag))

  /** Entity class storing rows of table Comments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param commentableId Database column commentable_id SqlType(INT), Default(None)
   *  @param commentableType Database column commentable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param commenterId Database column commenter_id SqlType(INT), Default(None)
   *  @param commenterType Database column commenter_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param message Database column message SqlType(TEXT), Default(None)
   *  @param parentId Database column parent_id SqlType(INT), Default(None)
   *  @param lft Database column lft SqlType(INT), Default(None)
   *  @param rgt Database column rgt SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param visible Database column visible SqlType(BIT), Default(Some(true)) */
  case class CommentsRow(id: Int, commentableId: Option[Int] = None, commentableType: Option[String] = None, commenterId: Option[Int] = None, commenterType: Option[String] = None, message: Option[String] = None, parentId: Option[Int] = None, lft: Option[Int] = None, rgt: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, visible: Option[Boolean] = Some(true))
  /** GetResult implicit for fetching CommentsRow objects using plain SQL queries */
  implicit def GetResultCommentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]]): GR[CommentsRow] = GR{
    prs => import prs._
    CommentsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean]))
  }
  /** Table description of table comments. Objects of this class serve as prototypes for rows in queries. */
  class Comments(_tableTag: Tag) extends Table[CommentsRow](_tableTag, "comments") {
    def * = (id, commentableId, commentableType, commenterId, commenterType, message, parentId, lft, rgt, createdAt, updatedAt, visible) <> (CommentsRow.tupled, CommentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), commentableId, commentableType, commenterId, commenterType, message, parentId, lft, rgt, createdAt, updatedAt, visible).shaped.<>({r=>import r._; _1.map(_=> CommentsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column commentable_id SqlType(INT), Default(None) */
    val commentableId: Rep[Option[Int]] = column[Option[Int]]("commentable_id", O.Default(None))
    /** Database column commentable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val commentableType: Rep[Option[String]] = column[Option[String]]("commentable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column commenter_id SqlType(INT), Default(None) */
    val commenterId: Rep[Option[Int]] = column[Option[Int]]("commenter_id", O.Default(None))
    /** Database column commenter_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val commenterType: Rep[Option[String]] = column[Option[String]]("commenter_type", O.Length(255,varying=true), O.Default(None))
    /** Database column message SqlType(TEXT), Default(None) */
    val message: Rep[Option[String]] = column[Option[String]]("message", O.Default(None))
    /** Database column parent_id SqlType(INT), Default(None) */
    val parentId: Rep[Option[Int]] = column[Option[Int]]("parent_id", O.Default(None))
    /** Database column lft SqlType(INT), Default(None) */
    val lft: Rep[Option[Int]] = column[Option[Int]]("lft", O.Default(None))
    /** Database column rgt SqlType(INT), Default(None) */
    val rgt: Rep[Option[Int]] = column[Option[Int]]("rgt", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column visible SqlType(BIT), Default(Some(true)) */
    val visible: Rep[Option[Boolean]] = column[Option[Boolean]]("visible", O.Default(Some(true)))

    /** Index over (commentableId,commentableType) (database name index_comments_on_commentable_id_and_commentable_type) */
    val index1 = index("index_comments_on_commentable_id_and_commentable_type", (commentableId, commentableType))
    /** Index over (commenterId,commenterType) (database name index_comments_on_commenter_id_and_commenter_type) */
    val index2 = index("index_comments_on_commenter_id_and_commenter_type", (commenterId, commenterType))
  }
  /** Collection-like TableQuery object for table Comments */
  lazy val Comments = new TableQuery(tag => new Comments(tag))

  /** Entity class storing rows of table ComponentGroupDefinitions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param productComponentGroupId Database column product_component_group_id SqlType(INT), Default(None)
   *  @param required Database column required SqlType(BIT), Default(false)
   *  @param limitSelections Database column limit_selections SqlType(BIT), Default(false)
   *  @param selectionMax Database column selection_max SqlType(INT), Default(None)
   *  @param chargeAdditional Database column charge_additional SqlType(BIT), Default(false)
   *  @param additionalCharge Database column additional_charge SqlType(INT), Default(None)
   *  @param numSelectionToCharge Database column num_selection_to_charge SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ComponentGroupDefinitionsRow(id: Int, productComponentGroupId: Option[Int] = None, required: Boolean = false, limitSelections: Boolean = false, selectionMax: Option[Int] = None, chargeAdditional: Boolean = false, additionalCharge: Option[Int] = None, numSelectionToCharge: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ComponentGroupDefinitionsRow objects using plain SQL queries */
  implicit def GetResultComponentGroupDefinitionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Boolean], e3: GR[Option[java.sql.Timestamp]]): GR[ComponentGroupDefinitionsRow] = GR{
    prs => import prs._
    ComponentGroupDefinitionsRow.tupled((<<[Int], <<?[Int], <<[Boolean], <<[Boolean], <<?[Int], <<[Boolean], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table component_group_definitions. Objects of this class serve as prototypes for rows in queries. */
  class ComponentGroupDefinitions(_tableTag: Tag) extends Table[ComponentGroupDefinitionsRow](_tableTag, "component_group_definitions") {
    def * = (id, productComponentGroupId, required, limitSelections, selectionMax, chargeAdditional, additionalCharge, numSelectionToCharge, createdAt, updatedAt) <> (ComponentGroupDefinitionsRow.tupled, ComponentGroupDefinitionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), productComponentGroupId, Rep.Some(required), Rep.Some(limitSelections), selectionMax, Rep.Some(chargeAdditional), additionalCharge, numSelectionToCharge, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ComponentGroupDefinitionsRow.tupled((_1.get, _2, _3.get, _4.get, _5, _6.get, _7, _8, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column product_component_group_id SqlType(INT), Default(None) */
    val productComponentGroupId: Rep[Option[Int]] = column[Option[Int]]("product_component_group_id", O.Default(None))
    /** Database column required SqlType(BIT), Default(false) */
    val required: Rep[Boolean] = column[Boolean]("required", O.Default(false))
    /** Database column limit_selections SqlType(BIT), Default(false) */
    val limitSelections: Rep[Boolean] = column[Boolean]("limit_selections", O.Default(false))
    /** Database column selection_max SqlType(INT), Default(None) */
    val selectionMax: Rep[Option[Int]] = column[Option[Int]]("selection_max", O.Default(None))
    /** Database column charge_additional SqlType(BIT), Default(false) */
    val chargeAdditional: Rep[Boolean] = column[Boolean]("charge_additional", O.Default(false))
    /** Database column additional_charge SqlType(INT), Default(None) */
    val additionalCharge: Rep[Option[Int]] = column[Option[Int]]("additional_charge", O.Default(None))
    /** Database column num_selection_to_charge SqlType(INT), Default(None) */
    val numSelectionToCharge: Rep[Option[Int]] = column[Option[Int]]("num_selection_to_charge", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (productComponentGroupId) (database name index_component_group_definitions_on_product_component_group_id) */
    val index1 = index("index_component_group_definitions_on_product_component_group_id", productComponentGroupId)
  }
  /** Collection-like TableQuery object for table ComponentGroupDefinitions */
  lazy val ComponentGroupDefinitions = new TableQuery(tag => new ComponentGroupDefinitions(tag))

  /** Entity class storing rows of table Conditions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param ruleId Database column rule_id SqlType(INT), Default(None)
   *  @param expression Database column expression SqlType(TEXT), Default(None)
   *  @param authoringMode Database column authoring_mode SqlType(INT), Default(Some(0))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param ruleType Database column rule_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param filterProperties Database column filter_properties SqlType(TEXT), Default(None) */
  case class ConditionsRow(id: Int, ruleId: Option[Int] = None, expression: Option[String] = None, authoringMode: Option[Int] = Some(0), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, ruleType: Option[String] = None, `type`: String, properties: Option[String] = None, rowOrder: Option[Int] = None, filterProperties: Option[String] = None)
  /** GetResult implicit for fetching ConditionsRow objects using plain SQL queries */
  implicit def GetResultConditionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String]): GR[ConditionsRow] = GR{
    prs => import prs._
    ConditionsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<[String], <<?[String], <<?[Int], <<?[String]))
  }
  /** Table description of table conditions. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Conditions(_tableTag: Tag) extends Table[ConditionsRow](_tableTag, "conditions") {
    def * = (id, ruleId, expression, authoringMode, createdAt, updatedAt, ruleType, `type`, properties, rowOrder, filterProperties) <> (ConditionsRow.tupled, ConditionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), ruleId, expression, authoringMode, createdAt, updatedAt, ruleType, Rep.Some(`type`), properties, rowOrder, filterProperties).shaped.<>({r=>import r._; _1.map(_=> ConditionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8.get, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column rule_id SqlType(INT), Default(None) */
    val ruleId: Rep[Option[Int]] = column[Option[Int]]("rule_id", O.Default(None))
    /** Database column expression SqlType(TEXT), Default(None) */
    val expression: Rep[Option[String]] = column[Option[String]]("expression", O.Default(None))
    /** Database column authoring_mode SqlType(INT), Default(Some(0)) */
    val authoringMode: Rep[Option[Int]] = column[Option[Int]]("authoring_mode", O.Default(Some(0)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column rule_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ruleType: Rep[Option[String]] = column[Option[String]]("rule_type", O.Length(255,varying=true), O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[String] = column[String]("type", O.Length(255,varying=true))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column filter_properties SqlType(TEXT), Default(None) */
    val filterProperties: Rep[Option[String]] = column[Option[String]]("filter_properties", O.Default(None))
  }
  /** Collection-like TableQuery object for table Conditions */
  lazy val Conditions = new TableQuery(tag => new Conditions(tag))

  /** Entity class storing rows of table ContentBlocks
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param templateSetVersionId Database column template_set_version_id SqlType(INT), Default(Some(0))
   *  @param showToPublic Database column show_to_public SqlType(BIT), Default(Some(false)) */
  case class ContentBlocksRow(id: Int, description: Option[String] = None, name: String, label: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, status: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, templateSetVersionId: Option[Int] = Some(0), showToPublic: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching ContentBlocksRow objects using plain SQL queries */
  implicit def GetResultContentBlocksRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[String], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Int]], e5: GR[Option[Boolean]]): GR[ContentBlocksRow] = GR{
    prs => import prs._
    ContentBlocksRow.tupled((<<[Int], <<?[String], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[Boolean], <<?[String], <<?[Int], <<?[Boolean]))
  }
  /** Table description of table content_blocks. Objects of this class serve as prototypes for rows in queries. */
  class ContentBlocks(_tableTag: Tag) extends Table[ContentBlocksRow](_tableTag, "content_blocks") {
    def * = (id, description, name, label, createdAt, updatedAt, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, status, effectivityStart, effectivityEnd, effectivityTimezone, publishedAt, recurring, recurringSchedule, templateSetVersionId, showToPublic) <> (ContentBlocksRow.tupled, ContentBlocksRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), description, Rep.Some(name), Rep.Some(label), createdAt, updatedAt, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, status, effectivityStart, effectivityEnd, effectivityTimezone, publishedAt, recurring, recurringSchedule, templateSetVersionId, showToPublic).shaped.<>({r=>import r._; _1.map(_=> ContentBlocksRow.tupled((_1.get, _2, _3.get, _4.get, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(VARCHAR), Length(255,true), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Length(255,varying=true), O.Default(None))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))

    /** Index over (templateSetVersionId) (database name index_content_blocks_on_template_set_version_id) */
    val index1 = index("index_content_blocks_on_template_set_version_id", templateSetVersionId)
  }
  /** Collection-like TableQuery object for table ContentBlocks */
  lazy val ContentBlocks = new TableQuery(tag => new ContentBlocks(tag))

  /** Entity class storing rows of table ContentPages
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param pageType Database column page_type SqlType(VARCHAR), Length(255,true)
   *  @param templateSetVersionId Database column template_set_version_id SqlType(INT), Default(0)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param fileFileName Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileContentType Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileSize Database column file_file_size SqlType(INT), Default(None)
   *  @param fileUpdatedAt Database column file_updated_at SqlType(DATETIME), Default(None)
   *  @param pageUrl Database column page_url SqlType(VARCHAR), Length(400,true), Default(None)
   *  @param pageLocation Database column page_location SqlType(VARCHAR), Length(255,true), Default(Some(stellar_page))
   *  @param requireLogin Database column require_login SqlType(BIT), Default(Some(true)) */
  case class ContentPagesRow(id: Int, name: String, label: String, description: Option[String] = None, pageType: String, templateSetVersionId: Int = 0, status: String = "draft", publishedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, fileFileName: Option[String] = None, fileContentType: Option[String] = None, fileFileSize: Option[Int] = None, fileUpdatedAt: Option[java.sql.Timestamp] = None, pageUrl: Option[String] = None, pageLocation: Option[String] = Some("stellar_page"), requireLogin: Option[Boolean] = Some(true))
  /** GetResult implicit for fetching ContentPagesRow objects using plain SQL queries */
  implicit def GetResultContentPagesRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Int]], e5: GR[Option[Boolean]]): GR[ContentPagesRow] = GR{
    prs => import prs._
    ContentPagesRow.tupled((<<[Int], <<[String], <<[String], <<?[String], <<[String], <<[Int], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Boolean]))
  }
  /** Table description of table content_pages. Objects of this class serve as prototypes for rows in queries. */
  class ContentPages(_tableTag: Tag) extends Table[ContentPagesRow](_tableTag, "content_pages") {
    def * = (id, name, label, description, pageType, templateSetVersionId, status, publishedAt, createdAt, updatedAt, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, pageUrl, pageLocation, requireLogin) <> (ContentPagesRow.tupled, ContentPagesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), description, Rep.Some(pageType), Rep.Some(templateSetVersionId), Rep.Some(status), publishedAt, createdAt, updatedAt, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, pageUrl, pageLocation, requireLogin).shaped.<>({r=>import r._; _1.map(_=> ContentPagesRow.tupled((_1.get, _2.get, _3.get, _4, _5.get, _6.get, _7.get, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column page_type SqlType(VARCHAR), Length(255,true) */
    val pageType: Rep[String] = column[String]("page_type", O.Length(255,varying=true))
    /** Database column template_set_version_id SqlType(INT), Default(0) */
    val templateSetVersionId: Rep[Int] = column[Int]("template_set_version_id", O.Default(0))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileFileName: Rep[Option[String]] = column[Option[String]]("file_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileContentType: Rep[Option[String]] = column[Option[String]]("file_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_size SqlType(INT), Default(None) */
    val fileFileSize: Rep[Option[Int]] = column[Option[Int]]("file_file_size", O.Default(None))
    /** Database column file_updated_at SqlType(DATETIME), Default(None) */
    val fileUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("file_updated_at", O.Default(None))
    /** Database column page_url SqlType(VARCHAR), Length(400,true), Default(None) */
    val pageUrl: Rep[Option[String]] = column[Option[String]]("page_url", O.Length(400,varying=true), O.Default(None))
    /** Database column page_location SqlType(VARCHAR), Length(255,true), Default(Some(stellar_page)) */
    val pageLocation: Rep[Option[String]] = column[Option[String]]("page_location", O.Length(255,varying=true), O.Default(Some("stellar_page")))
    /** Database column require_login SqlType(BIT), Default(Some(true)) */
    val requireLogin: Rep[Option[Boolean]] = column[Option[Boolean]]("require_login", O.Default(Some(true)))

    /** Index over (label) (database name index_content_pages_on_label) */
    val index1 = index("index_content_pages_on_label", label)
    /** Index over (name) (database name index_content_pages_on_name) */
    val index2 = index("index_content_pages_on_name", name)
    /** Index over (templateSetVersionId) (database name index_content_pages_on_template_set_version_id) */
    val index3 = index("index_content_pages_on_template_set_version_id", templateSetVersionId)
  }
  /** Collection-like TableQuery object for table ContentPages */
  lazy val ContentPages = new TableQuery(tag => new ContentPages(tag))

  /** Entity class storing rows of table Contents
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param designableId Database column designable_id SqlType(INT), Default(None)
   *  @param designableType Database column designable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param layoutId Database column layout_id SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param templateId Database column template_id SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param paletteId Database column palette_id SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param content Database column content SqlType(MEDIUMTEXT), Length(16777215,true), Default(None)
   *  @param html Database column html SqlType(MEDIUMTEXT), Length(16777215,true), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ContentsRow(id: Int, designableId: Option[Int] = None, designableType: Option[String] = None, layoutId: Option[String] = None, templateId: Option[String] = None, paletteId: Option[String] = None, content: Option[String] = None, html: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ContentsRow objects using plain SQL queries */
  implicit def GetResultContentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ContentsRow] = GR{
    prs => import prs._
    ContentsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table contents. Objects of this class serve as prototypes for rows in queries. */
  class Contents(_tableTag: Tag) extends Table[ContentsRow](_tableTag, "contents") {
    def * = (id, designableId, designableType, layoutId, templateId, paletteId, content, html, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt) <> (ContentsRow.tupled, ContentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), designableId, designableType, layoutId, templateId, paletteId, content, html, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ContentsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column designable_id SqlType(INT), Default(None) */
    val designableId: Rep[Option[Int]] = column[Option[Int]]("designable_id", O.Default(None))
    /** Database column designable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val designableType: Rep[Option[String]] = column[Option[String]]("designable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column layout_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val layoutId: Rep[Option[String]] = column[Option[String]]("layout_id", O.Length(50,varying=true), O.Default(None))
    /** Database column template_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val templateId: Rep[Option[String]] = column[Option[String]]("template_id", O.Length(50,varying=true), O.Default(None))
    /** Database column palette_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val paletteId: Rep[Option[String]] = column[Option[String]]("palette_id", O.Length(50,varying=true), O.Default(None))
    /** Database column content SqlType(MEDIUMTEXT), Length(16777215,true), Default(None) */
    val content: Rep[Option[String]] = column[Option[String]]("content", O.Length(16777215,varying=true), O.Default(None))
    /** Database column html SqlType(MEDIUMTEXT), Length(16777215,true), Default(None) */
    val html: Rep[Option[String]] = column[Option[String]]("html", O.Length(16777215,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (designableId,designableType) (database name index_contents_on_designable_id_and_designable_type) */
    val index1 = index("index_contents_on_designable_id_and_designable_type", (designableId, designableType))
  }
  /** Collection-like TableQuery object for table Contents */
  lazy val Contents = new TableQuery(tag => new Contents(tag))

  /** Entity class storing rows of table ContentSettings
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param value Database column value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param recordType Database column record_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param recordId Database column record_id SqlType(INT), Default(None) */
  case class ContentSettingsRow(id: Int, name: Option[String] = None, value: Option[String] = None, recordType: Option[String] = None, recordId: Option[Int] = None)
  /** GetResult implicit for fetching ContentSettingsRow objects using plain SQL queries */
  implicit def GetResultContentSettingsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]]): GR[ContentSettingsRow] = GR{
    prs => import prs._
    ContentSettingsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[Int]))
  }
  /** Table description of table content_settings. Objects of this class serve as prototypes for rows in queries. */
  class ContentSettings(_tableTag: Tag) extends Table[ContentSettingsRow](_tableTag, "content_settings") {
    def * = (id, name, value, recordType, recordId) <> (ContentSettingsRow.tupled, ContentSettingsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, value, recordType, recordId).shaped.<>({r=>import r._; _1.map(_=> ContentSettingsRow.tupled((_1.get, _2, _3, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column value SqlType(VARCHAR), Length(255,true), Default(None) */
    val value: Rep[Option[String]] = column[Option[String]]("value", O.Length(255,varying=true), O.Default(None))
    /** Database column record_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val recordType: Rep[Option[String]] = column[Option[String]]("record_type", O.Length(255,varying=true), O.Default(None))
    /** Database column record_id SqlType(INT), Default(None) */
    val recordId: Rep[Option[Int]] = column[Option[Int]]("record_id", O.Default(None))
  }
  /** Collection-like TableQuery object for table ContentSettings */
  lazy val ContentSettings = new TableQuery(tag => new ContentSettings(tag))

  /** Entity class storing rows of table ContentTokens
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param variable Database column variable SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param default Database column default SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param dataFormat Database column data_format SqlType(TEXT), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(Some(published))
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param `type` Database column type SqlType(TEXT), Default(None)
   *  @param system Database column system SqlType(BIT), Default(false)
   *  @param applyTo Database column apply_to SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param apiVisible Database column api_visible SqlType(BIT), Default(true)
   *  @param syncToEsp Database column sync_to_esp SqlType(BIT), Default(Some(false)) */
  case class ContentTokensRow(id: Int, description: Option[String] = None, variable: Option[String] = None, default: Option[String] = None, dataFormat: Option[String] = None, definition: Option[String] = None, status: Option[String] = Some("published"), publishedAt: Option[java.sql.Timestamp] = None, name: String, label: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, `type`: Option[String] = None, system: Boolean = false, applyTo: Option[String] = None, apiVisible: Boolean = true, syncToEsp: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching ContentTokensRow objects using plain SQL queries */
  implicit def GetResultContentTokensRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[String], e4: GR[Boolean], e5: GR[Option[Boolean]]): GR[ContentTokensRow] = GR{
    prs => import prs._
    ContentTokensRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<[Boolean], <<?[String], <<[Boolean], <<?[Boolean]))
  }
  /** Table description of table content_tokens. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class ContentTokens(_tableTag: Tag) extends Table[ContentTokensRow](_tableTag, "content_tokens") {
    def * = (id, description, variable, default, dataFormat, definition, status, publishedAt, name, label, createdAt, updatedAt, `type`, system, applyTo, apiVisible, syncToEsp) <> (ContentTokensRow.tupled, ContentTokensRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), description, variable, default, dataFormat, definition, status, publishedAt, Rep.Some(name), Rep.Some(label), createdAt, updatedAt, `type`, Rep.Some(system), applyTo, Rep.Some(apiVisible), syncToEsp).shaped.<>({r=>import r._; _1.map(_=> ContentTokensRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9.get, _10.get, _11, _12, _13, _14.get, _15, _16.get, _17)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column variable SqlType(VARCHAR), Length(100,true), Default(None) */
    val variable: Rep[Option[String]] = column[Option[String]]("variable", O.Length(100,varying=true), O.Default(None))
    /** Database column default SqlType(VARCHAR), Length(255,true), Default(None) */
    val default: Rep[Option[String]] = column[Option[String]]("default", O.Length(255,varying=true), O.Default(None))
    /** Database column data_format SqlType(TEXT), Default(None) */
    val dataFormat: Rep[Option[String]] = column[Option[String]]("data_format", O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(Some(published)) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(Some("published")))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column type SqlType(TEXT), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Default(None))
    /** Database column system SqlType(BIT), Default(false) */
    val system: Rep[Boolean] = column[Boolean]("system", O.Default(false))
    /** Database column apply_to SqlType(VARCHAR), Length(255,true), Default(None) */
    val applyTo: Rep[Option[String]] = column[Option[String]]("apply_to", O.Length(255,varying=true), O.Default(None))
    /** Database column api_visible SqlType(BIT), Default(true) */
    val apiVisible: Rep[Boolean] = column[Boolean]("api_visible", O.Default(true))
    /** Database column sync_to_esp SqlType(BIT), Default(Some(false)) */
    val syncToEsp: Rep[Option[Boolean]] = column[Option[Boolean]]("sync_to_esp", O.Default(Some(false)))
  }
  /** Collection-like TableQuery object for table ContentTokens */
  lazy val ContentTokens = new TableQuery(tag => new ContentTokens(tag))

  /** Entity class storing rows of table ContestActions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param contestId Database column contest_id SqlType(INT), Default(None)
   *  @param viewedAt Database column viewed_at SqlType(DATETIME), Default(None)
   *  @param respondedAt Database column responded_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ContestActionsRow(id: Int, memberId: Option[Int] = None, contestId: Option[Int] = None, viewedAt: Option[java.sql.Timestamp] = None, respondedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ContestActionsRow objects using plain SQL queries */
  implicit def GetResultContestActionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[ContestActionsRow] = GR{
    prs => import prs._
    ContestActionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table contest_actions. Objects of this class serve as prototypes for rows in queries. */
  class ContestActions(_tableTag: Tag) extends Table[ContestActionsRow](_tableTag, "contest_actions") {
    def * = (id, memberId, contestId, viewedAt, respondedAt, createdAt, updatedAt) <> (ContestActionsRow.tupled, ContestActionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, contestId, viewedAt, respondedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ContestActionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column contest_id SqlType(INT), Default(None) */
    val contestId: Rep[Option[Int]] = column[Option[Int]]("contest_id", O.Default(None))
    /** Database column viewed_at SqlType(DATETIME), Default(None) */
    val viewedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("viewed_at", O.Default(None))
    /** Database column responded_at SqlType(DATETIME), Default(None) */
    val respondedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("responded_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ContestActions */
  lazy val ContestActions = new TableQuery(tag => new ContestActions(tag))

  /** Entity class storing rows of table ContestLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param contestId Database column contest_id SqlType(INT)
   *  @param locationId Database column location_id SqlType(INT)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(255,true)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ContestLocationsRow(id: Int, contestId: Int, locationId: Int, locationType: String, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ContestLocationsRow objects using plain SQL queries */
  implicit def GetResultContestLocationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Boolean], e3: GR[Option[java.sql.Timestamp]]): GR[ContestLocationsRow] = GR{
    prs => import prs._
    ContestLocationsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table contest_locations. Objects of this class serve as prototypes for rows in queries. */
  class ContestLocations(_tableTag: Tag) extends Table[ContestLocationsRow](_tableTag, "contest_locations") {
    def * = (id, contestId, locationId, locationType, included, createdAt, updatedAt) <> (ContestLocationsRow.tupled, ContestLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(contestId), Rep.Some(locationId), Rep.Some(locationType), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ContestLocationsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column contest_id SqlType(INT) */
    val contestId: Rep[Int] = column[Int]("contest_id")
    /** Database column location_id SqlType(INT) */
    val locationId: Rep[Int] = column[Int]("location_id")
    /** Database column location_type SqlType(VARCHAR), Length(255,true) */
    val locationType: Rep[String] = column[String]("location_type", O.Length(255,varying=true))
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ContestLocations */
  lazy val ContestLocations = new TableQuery(tag => new ContestLocations(tag))

  /** Entity class storing rows of table ContestPrizes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param contestId Database column contest_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param awardType Database column award_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param awardAwardableId Database column award_awardable_id SqlType(INT), Default(None)
   *  @param awardMetricAmount Database column award_metric_amount SqlType(DECIMAL), Default(None)
   *  @param awardMetricName Database column award_metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param awardFrequency Database column award_frequency SqlType(INT), Default(None)
   *  @param awardProbability Database column award_probability SqlType(DECIMAL), Default(None)
   *  @param numberOfWinners Database column number_of_winners SqlType(INT), Default(Some(0)) */
  case class ContestPrizesRow(id: Int, contestId: Option[Int] = None, label: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, awardType: Option[String] = None, awardAwardableId: Option[Int] = None, awardMetricAmount: Option[scala.math.BigDecimal] = None, awardMetricName: Option[String] = None, awardFrequency: Option[Int] = None, awardProbability: Option[scala.math.BigDecimal] = None, numberOfWinners: Option[Int] = Some(0))
  /** GetResult implicit for fetching ContestPrizesRow objects using plain SQL queries */
  implicit def GetResultContestPrizesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[scala.math.BigDecimal]]): GR[ContestPrizesRow] = GR{
    prs => import prs._
    ContestPrizesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[scala.math.BigDecimal], <<?[String], <<?[Int], <<?[scala.math.BigDecimal], <<?[Int]))
  }
  /** Table description of table contest_prizes. Objects of this class serve as prototypes for rows in queries. */
  class ContestPrizes(_tableTag: Tag) extends Table[ContestPrizesRow](_tableTag, "contest_prizes") {
    def * = (id, contestId, label, description, createdAt, updatedAt, awardType, awardAwardableId, awardMetricAmount, awardMetricName, awardFrequency, awardProbability, numberOfWinners) <> (ContestPrizesRow.tupled, ContestPrizesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), contestId, label, description, createdAt, updatedAt, awardType, awardAwardableId, awardMetricAmount, awardMetricName, awardFrequency, awardProbability, numberOfWinners).shaped.<>({r=>import r._; _1.map(_=> ContestPrizesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column contest_id SqlType(INT), Default(None) */
    val contestId: Rep[Option[Int]] = column[Option[Int]]("contest_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column award_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val awardType: Rep[Option[String]] = column[Option[String]]("award_type", O.Length(50,varying=true), O.Default(None))
    /** Database column award_awardable_id SqlType(INT), Default(None) */
    val awardAwardableId: Rep[Option[Int]] = column[Option[Int]]("award_awardable_id", O.Default(None))
    /** Database column award_metric_amount SqlType(DECIMAL), Default(None) */
    val awardMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("award_metric_amount", O.Default(None))
    /** Database column award_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val awardMetricName: Rep[Option[String]] = column[Option[String]]("award_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column award_frequency SqlType(INT), Default(None) */
    val awardFrequency: Rep[Option[Int]] = column[Option[Int]]("award_frequency", O.Default(None))
    /** Database column award_probability SqlType(DECIMAL), Default(None) */
    val awardProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("award_probability", O.Default(None))
    /** Database column number_of_winners SqlType(INT), Default(Some(0)) */
    val numberOfWinners: Rep[Option[Int]] = column[Option[Int]]("number_of_winners", O.Default(Some(0)))
  }
  /** Collection-like TableQuery object for table ContestPrizes */
  lazy val ContestPrizes = new TableQuery(tag => new ContestPrizes(tag))

  /** Entity class storing rows of table ContestResponsePrizes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param contestPrizeId Database column contest_prize_id SqlType(INT), Default(None)
   *  @param contestResponseId Database column contest_response_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ContestResponsePrizesRow(id: Int, contestPrizeId: Option[Int] = None, contestResponseId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ContestResponsePrizesRow objects using plain SQL queries */
  implicit def GetResultContestResponsePrizesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[ContestResponsePrizesRow] = GR{
    prs => import prs._
    ContestResponsePrizesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table contest_response_prizes. Objects of this class serve as prototypes for rows in queries. */
  class ContestResponsePrizes(_tableTag: Tag) extends Table[ContestResponsePrizesRow](_tableTag, "contest_response_prizes") {
    def * = (id, contestPrizeId, contestResponseId, createdAt, updatedAt) <> (ContestResponsePrizesRow.tupled, ContestResponsePrizesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), contestPrizeId, contestResponseId, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ContestResponsePrizesRow.tupled((_1.get, _2, _3, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column contest_prize_id SqlType(INT), Default(None) */
    val contestPrizeId: Rep[Option[Int]] = column[Option[Int]]("contest_prize_id", O.Default(None))
    /** Database column contest_response_id SqlType(INT), Default(None) */
    val contestResponseId: Rep[Option[Int]] = column[Option[Int]]("contest_response_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ContestResponsePrizes */
  lazy val ContestResponsePrizes = new TableQuery(tag => new ContestResponsePrizes(tag))

  /** Entity class storing rows of table ContestResponses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param contestId Database column contest_id SqlType(INT), Default(None)
   *  @param entryStatus Database column entry_status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param prizeStatus Database column prize_status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true)
   *  @param properties Database column properties SqlType(TEXT), Default(None) */
  case class ContestResponsesRow(id: Int, memberId: Option[Int] = None, contestId: Option[Int] = None, entryStatus: Option[String] = None, prizeStatus: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, `type`: String, properties: Option[String] = None)
  /** GetResult implicit for fetching ContestResponsesRow objects using plain SQL queries */
  implicit def GetResultContestResponsesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String]): GR[ContestResponsesRow] = GR{
    prs => import prs._
    ContestResponsesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[String], <<?[String]))
  }
  /** Table description of table contest_responses. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class ContestResponses(_tableTag: Tag) extends Table[ContestResponsesRow](_tableTag, "contest_responses") {
    def * = (id, memberId, contestId, entryStatus, prizeStatus, createdAt, updatedAt, `type`, properties) <> (ContestResponsesRow.tupled, ContestResponsesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, contestId, entryStatus, prizeStatus, createdAt, updatedAt, Rep.Some(`type`), properties).shaped.<>({r=>import r._; _1.map(_=> ContestResponsesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8.get, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column contest_id SqlType(INT), Default(None) */
    val contestId: Rep[Option[Int]] = column[Option[Int]]("contest_id", O.Default(None))
    /** Database column entry_status SqlType(VARCHAR), Length(255,true), Default(None) */
    val entryStatus: Rep[Option[String]] = column[Option[String]]("entry_status", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_status SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeStatus: Rep[Option[String]] = column[Option[String]]("prize_status", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[String] = column[String]("type", O.Length(255,varying=true))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))

    /** Index over (contestId) (database name index_contest_responses_on_contest_id) */
    val index1 = index("index_contest_responses_on_contest_id", contestId)
    /** Index over (memberId) (database name index_contest_responses_on_member_id) */
    val index2 = index("index_contest_responses_on_member_id", memberId)
  }
  /** Collection-like TableQuery object for table ContestResponses */
  lazy val ContestResponses = new TableQuery(tag => new ContestResponses(tag))

  /** Row type of table Contests */
  type ContestsRow = HCons[Int,HCons[Option[Int],HCons[String,HCons[String,HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[Boolean],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Boolean],HCons[String,HCons[Option[String],HCons[String,HCons[String,HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for ContestsRow providing default values if available in the database schema. */
  def ContestsRow(id: Int, programId: Option[Int] = None, name: String, label: String, description: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, status: String = "draft", publishedAt: Option[java.sql.Timestamp] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, templateSetVersionId: Option[Int] = Some(0), responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, responseTier: Option[String] = None, responseMaxPerMember: Option[Int] = None, responseMaxPerMemberUnit: Option[String] = None, responseInterval: Option[Int] = None, responseIntervalUnit: Option[String] = None, showInGallery: Option[Boolean] = Some(true), showInList: Option[Boolean] = Some(true), allowResponses: Option[Boolean] = Some(true), `type`: String, properties: Option[String] = None, shareOnActivityFeed: String, shareOnGallery: String, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, newsFeedId: Option[Int] = None, shareOnNewsFeed: Option[String] = None, showToPublic: Option[Boolean] = Some(false), awardType: Option[String] = None, awardAwardableId: Option[Int] = None, awardMetricAmount: Option[scala.math.BigDecimal] = None, awardMetricName: Option[String] = None, awardFrequency: Option[Int] = None, awardProbability: Option[scala.math.BigDecimal] = None, targetableId: Option[Int] = None, targetableType: Option[String] = None, targetUrl: Option[String] = None): ContestsRow = {
    id :: programId :: name :: label :: description :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: status :: publishedAt :: effectivityStart :: effectivityEnd :: recurring :: recurringSchedule :: createdAt :: updatedAt :: templateSetVersionId :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: showInGallery :: showInList :: allowResponses :: `type` :: properties :: shareOnActivityFeed :: shareOnGallery :: metricName :: metricAmount :: newsFeedId :: shareOnNewsFeed :: showToPublic :: awardType :: awardAwardableId :: awardMetricAmount :: awardMetricName :: awardFrequency :: awardProbability :: targetableId :: targetableType :: targetUrl :: HNil
  }
  /** GetResult implicit for fetching ContestsRow objects using plain SQL queries */
  implicit def GetResultContestsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]], e6: GR[Option[scala.math.BigDecimal]]): GR[ContestsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<[String] :: <<[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[Boolean] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Boolean] :: <<[String] :: <<?[String] :: <<[String] :: <<[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[String] :: <<?[String] :: HNil
  }
  /** Table description of table contests. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Contests(_tableTag: Tag) extends Table[ContestsRow](_tableTag, "contests") {
    def * = id :: programId :: name :: label :: description :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: status :: publishedAt :: effectivityStart :: effectivityEnd :: recurring :: recurringSchedule :: createdAt :: updatedAt :: templateSetVersionId :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: showInGallery :: showInList :: allowResponses :: `type` :: properties :: shareOnActivityFeed :: shareOnGallery :: metricName :: metricAmount :: newsFeedId :: shareOnNewsFeed :: showToPublic :: awardType :: awardAwardableId :: awardMetricAmount :: awardMetricName :: awardFrequency :: awardProbability :: targetableId :: targetableType :: targetUrl :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_per_member SqlType(INT), Default(None) */
    val responseMaxPerMember: Rep[Option[Int]] = column[Option[Int]]("response_max_per_member", O.Default(None))
    /** Database column response_max_per_member_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxPerMemberUnit: Rep[Option[String]] = column[Option[String]]("response_max_per_member_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_interval SqlType(INT), Default(None) */
    val responseInterval: Rep[Option[Int]] = column[Option[Int]]("response_interval", O.Default(None))
    /** Database column response_interval_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseIntervalUnit: Rep[Option[String]] = column[Option[String]]("response_interval_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column show_in_gallery SqlType(BIT), Default(Some(true)) */
    val showInGallery: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_gallery", O.Default(Some(true)))
    /** Database column show_in_list SqlType(BIT), Default(Some(true)) */
    val showInList: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_list", O.Default(Some(true)))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column type SqlType(VARCHAR), Length(50,true)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[String] = column[String]("type", O.Length(50,varying=true))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column share_on_activity_feed SqlType(VARCHAR), Length(50,true) */
    val shareOnActivityFeed: Rep[String] = column[String]("share_on_activity_feed", O.Length(50,varying=true))
    /** Database column share_on_gallery SqlType(VARCHAR), Length(50,true) */
    val shareOnGallery: Rep[String] = column[String]("share_on_gallery", O.Length(50,varying=true))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column news_feed_id SqlType(INT), Default(None) */
    val newsFeedId: Rep[Option[Int]] = column[Option[Int]]("news_feed_id", O.Default(None))
    /** Database column share_on_news_feed SqlType(VARCHAR), Length(25,true), Default(None) */
    val shareOnNewsFeed: Rep[Option[String]] = column[Option[String]]("share_on_news_feed", O.Length(25,varying=true), O.Default(None))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))
    /** Database column award_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val awardType: Rep[Option[String]] = column[Option[String]]("award_type", O.Length(50,varying=true), O.Default(None))
    /** Database column award_awardable_id SqlType(INT), Default(None) */
    val awardAwardableId: Rep[Option[Int]] = column[Option[Int]]("award_awardable_id", O.Default(None))
    /** Database column award_metric_amount SqlType(DECIMAL), Default(None) */
    val awardMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("award_metric_amount", O.Default(None))
    /** Database column award_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val awardMetricName: Rep[Option[String]] = column[Option[String]]("award_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column award_frequency SqlType(INT), Default(None) */
    val awardFrequency: Rep[Option[Int]] = column[Option[Int]]("award_frequency", O.Default(None))
    /** Database column award_probability SqlType(DECIMAL), Default(None) */
    val awardProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("award_probability", O.Default(None))
    /** Database column targetable_id SqlType(INT), Default(None) */
    val targetableId: Rep[Option[Int]] = column[Option[Int]]("targetable_id", O.Default(None))
    /** Database column targetable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val targetableType: Rep[Option[String]] = column[Option[String]]("targetable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column target_url SqlType(TEXT), Default(None) */
    val targetUrl: Rep[Option[String]] = column[Option[String]]("target_url", O.Default(None))
  }
  /** Collection-like TableQuery object for table Contests */
  lazy val Contests = new TableQuery(tag => new Contests(tag))

  /** Entity class storing rows of table ContestSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param contestId Database column contest_id SqlType(INT)
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ContestSegmentsRow(id: Int, contestId: Int, segmentId: Int, included: Boolean = true, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ContestSegmentsRow objects using plain SQL queries */
  implicit def GetResultContestSegmentsRow(implicit e0: GR[Int], e1: GR[Boolean], e2: GR[Option[java.sql.Timestamp]]): GR[ContestSegmentsRow] = GR{
    prs => import prs._
    ContestSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table contest_segments. Objects of this class serve as prototypes for rows in queries. */
  class ContestSegments(_tableTag: Tag) extends Table[ContestSegmentsRow](_tableTag, "contest_segments") {
    def * = (id, contestId, segmentId, included, createdAt, updatedAt) <> (ContestSegmentsRow.tupled, ContestSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(contestId), Rep.Some(segmentId), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ContestSegmentsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column contest_id SqlType(INT) */
    val contestId: Rep[Int] = column[Int]("contest_id")
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column included SqlType(BIT), Default(true) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ContestSegments */
  lazy val ContestSegments = new TableQuery(tag => new ContestSegments(tag))

  /** Entity class storing rows of table DashboardKpis
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param dashboardId Database column dashboard_id SqlType(INT), Default(None)
   *  @param heading Database column heading SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param subheading Database column subheading SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param icon Database column icon SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class DashboardKpisRow(id: Int, dashboardId: Option[Int] = None, heading: Option[String] = None, subheading: Option[String] = None, icon: Option[String] = None, rowOrder: Option[Int] = None, properties: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching DashboardKpisRow objects using plain SQL queries */
  implicit def GetResultDashboardKpisRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[DashboardKpisRow] = GR{
    prs => import prs._
    DashboardKpisRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table dashboard_kpis. Objects of this class serve as prototypes for rows in queries. */
  class DashboardKpis(_tableTag: Tag) extends Table[DashboardKpisRow](_tableTag, "dashboard_kpis") {
    def * = (id, dashboardId, heading, subheading, icon, rowOrder, properties, createdAt, updatedAt) <> (DashboardKpisRow.tupled, DashboardKpisRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), dashboardId, heading, subheading, icon, rowOrder, properties, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> DashboardKpisRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column dashboard_id SqlType(INT), Default(None) */
    val dashboardId: Rep[Option[Int]] = column[Option[Int]]("dashboard_id", O.Default(None))
    /** Database column heading SqlType(VARCHAR), Length(50,true), Default(None) */
    val heading: Rep[Option[String]] = column[Option[String]]("heading", O.Length(50,varying=true), O.Default(None))
    /** Database column subheading SqlType(VARCHAR), Length(50,true), Default(None) */
    val subheading: Rep[Option[String]] = column[Option[String]]("subheading", O.Length(50,varying=true), O.Default(None))
    /** Database column icon SqlType(VARCHAR), Length(50,true), Default(None) */
    val icon: Rep[Option[String]] = column[Option[String]]("icon", O.Length(50,varying=true), O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (dashboardId) (database name index_dashboard_kpis_on_dashboard_id) */
    val index1 = index("index_dashboard_kpis_on_dashboard_id", dashboardId)
  }
  /** Collection-like TableQuery object for table DashboardKpis */
  lazy val DashboardKpis = new TableQuery(tag => new DashboardKpis(tag))

  /** Entity class storing rows of table DashboardPanels
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param dashboardId Database column dashboard_id SqlType(INT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param heading Database column heading SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param gridSize Database column grid_size SqlType(VARCHAR), Length(10,true), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param icon Database column icon SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param subheading Database column subheading SqlType(VARCHAR), Length(50,true), Default(None) */
  case class DashboardPanelsRow(id: Int, dashboardId: Option[Int] = None, `type`: Option[String] = None, heading: Option[String] = None, gridSize: Option[String] = None, rowOrder: Option[Int] = None, properties: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, icon: Option[String] = None, subheading: Option[String] = None)
  /** GetResult implicit for fetching DashboardPanelsRow objects using plain SQL queries */
  implicit def GetResultDashboardPanelsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[DashboardPanelsRow] = GR{
    prs => import prs._
    DashboardPanelsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String]))
  }
  /** Table description of table dashboard_panels. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class DashboardPanels(_tableTag: Tag) extends Table[DashboardPanelsRow](_tableTag, "dashboard_panels") {
    def * = (id, dashboardId, `type`, heading, gridSize, rowOrder, properties, createdAt, updatedAt, icon, subheading) <> (DashboardPanelsRow.tupled, DashboardPanelsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), dashboardId, `type`, heading, gridSize, rowOrder, properties, createdAt, updatedAt, icon, subheading).shaped.<>({r=>import r._; _1.map(_=> DashboardPanelsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column dashboard_id SqlType(INT), Default(None) */
    val dashboardId: Rep[Option[Int]] = column[Option[Int]]("dashboard_id", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(50,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(50,varying=true), O.Default(None))
    /** Database column heading SqlType(VARCHAR), Length(50,true), Default(None) */
    val heading: Rep[Option[String]] = column[Option[String]]("heading", O.Length(50,varying=true), O.Default(None))
    /** Database column grid_size SqlType(VARCHAR), Length(10,true), Default(None) */
    val gridSize: Rep[Option[String]] = column[Option[String]]("grid_size", O.Length(10,varying=true), O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column icon SqlType(VARCHAR), Length(50,true), Default(None) */
    val icon: Rep[Option[String]] = column[Option[String]]("icon", O.Length(50,varying=true), O.Default(None))
    /** Database column subheading SqlType(VARCHAR), Length(50,true), Default(None) */
    val subheading: Rep[Option[String]] = column[Option[String]]("subheading", O.Length(50,varying=true), O.Default(None))

    /** Index over (dashboardId) (database name index_dashboard_panels_on_dashboard_id) */
    val index1 = index("index_dashboard_panels_on_dashboard_id", dashboardId)
  }
  /** Collection-like TableQuery object for table DashboardPanels */
  lazy val DashboardPanels = new TableQuery(tag => new DashboardPanels(tag))

  /** Entity class storing rows of table Dashboards
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param icon Database column icon SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param kind Database column kind SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param url Database column url SqlType(TEXT), Default(None)
   *  @param visibleFlag Database column visible_flag SqlType(BIT), Default(Some(true)) */
  case class DashboardsRow(id: Int, name: String, label: String, description: Option[String] = None, icon: Option[String] = None, rowOrder: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, kind: Option[String] = None, url: Option[String] = None, visibleFlag: Option[Boolean] = Some(true))
  /** GetResult implicit for fetching DashboardsRow objects using plain SQL queries */
  implicit def GetResultDashboardsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]]): GR[DashboardsRow] = GR{
    prs => import prs._
    DashboardsRow.tupled((<<[Int], <<[String], <<[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Boolean]))
  }
  /** Table description of table dashboards. Objects of this class serve as prototypes for rows in queries. */
  class Dashboards(_tableTag: Tag) extends Table[DashboardsRow](_tableTag, "dashboards") {
    def * = (id, name, label, description, icon, rowOrder, createdAt, updatedAt, kind, url, visibleFlag) <> (DashboardsRow.tupled, DashboardsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), description, icon, rowOrder, createdAt, updatedAt, kind, url, visibleFlag).shaped.<>({r=>import r._; _1.map(_=> DashboardsRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column icon SqlType(VARCHAR), Length(50,true), Default(None) */
    val icon: Rep[Option[String]] = column[Option[String]]("icon", O.Length(50,varying=true), O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column kind SqlType(VARCHAR), Length(25,true), Default(None) */
    val kind: Rep[Option[String]] = column[Option[String]]("kind", O.Length(25,varying=true), O.Default(None))
    /** Database column url SqlType(TEXT), Default(None) */
    val url: Rep[Option[String]] = column[Option[String]]("url", O.Default(None))
    /** Database column visible_flag SqlType(BIT), Default(Some(true)) */
    val visibleFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("visible_flag", O.Default(Some(true)))
  }
  /** Collection-like TableQuery object for table Dashboards */
  lazy val Dashboards = new TableQuery(tag => new Dashboards(tag))

  /** Entity class storing rows of table Deployments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param effectiveAt Database column effective_at SqlType(DATE), Default(None)
   *  @param note Database column note SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(255,true)
   *  @param jsonDataFileName Database column json_data_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param jsonDataContentType Database column json_data_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param jsonDataFileSize Database column json_data_file_size SqlType(INT), Default(None)
   *  @param jsonDataUpdatedAt Database column json_data_updated_at SqlType(DATETIME), Default(None)
   *  @param restartedAt Database column restarted_at SqlType(DATETIME), Default(None)
   *  @param restartedBy Database column restarted_by SqlType(INT), Default(None) */
  case class DeploymentsRow(id: Int, name: String, programId: Option[Int] = None, effectiveAt: Option[java.sql.Date] = None, note: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, status: String, jsonDataFileName: Option[String] = None, jsonDataContentType: Option[String] = None, jsonDataFileSize: Option[Int] = None, jsonDataUpdatedAt: Option[java.sql.Timestamp] = None, restartedAt: Option[java.sql.Timestamp] = None, restartedBy: Option[Int] = None)
  /** GetResult implicit for fetching DeploymentsRow objects using plain SQL queries */
  implicit def GetResultDeploymentsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[Int]], e3: GR[Option[java.sql.Date]], e4: GR[Option[String]], e5: GR[Option[java.sql.Timestamp]]): GR[DeploymentsRow] = GR{
    prs => import prs._
    DeploymentsRow.tupled((<<[Int], <<[String], <<?[Int], <<?[java.sql.Date], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table deployments. Objects of this class serve as prototypes for rows in queries. */
  class Deployments(_tableTag: Tag) extends Table[DeploymentsRow](_tableTag, "deployments") {
    def * = (id, name, programId, effectiveAt, note, createdAt, updatedAt, status, jsonDataFileName, jsonDataContentType, jsonDataFileSize, jsonDataUpdatedAt, restartedAt, restartedBy) <> (DeploymentsRow.tupled, DeploymentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), programId, effectiveAt, note, createdAt, updatedAt, Rep.Some(status), jsonDataFileName, jsonDataContentType, jsonDataFileSize, jsonDataUpdatedAt, restartedAt, restartedBy).shaped.<>({r=>import r._; _1.map(_=> DeploymentsRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8.get, _9, _10, _11, _12, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column effective_at SqlType(DATE), Default(None) */
    val effectiveAt: Rep[Option[java.sql.Date]] = column[Option[java.sql.Date]]("effective_at", O.Default(None))
    /** Database column note SqlType(TEXT), Default(None) */
    val note: Rep[Option[String]] = column[Option[String]]("note", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true) */
    val status: Rep[String] = column[String]("status", O.Length(255,varying=true))
    /** Database column json_data_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val jsonDataFileName: Rep[Option[String]] = column[Option[String]]("json_data_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column json_data_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val jsonDataContentType: Rep[Option[String]] = column[Option[String]]("json_data_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column json_data_file_size SqlType(INT), Default(None) */
    val jsonDataFileSize: Rep[Option[Int]] = column[Option[Int]]("json_data_file_size", O.Default(None))
    /** Database column json_data_updated_at SqlType(DATETIME), Default(None) */
    val jsonDataUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("json_data_updated_at", O.Default(None))
    /** Database column restarted_at SqlType(DATETIME), Default(None) */
    val restartedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("restarted_at", O.Default(None))
    /** Database column restarted_by SqlType(INT), Default(None) */
    val restartedBy: Rep[Option[Int]] = column[Option[Int]]("restarted_by", O.Default(None))

    /** Index over (programId) (database name index_deployments_on_program_id) */
    val index1 = index("index_deployments_on_program_id", programId)
    /** Uniqueness Index over (programId,name) (database name index_deployments_on_program_id_and_name) */
    val index2 = index("index_deployments_on_program_id_and_name", (programId, name), unique=true)
  }
  /** Collection-like TableQuery object for table Deployments */
  lazy val Deployments = new TableQuery(tag => new Deployments(tag))

  /** Entity class storing rows of table DiscountTransactions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param placeId Database column place_id SqlType(INT), Default(None)
   *  @param responseId Database column response_id SqlType(INT), Default(None)
   *  @param responseType Database column response_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param inputAmount Database column input_amount SqlType(DECIMAL), Default(None)
   *  @param discountAmount Database column discount_amount SqlType(DECIMAL), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param parentIntegrationId Database column parent_integration_id SqlType(VARCHAR), Length(50,true)
   *  @param subtotal Database column subtotal SqlType(DECIMAL), Default(None) */
  case class DiscountTransactionsRow(id: Int, memberId: Option[Int] = None, placeId: Option[Int] = None, responseId: Option[Int] = None, responseType: Option[String] = None, inputAmount: Option[scala.math.BigDecimal] = None, discountAmount: Option[scala.math.BigDecimal] = None, status: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, parentIntegrationId: String, subtotal: Option[scala.math.BigDecimal] = None)
  /** GetResult implicit for fetching DiscountTransactionsRow objects using plain SQL queries */
  implicit def GetResultDiscountTransactionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[String], e5: GR[Option[java.sql.Timestamp]]): GR[DiscountTransactionsRow] = GR{
    prs => import prs._
    DiscountTransactionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[Int], <<?[String], <<?[scala.math.BigDecimal], <<?[scala.math.BigDecimal], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[String], <<?[scala.math.BigDecimal]))
  }
  /** Table description of table discount_transactions. Objects of this class serve as prototypes for rows in queries. */
  class DiscountTransactions(_tableTag: Tag) extends Table[DiscountTransactionsRow](_tableTag, "discount_transactions") {
    def * = (id, memberId, placeId, responseId, responseType, inputAmount, discountAmount, status, createdAt, updatedAt, parentIntegrationId, subtotal) <> (DiscountTransactionsRow.tupled, DiscountTransactionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, placeId, responseId, responseType, inputAmount, discountAmount, Rep.Some(status), createdAt, updatedAt, Rep.Some(parentIntegrationId), subtotal).shaped.<>({r=>import r._; _1.map(_=> DiscountTransactionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8.get, _9, _10, _11.get, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column place_id SqlType(INT), Default(None) */
    val placeId: Rep[Option[Int]] = column[Option[Int]]("place_id", O.Default(None))
    /** Database column response_id SqlType(INT), Default(None) */
    val responseId: Rep[Option[Int]] = column[Option[Int]]("response_id", O.Default(None))
    /** Database column response_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val responseType: Rep[Option[String]] = column[Option[String]]("response_type", O.Length(50,varying=true), O.Default(None))
    /** Database column input_amount SqlType(DECIMAL), Default(None) */
    val inputAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("input_amount", O.Default(None))
    /** Database column discount_amount SqlType(DECIMAL), Default(None) */
    val discountAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_amount", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column parent_integration_id SqlType(VARCHAR), Length(50,true) */
    val parentIntegrationId: Rep[String] = column[String]("parent_integration_id", O.Length(50,varying=true))
    /** Database column subtotal SqlType(DECIMAL), Default(None) */
    val subtotal: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("subtotal", O.Default(None))

    /** Index over (memberId) (database name index_discount_transactions_on_member_id) */
    val index1 = index("index_discount_transactions_on_member_id", memberId)
    /** Index over (memberId,responseType) (database name index_discount_transactions_on_member_id_and_response_type) */
    val index2 = index("index_discount_transactions_on_member_id_and_response_type", (memberId, responseType))
    /** Index over (memberId,status) (database name index_discount_transactions_on_member_id_and_status) */
    val index3 = index("index_discount_transactions_on_member_id_and_status", (memberId, status))
  }
  /** Collection-like TableQuery object for table DiscountTransactions */
  lazy val DiscountTransactions = new TableQuery(tag => new DiscountTransactions(tag))

  /** Entity class storing rows of table Edges
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param ancestorId Database column ancestor_id SqlType(INT), Default(None)
   *  @param ancestorType Database column ancestor_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param descendantId Database column descendant_id SqlType(INT), Default(None)
   *  @param descendantType Database column descendant_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param direct Database column direct SqlType(BIT), Default(None)
   *  @param count Database column count SqlType(INT), Default(None)
   *  @param selected Database column selected SqlType(VARCHAR), Length(10,true), Default(Some(no))
   *  @param extra Database column extra SqlType(VARCHAR), Length(10,true), Default(Some(no))
   *  @param configureAttributeId Database column configure_attribute_id SqlType(INT), Default(None) */
  case class EdgesRow(id: Int, ancestorId: Option[Int] = None, ancestorType: Option[String] = None, descendantId: Option[Int] = None, descendantType: Option[String] = None, direct: Option[Boolean] = None, count: Option[Int] = None, selected: Option[String] = Some("no"), extra: Option[String] = Some("no"), configureAttributeId: Option[Int] = None)
  /** GetResult implicit for fetching EdgesRow objects using plain SQL queries */
  implicit def GetResultEdgesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]]): GR[EdgesRow] = GR{
    prs => import prs._
    EdgesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[Boolean], <<?[Int], <<?[String], <<?[String], <<?[Int]))
  }
  /** Table description of table edges. Objects of this class serve as prototypes for rows in queries. */
  class Edges(_tableTag: Tag) extends Table[EdgesRow](_tableTag, "edges") {
    def * = (id, ancestorId, ancestorType, descendantId, descendantType, direct, count, selected, extra, configureAttributeId) <> (EdgesRow.tupled, EdgesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), ancestorId, ancestorType, descendantId, descendantType, direct, count, selected, extra, configureAttributeId).shaped.<>({r=>import r._; _1.map(_=> EdgesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column ancestor_id SqlType(INT), Default(None) */
    val ancestorId: Rep[Option[Int]] = column[Option[Int]]("ancestor_id", O.Default(None))
    /** Database column ancestor_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ancestorType: Rep[Option[String]] = column[Option[String]]("ancestor_type", O.Length(255,varying=true), O.Default(None))
    /** Database column descendant_id SqlType(INT), Default(None) */
    val descendantId: Rep[Option[Int]] = column[Option[Int]]("descendant_id", O.Default(None))
    /** Database column descendant_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val descendantType: Rep[Option[String]] = column[Option[String]]("descendant_type", O.Length(255,varying=true), O.Default(None))
    /** Database column direct SqlType(BIT), Default(None) */
    val direct: Rep[Option[Boolean]] = column[Option[Boolean]]("direct", O.Default(None))
    /** Database column count SqlType(INT), Default(None) */
    val count: Rep[Option[Int]] = column[Option[Int]]("count", O.Default(None))
    /** Database column selected SqlType(VARCHAR), Length(10,true), Default(Some(no)) */
    val selected: Rep[Option[String]] = column[Option[String]]("selected", O.Length(10,varying=true), O.Default(Some("no")))
    /** Database column extra SqlType(VARCHAR), Length(10,true), Default(Some(no)) */
    val extra: Rep[Option[String]] = column[Option[String]]("extra", O.Length(10,varying=true), O.Default(Some("no")))
    /** Database column configure_attribute_id SqlType(INT), Default(None) */
    val configureAttributeId: Rep[Option[Int]] = column[Option[Int]]("configure_attribute_id", O.Default(None))
  }
  /** Collection-like TableQuery object for table Edges */
  lazy val Edges = new TableQuery(tag => new Edges(tag))

  /** Entity class storing rows of table EntityPlacements
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param placementId Database column placement_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class EntityPlacementsRow(id: Int, entityId: Option[Int] = None, entityType: Option[String] = None, placementId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching EntityPlacementsRow objects using plain SQL queries */
  implicit def GetResultEntityPlacementsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[EntityPlacementsRow] = GR{
    prs => import prs._
    EntityPlacementsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table entity_placements. Objects of this class serve as prototypes for rows in queries. */
  class EntityPlacements(_tableTag: Tag) extends Table[EntityPlacementsRow](_tableTag, "entity_placements") {
    def * = (id, entityId, entityType, placementId, createdAt, updatedAt) <> (EntityPlacementsRow.tupled, EntityPlacementsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), entityId, entityType, placementId, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> EntityPlacementsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column placement_id SqlType(INT), Default(None) */
    val placementId: Rep[Option[Int]] = column[Option[Int]]("placement_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (placementId) (database name index_entity_placements_on_placement_id) */
    val index1 = index("index_entity_placements_on_placement_id", placementId)
  }
  /** Collection-like TableQuery object for table EntityPlacements */
  lazy val EntityPlacements = new TableQuery(tag => new EntityPlacements(tag))

  /** Entity class storing rows of table EventLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param eventId Database column event_id SqlType(INT)
   *  @param locationId Database column location_id SqlType(INT)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(255,true)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class EventLocationsRow(id: Int, eventId: Int, locationId: Int, locationType: String, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching EventLocationsRow objects using plain SQL queries */
  implicit def GetResultEventLocationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Boolean], e3: GR[Option[java.sql.Timestamp]]): GR[EventLocationsRow] = GR{
    prs => import prs._
    EventLocationsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table event_locations. Objects of this class serve as prototypes for rows in queries. */
  class EventLocations(_tableTag: Tag) extends Table[EventLocationsRow](_tableTag, "event_locations") {
    def * = (id, eventId, locationId, locationType, included, createdAt, updatedAt) <> (EventLocationsRow.tupled, EventLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(eventId), Rep.Some(locationId), Rep.Some(locationType), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> EventLocationsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column event_id SqlType(INT) */
    val eventId: Rep[Int] = column[Int]("event_id")
    /** Database column location_id SqlType(INT) */
    val locationId: Rep[Int] = column[Int]("location_id")
    /** Database column location_type SqlType(VARCHAR), Length(255,true) */
    val locationType: Rep[String] = column[String]("location_type", O.Length(255,varying=true))
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (eventId) (database name index_event_locations_on_event_id) */
    val index1 = index("index_event_locations_on_event_id", eventId)
    /** Uniqueness Index over (eventId,locationId) (database name index_event_locations_on_event_id_and_location_id) */
    val index2 = index("index_event_locations_on_event_id_and_location_id", (eventId, locationId), unique=true)
    /** Index over (locationId) (database name index_event_locations_on_location_id) */
    val index3 = index("index_event_locations_on_location_id", locationId)
  }
  /** Collection-like TableQuery object for table EventLocations */
  lazy val EventLocations = new TableQuery(tag => new EventLocations(tag))

  /** Entity class storing rows of table EventMembers
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param eventId Database column event_id SqlType(INT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class EventMembersRow(id: Int, memberId: Option[Int] = None, eventId: Option[Int] = None, `type`: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching EventMembersRow objects using plain SQL queries */
  implicit def GetResultEventMembersRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[EventMembersRow] = GR{
    prs => import prs._
    EventMembersRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table event_members. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class EventMembers(_tableTag: Tag) extends Table[EventMembersRow](_tableTag, "event_members") {
    def * = (id, memberId, eventId, `type`, createdAt, updatedAt) <> (EventMembersRow.tupled, EventMembersRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, eventId, `type`, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> EventMembersRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column event_id SqlType(INT), Default(None) */
    val eventId: Rep[Option[Int]] = column[Option[Int]]("event_id", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(50,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(50,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (eventId) (database name index_event_members_on_event_id) */
    val index1 = index("index_event_members_on_event_id", eventId)
    /** Uniqueness Index over (eventId,memberId) (database name index_event_members_on_event_id_and_member_id) */
    val index2 = index("index_event_members_on_event_id_and_member_id", (eventId, memberId), unique=true)
    /** Index over (memberId) (database name index_event_members_on_member_id) */
    val index3 = index("index_event_members_on_member_id", memberId)
  }
  /** Collection-like TableQuery object for table EventMembers */
  lazy val EventMembers = new TableQuery(tag => new EventMembers(tag))

  /** Entity class storing rows of table EventResponses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param eventId Database column event_id SqlType(INT), Default(None)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param outcome Database column outcome SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param metricAmount Database column metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeMetricName Database column prize_metric_name SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeMetricAmount Database column prize_metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeId Database column prize_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param businessValue Database column business_value SqlType(DECIMAL), Default(0.00) */
  case class EventResponsesRow(id: Int, eventId: Option[Int] = None, memberId: Option[Int] = None, status: Option[String] = None, outcome: Option[String] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"))
  /** GetResult implicit for fetching EventResponsesRow objects using plain SQL queries */
  implicit def GetResultEventResponsesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]], e5: GR[scala.math.BigDecimal]): GR[EventResponsesRow] = GR{
    prs => import prs._
    EventResponsesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[scala.math.BigDecimal]))
  }
  /** Table description of table event_responses. Objects of this class serve as prototypes for rows in queries. */
  class EventResponses(_tableTag: Tag) extends Table[EventResponsesRow](_tableTag, "event_responses") {
    def * = (id, eventId, memberId, status, outcome, metricName, metricAmount, prizeType, prizeMetricName, prizeMetricAmount, prizeId, createdAt, updatedAt, businessValue) <> (EventResponsesRow.tupled, EventResponsesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), eventId, memberId, status, outcome, metricName, metricAmount, prizeType, prizeMetricName, prizeMetricAmount, prizeId, createdAt, updatedAt, Rep.Some(businessValue)).shaped.<>({r=>import r._; _1.map(_=> EventResponsesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column event_id SqlType(INT), Default(None) */
    val eventId: Rep[Option[Int]] = column[Option[Int]]("event_id", O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column outcome SqlType(VARCHAR), Length(50,true), Default(None) */
    val outcome: Rep[Option[String]] = column[Option[String]]("outcome", O.Length(50,varying=true), O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(50,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(50,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))

    /** Index over (eventId) (database name index_event_responses_on_event_id) */
    val index1 = index("index_event_responses_on_event_id", eventId)
    /** Index over (eventId,memberId) (database name index_event_responses_on_event_id_and_member_id) */
    val index2 = index("index_event_responses_on_event_id_and_member_id", (eventId, memberId))
  }
  /** Collection-like TableQuery object for table EventResponses */
  lazy val EventResponses = new TableQuery(tag => new EventResponses(tag))

  /** Row type of table Events */
  type EventsRow = HCons[Int,HCons[String,HCons[String,HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[scala.math.BigDecimal,HCons[scala.math.BigDecimal,HCons[Int,HCons[scala.math.BigDecimal,HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for EventsRow providing default values if available in the database schema. */
  def EventsRow(id: Int, name: String, label: String, description: Option[String] = None, location: Option[String] = None, programId: Option[Int] = None, startAt: Option[java.sql.Timestamp] = None, endAt: Option[java.sql.Timestamp] = None, timezone: Option[String] = None, isrecurring: Option[Boolean] = Some(false), recurringDate: Option[String] = None, responseEndAt: Option[java.sql.Timestamp] = None, responseStartAt: Option[java.sql.Timestamp] = None, publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, metricName: Option[String] = None, allowResponses: Option[Boolean] = Some(true), showToPublic: Option[Boolean] = Some(true), templateSetVersionId: Option[Int] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, prizeId: Option[Int] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[scala.math.BigDecimal] = None, responseTier: Option[String] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), aggregatedBusinessValue: scala.math.BigDecimal = BigDecimal("0.00"), responsesCount: Int = 0, aggregatedMetricAmount: scala.math.BigDecimal = BigDecimal("0.00"), discountType: Option[String] = None, discountValue: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), discountMinSubtotal: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00"))): EventsRow = {
    id :: name :: label :: description :: location :: programId :: startAt :: endAt :: timezone :: isrecurring :: recurringDate :: responseEndAt :: responseStartAt :: publishedAt :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: responseMaxOverall :: responseMaxOverallUnit :: metricAmount :: metricName :: allowResponses :: showToPublic :: templateSetVersionId :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: createdAt :: updatedAt :: prizeId :: prizeType :: prizeMetricName :: prizeMetricAmount :: prizeFrequency :: prizeProbability :: responseTier :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: discountType :: discountValue :: discountMinSubtotal :: HNil
  }
  /** GetResult implicit for fetching EventsRow objects using plain SQL queries */
  implicit def GetResultEventsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]], e6: GR[Option[scala.math.BigDecimal]], e7: GR[scala.math.BigDecimal]): GR[EventsRow] = GR{
    prs => import prs._
    <<[Int] :: <<[String] :: <<[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<[Int] :: <<[scala.math.BigDecimal] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: HNil
  }
  /** Table description of table events. Objects of this class serve as prototypes for rows in queries. */
  class Events(_tableTag: Tag) extends Table[EventsRow](_tableTag, "events") {
    def * = id :: name :: label :: description :: location :: programId :: startAt :: endAt :: timezone :: isrecurring :: recurringDate :: responseEndAt :: responseStartAt :: publishedAt :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: responseMaxOverall :: responseMaxOverallUnit :: metricAmount :: metricName :: allowResponses :: showToPublic :: templateSetVersionId :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: createdAt :: updatedAt :: prizeId :: prizeType :: prizeMetricName :: prizeMetricAmount :: prizeFrequency :: prizeProbability :: responseTier :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: discountType :: discountValue :: discountMinSubtotal :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column location SqlType(TEXT), Default(None) */
    val location: Rep[Option[String]] = column[Option[String]]("location", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column start_at SqlType(DATETIME), Default(None) */
    val startAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("start_at", O.Default(None))
    /** Database column end_at SqlType(DATETIME), Default(None) */
    val endAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("end_at", O.Default(None))
    /** Database column timezone SqlType(VARCHAR), Length(255,true), Default(None) */
    val timezone: Rep[Option[String]] = column[Option[String]]("timezone", O.Length(255,varying=true), O.Default(None))
    /** Database column isrecurring SqlType(BIT), Default(Some(false)) */
    val isrecurring: Rep[Option[Boolean]] = column[Option[Boolean]]("isrecurring", O.Default(Some(false)))
    /** Database column recurring_date SqlType(TEXT), Default(None) */
    val recurringDate: Rep[Option[String]] = column[Option[String]]("recurring_date", O.Default(None))
    /** Database column response_end_at SqlType(DATETIME), Default(None) */
    val responseEndAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("response_end_at", O.Default(None))
    /** Database column response_start_at SqlType(DATETIME), Default(None) */
    val responseStartAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("response_start_at", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(255,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(255,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column show_to_public SqlType(BIT), Default(Some(true)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(true)))
    /** Database column template_set_version_id SqlType(INT), Default(None) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(DECIMAL), Default(None) */
    val prizeProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_probability", O.Default(None))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column aggregated_business_value SqlType(DECIMAL), Default(0.00) */
    val aggregatedBusinessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_business_value", O.Default(BigDecimal("0.00")))
    /** Database column responses_count SqlType(INT), Default(0) */
    val responsesCount: Rep[Int] = column[Int]("responses_count", O.Default(0))
    /** Database column aggregated_metric_amount SqlType(DECIMAL), Default(0.00) */
    val aggregatedMetricAmount: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_metric_amount", O.Default(BigDecimal("0.00")))
    /** Database column discount_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val discountType: Rep[Option[String]] = column[Option[String]]("discount_type", O.Length(25,varying=true), O.Default(None))
    /** Database column discount_value SqlType(DECIMAL), Default(Some(0.00)) */
    val discountValue: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_value", O.Default(Some(BigDecimal("0.00"))))
    /** Database column discount_min_subtotal SqlType(DECIMAL), Default(Some(0.00)) */
    val discountMinSubtotal: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_min_subtotal", O.Default(Some(BigDecimal("0.00"))))

    /** Index over (name) (database name index_events_on_name) */
    val index1 = index("index_events_on_name", name :: HNil)
    /** Index over (startAt) (database name index_events_on_start_at) */
    val index2 = index("index_events_on_start_at", startAt :: HNil)
    /** Index over (templateSetVersionId) (database name index_events_on_template_set_version_id) */
    val index3 = index("index_events_on_template_set_version_id", templateSetVersionId :: HNil)
  }
  /** Collection-like TableQuery object for table Events */
  lazy val Events = new TableQuery(tag => new Events(tag))

  /** Entity class storing rows of table EventSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param eventId Database column event_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(Some(true))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class EventSegmentsRow(id: Int, segmentId: Int, eventId: Int, included: Option[Boolean] = Some(true), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching EventSegmentsRow objects using plain SQL queries */
  implicit def GetResultEventSegmentsRow(implicit e0: GR[Int], e1: GR[Option[Boolean]], e2: GR[Option[java.sql.Timestamp]]): GR[EventSegmentsRow] = GR{
    prs => import prs._
    EventSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table event_segments. Objects of this class serve as prototypes for rows in queries. */
  class EventSegments(_tableTag: Tag) extends Table[EventSegmentsRow](_tableTag, "event_segments") {
    def * = (id, segmentId, eventId, included, createdAt, updatedAt) <> (EventSegmentsRow.tupled, EventSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(segmentId), Rep.Some(eventId), included, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> EventSegmentsRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column event_id SqlType(INT) */
    val eventId: Rep[Int] = column[Int]("event_id")
    /** Database column included SqlType(BIT), Default(Some(true)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(true)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (eventId) (database name index_event_segments_on_event_id) */
    val index1 = index("index_event_segments_on_event_id", eventId)
    /** Uniqueness Index over (eventId,segmentId) (database name index_event_segments_on_event_id_and_segment_id) */
    val index2 = index("index_event_segments_on_event_id_and_segment_id", (eventId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_event_segments_on_segment_id) */
    val index3 = index("index_event_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table EventSegments */
  lazy val EventSegments = new TableQuery(tag => new EventSegments(tag))

  /** Entity class storing rows of table ExportDefinitions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param exportId Database column export_id SqlType(INT), Default(None)
   *  @param property Database column property SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param enabled Database column enabled SqlType(BIT), Default(Some(true))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param columnInclusion Database column column_inclusion SqlType(VARCHAR), Length(50,true), Default(Some(all)) */
  case class ExportDefinitionsRow(id: Int, exportId: Option[Int] = None, property: Option[String] = None, definition: Option[String] = None, `type`: Option[String] = None, enabled: Option[Boolean] = Some(true), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, columnInclusion: Option[String] = Some("all"))
  /** GetResult implicit for fetching ExportDefinitionsRow objects using plain SQL queries */
  implicit def GetResultExportDefinitionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]], e4: GR[Option[java.sql.Timestamp]]): GR[ExportDefinitionsRow] = GR{
    prs => import prs._
    ExportDefinitionsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table export_definitions. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class ExportDefinitions(_tableTag: Tag) extends Table[ExportDefinitionsRow](_tableTag, "export_definitions") {
    def * = (id, exportId, property, definition, `type`, enabled, createdAt, updatedAt, columnInclusion) <> (ExportDefinitionsRow.tupled, ExportDefinitionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), exportId, property, definition, `type`, enabled, createdAt, updatedAt, columnInclusion).shaped.<>({r=>import r._; _1.map(_=> ExportDefinitionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column export_id SqlType(INT), Default(None) */
    val exportId: Rep[Option[Int]] = column[Option[Int]]("export_id", O.Default(None))
    /** Database column property SqlType(VARCHAR), Length(255,true), Default(None) */
    val property: Rep[Option[String]] = column[Option[String]]("property", O.Length(255,varying=true), O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column enabled SqlType(BIT), Default(Some(true)) */
    val enabled: Rep[Option[Boolean]] = column[Option[Boolean]]("enabled", O.Default(Some(true)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column column_inclusion SqlType(VARCHAR), Length(50,true), Default(Some(all)) */
    val columnInclusion: Rep[Option[String]] = column[Option[String]]("column_inclusion", O.Length(50,varying=true), O.Default(Some("all")))

    /** Index over (exportId) (database name index_export_definitions_on_export_id) */
    val index1 = index("index_export_definitions_on_export_id", exportId)
  }
  /** Collection-like TableQuery object for table ExportDefinitions */
  lazy val ExportDefinitions = new TableQuery(tag => new ExportDefinitions(tag))

  /** Entity class storing rows of table ExportJobs
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param exportId Database column export_id SqlType(INT), Default(None)
   *  @param executorId Database column executor_id SqlType(INT), Default(None)
   *  @param executorType Database column executor_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param startedAt Database column started_at SqlType(DATETIME), Default(None)
   *  @param finishedAt Database column finished_at SqlType(DATETIME), Default(None)
   *  @param sqsMessageId Database column sqs_message_id SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param outputFileFileName Database column output_file_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param outputFileContentType Database column output_file_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param outputFileFileSize Database column output_file_file_size SqlType(INT), Default(None)
   *  @param outputFileUpdatedAt Database column output_file_updated_at SqlType(DATETIME), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param logFileName Database column log_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param logContentType Database column log_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param logFileSize Database column log_file_size SqlType(INT), Default(None)
   *  @param logUpdatedAt Database column log_updated_at SqlType(DATETIME), Default(None) */
  case class ExportJobsRow(id: Int, exportId: Option[Int] = None, executorId: Option[Int] = None, executorType: Option[String] = None, status: Option[String] = None, startedAt: Option[java.sql.Timestamp] = None, finishedAt: Option[java.sql.Timestamp] = None, sqsMessageId: Option[String] = None, outputFileFileName: Option[String] = None, outputFileContentType: Option[String] = None, outputFileFileSize: Option[Int] = None, outputFileUpdatedAt: Option[java.sql.Timestamp] = None, definition: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, logFileName: Option[String] = None, logContentType: Option[String] = None, logFileSize: Option[Int] = None, logUpdatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ExportJobsRow objects using plain SQL queries */
  implicit def GetResultExportJobsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ExportJobsRow] = GR{
    prs => import prs._
    ExportJobsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp]))
  }
  /** Table description of table export_jobs. Objects of this class serve as prototypes for rows in queries. */
  class ExportJobs(_tableTag: Tag) extends Table[ExportJobsRow](_tableTag, "export_jobs") {
    def * = (id, exportId, executorId, executorType, status, startedAt, finishedAt, sqsMessageId, outputFileFileName, outputFileContentType, outputFileFileSize, outputFileUpdatedAt, definition, createdAt, updatedAt, logFileName, logContentType, logFileSize, logUpdatedAt) <> (ExportJobsRow.tupled, ExportJobsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), exportId, executorId, executorType, status, startedAt, finishedAt, sqsMessageId, outputFileFileName, outputFileContentType, outputFileFileSize, outputFileUpdatedAt, definition, createdAt, updatedAt, logFileName, logContentType, logFileSize, logUpdatedAt).shaped.<>({r=>import r._; _1.map(_=> ExportJobsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column export_id SqlType(INT), Default(None) */
    val exportId: Rep[Option[Int]] = column[Option[Int]]("export_id", O.Default(None))
    /** Database column executor_id SqlType(INT), Default(None) */
    val executorId: Rep[Option[Int]] = column[Option[Int]]("executor_id", O.Default(None))
    /** Database column executor_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val executorType: Rep[Option[String]] = column[Option[String]]("executor_type", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(100,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(100,varying=true), O.Default(None))
    /** Database column started_at SqlType(DATETIME), Default(None) */
    val startedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("started_at", O.Default(None))
    /** Database column finished_at SqlType(DATETIME), Default(None) */
    val finishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("finished_at", O.Default(None))
    /** Database column sqs_message_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val sqsMessageId: Rep[Option[String]] = column[Option[String]]("sqs_message_id", O.Length(255,varying=true), O.Default(None))
    /** Database column output_file_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val outputFileFileName: Rep[Option[String]] = column[Option[String]]("output_file_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column output_file_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val outputFileContentType: Rep[Option[String]] = column[Option[String]]("output_file_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column output_file_file_size SqlType(INT), Default(None) */
    val outputFileFileSize: Rep[Option[Int]] = column[Option[Int]]("output_file_file_size", O.Default(None))
    /** Database column output_file_updated_at SqlType(DATETIME), Default(None) */
    val outputFileUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("output_file_updated_at", O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column log_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val logFileName: Rep[Option[String]] = column[Option[String]]("log_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column log_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val logContentType: Rep[Option[String]] = column[Option[String]]("log_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column log_file_size SqlType(INT), Default(None) */
    val logFileSize: Rep[Option[Int]] = column[Option[Int]]("log_file_size", O.Default(None))
    /** Database column log_updated_at SqlType(DATETIME), Default(None) */
    val logUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("log_updated_at", O.Default(None))

    /** Index over (exportId) (database name index_export_jobs_on_export_id) */
    val index1 = index("index_export_jobs_on_export_id", exportId)
  }
  /** Collection-like TableQuery object for table ExportJobs */
  lazy val ExportJobs = new TableQuery(tag => new ExportJobs(tag))

  /** Entity class storing rows of table Exports
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param resource Database column resource SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param adminId Database column admin_id SqlType(INT), Default(None)
   *  @param fileFileName Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileContentType Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileSize Database column file_file_size SqlType(INT), Default(None)
   *  @param fileUpdatedAt Database column file_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param ext Database column ext SqlType(VARCHAR), Length(10,true), Default(None)
   *  @param resourceFields Database column resource_fields SqlType(TEXT), Default(None)
   *  @param resourceAttachments Database column resource_attachments SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param columnInclusion Database column column_inclusion SqlType(VARCHAR), Length(50,true), Default(Some(all))
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param background Database column background SqlType(BIT), Default(Some(true))
   *  @param emailRecipients Database column email_recipients SqlType(TEXT), Default(None)
   *  @param lastExecutedAt Database column last_executed_at SqlType(DATETIME), Default(None) */
  case class ExportsRow(id: Int, resource: Option[String] = None, adminId: Option[Int] = None, fileFileName: Option[String] = None, fileContentType: Option[String] = None, fileFileSize: Option[Int] = None, fileUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, ext: Option[String] = None, resourceFields: Option[String] = None, resourceAttachments: Option[String] = None, columnInclusion: Option[String] = Some("all"), name: Option[String] = None, description: Option[String] = None, background: Option[Boolean] = Some(true), emailRecipients: Option[String] = None, lastExecutedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ExportsRow objects using plain SQL queries */
  implicit def GetResultExportsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]]): GR[ExportsRow] = GR{
    prs => import prs._
    ExportsRow.tupled((<<[Int], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Boolean], <<?[String], <<?[java.sql.Timestamp]))
  }
  /** Table description of table exports. Objects of this class serve as prototypes for rows in queries. */
  class Exports(_tableTag: Tag) extends Table[ExportsRow](_tableTag, "exports") {
    def * = (id, resource, adminId, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, createdAt, updatedAt, ext, resourceFields, resourceAttachments, columnInclusion, name, description, background, emailRecipients, lastExecutedAt) <> (ExportsRow.tupled, ExportsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), resource, adminId, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, createdAt, updatedAt, ext, resourceFields, resourceAttachments, columnInclusion, name, description, background, emailRecipients, lastExecutedAt).shaped.<>({r=>import r._; _1.map(_=> ExportsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column resource SqlType(VARCHAR), Length(255,true), Default(None) */
    val resource: Rep[Option[String]] = column[Option[String]]("resource", O.Length(255,varying=true), O.Default(None))
    /** Database column admin_id SqlType(INT), Default(None) */
    val adminId: Rep[Option[Int]] = column[Option[Int]]("admin_id", O.Default(None))
    /** Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileFileName: Rep[Option[String]] = column[Option[String]]("file_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileContentType: Rep[Option[String]] = column[Option[String]]("file_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_size SqlType(INT), Default(None) */
    val fileFileSize: Rep[Option[Int]] = column[Option[Int]]("file_file_size", O.Default(None))
    /** Database column file_updated_at SqlType(DATETIME), Default(None) */
    val fileUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("file_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column ext SqlType(VARCHAR), Length(10,true), Default(None) */
    val ext: Rep[Option[String]] = column[Option[String]]("ext", O.Length(10,varying=true), O.Default(None))
    /** Database column resource_fields SqlType(TEXT), Default(None) */
    val resourceFields: Rep[Option[String]] = column[Option[String]]("resource_fields", O.Default(None))
    /** Database column resource_attachments SqlType(VARCHAR), Length(255,true), Default(None) */
    val resourceAttachments: Rep[Option[String]] = column[Option[String]]("resource_attachments", O.Length(255,varying=true), O.Default(None))
    /** Database column column_inclusion SqlType(VARCHAR), Length(50,true), Default(Some(all)) */
    val columnInclusion: Rep[Option[String]] = column[Option[String]]("column_inclusion", O.Length(50,varying=true), O.Default(Some("all")))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column background SqlType(BIT), Default(Some(true)) */
    val background: Rep[Option[Boolean]] = column[Option[Boolean]]("background", O.Default(Some(true)))
    /** Database column email_recipients SqlType(TEXT), Default(None) */
    val emailRecipients: Rep[Option[String]] = column[Option[String]]("email_recipients", O.Default(None))
    /** Database column last_executed_at SqlType(DATETIME), Default(None) */
    val lastExecutedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("last_executed_at", O.Default(None))

    /** Index over (adminId) (database name index_exports_on_admin_id) */
    val index1 = index("index_exports_on_admin_id", adminId)
  }
  /** Collection-like TableQuery object for table Exports */
  lazy val Exports = new TableQuery(tag => new Exports(tag))

  /** Entity class storing rows of table FailedActivities
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param slMemberId Database column sl_member_id SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param slId Database column sl_id SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param slActivityTs Database column sl_activity_ts SqlType(DATETIME), Default(None)
   *  @param slProcessedTs Database column sl_processed_ts SqlType(DATETIME), Default(None)
   *  @param slReceivedTs Database column sl_received_ts SqlType(DATETIME), Default(None)
   *  @param slQueueMessageId Database column sl_queue_message_id SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param slType Database column sl_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param activity Database column activity SqlType(TEXT), Default(None)
   *  @param callStack Database column call_stack SqlType(TEXT), Default(None)
   *  @param disposition Database column disposition SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param errorMessage Database column error_message SqlType(TEXT), Default(None)
   *  @param resubmittedAt Database column resubmitted_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class FailedActivitiesRow(id: Int, slMemberId: Option[String] = None, slId: Option[String] = None, slActivityTs: Option[java.sql.Timestamp] = None, slProcessedTs: Option[java.sql.Timestamp] = None, slReceivedTs: Option[java.sql.Timestamp] = None, slQueueMessageId: Option[String] = None, slType: Option[String] = None, activity: Option[String] = None, callStack: Option[String] = None, disposition: Option[String] = None, errorMessage: Option[String] = None, resubmittedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching FailedActivitiesRow objects using plain SQL queries */
  implicit def GetResultFailedActivitiesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]]): GR[FailedActivitiesRow] = GR{
    prs => import prs._
    FailedActivitiesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table failed_activities. Objects of this class serve as prototypes for rows in queries. */
  class FailedActivities(_tableTag: Tag) extends Table[FailedActivitiesRow](_tableTag, "failed_activities") {
    def * = (id, slMemberId, slId, slActivityTs, slProcessedTs, slReceivedTs, slQueueMessageId, slType, activity, callStack, disposition, errorMessage, resubmittedAt, createdAt, updatedAt) <> (FailedActivitiesRow.tupled, FailedActivitiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), slMemberId, slId, slActivityTs, slProcessedTs, slReceivedTs, slQueueMessageId, slType, activity, callStack, disposition, errorMessage, resubmittedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> FailedActivitiesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column sl_member_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val slMemberId: Rep[Option[String]] = column[Option[String]]("sl_member_id", O.Length(50,varying=true), O.Default(None))
    /** Database column sl_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val slId: Rep[Option[String]] = column[Option[String]]("sl_id", O.Length(50,varying=true), O.Default(None))
    /** Database column sl_activity_ts SqlType(DATETIME), Default(None) */
    val slActivityTs: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("sl_activity_ts", O.Default(None))
    /** Database column sl_processed_ts SqlType(DATETIME), Default(None) */
    val slProcessedTs: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("sl_processed_ts", O.Default(None))
    /** Database column sl_received_ts SqlType(DATETIME), Default(None) */
    val slReceivedTs: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("sl_received_ts", O.Default(None))
    /** Database column sl_queue_message_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val slQueueMessageId: Rep[Option[String]] = column[Option[String]]("sl_queue_message_id", O.Length(50,varying=true), O.Default(None))
    /** Database column sl_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val slType: Rep[Option[String]] = column[Option[String]]("sl_type", O.Length(50,varying=true), O.Default(None))
    /** Database column activity SqlType(TEXT), Default(None) */
    val activity: Rep[Option[String]] = column[Option[String]]("activity", O.Default(None))
    /** Database column call_stack SqlType(TEXT), Default(None) */
    val callStack: Rep[Option[String]] = column[Option[String]]("call_stack", O.Default(None))
    /** Database column disposition SqlType(VARCHAR), Length(50,true), Default(None) */
    val disposition: Rep[Option[String]] = column[Option[String]]("disposition", O.Length(50,varying=true), O.Default(None))
    /** Database column error_message SqlType(TEXT), Default(None) */
    val errorMessage: Rep[Option[String]] = column[Option[String]]("error_message", O.Default(None))
    /** Database column resubmitted_at SqlType(DATETIME), Default(None) */
    val resubmittedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("resubmitted_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table FailedActivities */
  lazy val FailedActivities = new TableQuery(tag => new FailedActivities(tag))

  /** Entity class storing rows of table Features
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param kind Database column kind SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param visible Database column visible SqlType(BIT), Default(None)
   *  @param activityTypeId Database column activity_type_id SqlType(INT), Default(None)
   *  @param propertyId Database column property_id SqlType(INT), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param addIndexFlag Database column add_index_flag SqlType(BIT), Default(Some(true)) */
  case class FeaturesRow(id: Int, name: Option[String] = None, kind: Option[String] = None, visible: Option[Boolean] = None, activityTypeId: Option[Int] = None, propertyId: Option[Int] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, label: Option[String] = None, addIndexFlag: Option[Boolean] = Some(true))
  /** GetResult implicit for fetching FeaturesRow objects using plain SQL queries */
  implicit def GetResultFeaturesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Boolean]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[FeaturesRow] = GR{
    prs => import prs._
    FeaturesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[Boolean], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Boolean]))
  }
  /** Table description of table features. Objects of this class serve as prototypes for rows in queries. */
  class Features(_tableTag: Tag) extends Table[FeaturesRow](_tableTag, "features") {
    def * = (id, name, kind, visible, activityTypeId, propertyId, description, createdAt, updatedAt, label, addIndexFlag) <> (FeaturesRow.tupled, FeaturesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, kind, visible, activityTypeId, propertyId, description, createdAt, updatedAt, label, addIndexFlag).shaped.<>({r=>import r._; _1.map(_=> FeaturesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column kind SqlType(VARCHAR), Length(255,true), Default(None) */
    val kind: Rep[Option[String]] = column[Option[String]]("kind", O.Length(255,varying=true), O.Default(None))
    /** Database column visible SqlType(BIT), Default(None) */
    val visible: Rep[Option[Boolean]] = column[Option[Boolean]]("visible", O.Default(None))
    /** Database column activity_type_id SqlType(INT), Default(None) */
    val activityTypeId: Rep[Option[Int]] = column[Option[Int]]("activity_type_id", O.Default(None))
    /** Database column property_id SqlType(INT), Default(None) */
    val propertyId: Rep[Option[Int]] = column[Option[Int]]("property_id", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column add_index_flag SqlType(BIT), Default(Some(true)) */
    val addIndexFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("add_index_flag", O.Default(Some(true)))

    /** Index over (activityTypeId) (database name index_features_on_activity_type_id) */
    val index1 = index("index_features_on_activity_type_id", activityTypeId)
    /** Index over (kind) (database name index_features_on_kind) */
    val index2 = index("index_features_on_kind", kind)
    /** Index over (name) (database name index_features_on_name) */
    val index3 = index("index_features_on_name", name)
    /** Index over (propertyId) (database name index_features_on_property_id) */
    val index4 = index("index_features_on_property_id", propertyId)
  }
  /** Collection-like TableQuery object for table Features */
  lazy val Features = new TableQuery(tag => new Features(tag))

  /** Entity class storing rows of table Flaggings
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param flaggerId Database column flagger_id SqlType(INT), Default(None)
   *  @param flaggerType Database column flagger_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param flaggableId Database column flaggable_id SqlType(INT), Default(None)
   *  @param flaggableType Database column flaggable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param key Database column key SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param reason Database column reason SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class FlaggingsRow(id: Int, flaggerId: Option[Int] = None, flaggerType: Option[String] = None, flaggableId: Option[Int] = None, flaggableType: Option[String] = None, key: Option[String] = None, reason: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching FlaggingsRow objects using plain SQL queries */
  implicit def GetResultFlaggingsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[FlaggingsRow] = GR{
    prs => import prs._
    FlaggingsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table flaggings. Objects of this class serve as prototypes for rows in queries. */
  class Flaggings(_tableTag: Tag) extends Table[FlaggingsRow](_tableTag, "flaggings") {
    def * = (id, flaggerId, flaggerType, flaggableId, flaggableType, key, reason, createdAt, updatedAt) <> (FlaggingsRow.tupled, FlaggingsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), flaggerId, flaggerType, flaggableId, flaggableType, key, reason, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> FlaggingsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column flagger_id SqlType(INT), Default(None) */
    val flaggerId: Rep[Option[Int]] = column[Option[Int]]("flagger_id", O.Default(None))
    /** Database column flagger_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val flaggerType: Rep[Option[String]] = column[Option[String]]("flagger_type", O.Length(255,varying=true), O.Default(None))
    /** Database column flaggable_id SqlType(INT), Default(None) */
    val flaggableId: Rep[Option[Int]] = column[Option[Int]]("flaggable_id", O.Default(None))
    /** Database column flaggable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val flaggableType: Rep[Option[String]] = column[Option[String]]("flaggable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column key SqlType(VARCHAR), Length(255,true), Default(None) */
    val key: Rep[Option[String]] = column[Option[String]]("key", O.Length(255,varying=true), O.Default(None))
    /** Database column reason SqlType(TEXT), Default(None) */
    val reason: Rep[Option[String]] = column[Option[String]]("reason", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table Flaggings */
  lazy val Flaggings = new TableQuery(tag => new Flaggings(tag))

  /** Entity class storing rows of table FlightSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param distance Database column distance SqlType(DECIMAL), Default(None)
   *  @param originAirportId Database column origin_airport_id SqlType(INT), Default(None)
   *  @param destinationAirportId Database column destination_airport_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class FlightSegmentsRow(id: Int, name: Option[String] = None, label: Option[String] = None, distance: Option[scala.math.BigDecimal] = None, originAirportId: Option[Int] = None, destinationAirportId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching FlightSegmentsRow objects using plain SQL queries */
  implicit def GetResultFlightSegmentsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[scala.math.BigDecimal]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[FlightSegmentsRow] = GR{
    prs => import prs._
    FlightSegmentsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table flight_segments. Objects of this class serve as prototypes for rows in queries. */
  class FlightSegments(_tableTag: Tag) extends Table[FlightSegmentsRow](_tableTag, "flight_segments") {
    def * = (id, name, label, distance, originAirportId, destinationAirportId, createdAt, updatedAt) <> (FlightSegmentsRow.tupled, FlightSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, label, distance, originAirportId, destinationAirportId, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> FlightSegmentsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column distance SqlType(DECIMAL), Default(None) */
    val distance: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("distance", O.Default(None))
    /** Database column origin_airport_id SqlType(INT), Default(None) */
    val originAirportId: Rep[Option[Int]] = column[Option[Int]]("origin_airport_id", O.Default(None))
    /** Database column destination_airport_id SqlType(INT), Default(None) */
    val destinationAirportId: Rep[Option[Int]] = column[Option[Int]]("destination_airport_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table FlightSegments */
  lazy val FlightSegments = new TableQuery(tag => new FlightSegments(tag))

  /** Entity class storing rows of table GalleryItems
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param sourceId Database column source_id SqlType(INT), Default(None)
   *  @param sourceType Database column source_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileName Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileContentType Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileSize Database column file_file_size SqlType(INT), Default(None)
   *  @param fileUpdatedAt Database column file_updated_at SqlType(DATETIME), Default(None)
   *  @param note Database column note SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(Some(published))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param title Database column title SqlType(VARCHAR), Length(255,true)
   *  @param showToPublic Database column show_to_public SqlType(BIT), Default(Some(false))
   *  @param description Database column description SqlType(TEXT), Default(None) */
  case class GalleryItemsRow(id: Int, sourceId: Option[Int] = None, sourceType: Option[String] = None, fileFileName: Option[String] = None, fileContentType: Option[String] = None, fileFileSize: Option[Int] = None, fileUpdatedAt: Option[java.sql.Timestamp] = None, note: Option[String] = None, status: Option[String] = Some("published"), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, title: String, showToPublic: Option[Boolean] = Some(false), description: Option[String] = None)
  /** GetResult implicit for fetching GalleryItemsRow objects using plain SQL queries */
  implicit def GetResultGalleryItemsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String], e5: GR[Option[Boolean]]): GR[GalleryItemsRow] = GR{
    prs => import prs._
    GalleryItemsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[String], <<?[Boolean], <<?[String]))
  }
  /** Table description of table gallery_items. Objects of this class serve as prototypes for rows in queries. */
  class GalleryItems(_tableTag: Tag) extends Table[GalleryItemsRow](_tableTag, "gallery_items") {
    def * = (id, sourceId, sourceType, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, note, status, createdAt, updatedAt, title, showToPublic, description) <> (GalleryItemsRow.tupled, GalleryItemsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), sourceId, sourceType, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, note, status, createdAt, updatedAt, Rep.Some(title), showToPublic, description).shaped.<>({r=>import r._; _1.map(_=> GalleryItemsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12.get, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column source_id SqlType(INT), Default(None) */
    val sourceId: Rep[Option[Int]] = column[Option[Int]]("source_id", O.Default(None))
    /** Database column source_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val sourceType: Rep[Option[String]] = column[Option[String]]("source_type", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileFileName: Rep[Option[String]] = column[Option[String]]("file_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileContentType: Rep[Option[String]] = column[Option[String]]("file_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_size SqlType(INT), Default(None) */
    val fileFileSize: Rep[Option[Int]] = column[Option[Int]]("file_file_size", O.Default(None))
    /** Database column file_updated_at SqlType(DATETIME), Default(None) */
    val fileUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("file_updated_at", O.Default(None))
    /** Database column note SqlType(VARCHAR), Length(255,true), Default(None) */
    val note: Rep[Option[String]] = column[Option[String]]("note", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(Some(published)) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(Some("published")))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column title SqlType(VARCHAR), Length(255,true) */
    val title: Rep[String] = column[String]("title", O.Length(255,varying=true))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
  }
  /** Collection-like TableQuery object for table GalleryItems */
  lazy val GalleryItems = new TableQuery(tag => new GalleryItems(tag))

  /** Entity class storing rows of table GiftcardClasses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(100,true)
   *  @param label Database column label SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param description Database column description SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param active Database column active SqlType(BIT), Default(Some(false)) */
  case class GiftcardClassesRow(id: Int, name: String, label: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, active: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching GiftcardClassesRow objects using plain SQL queries */
  implicit def GetResultGiftcardClassesRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Int]], e5: GR[Option[Boolean]]): GR[GiftcardClassesRow] = GR{
    prs => import prs._
    GiftcardClassesRow.tupled((<<[Int], <<[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[Boolean]))
  }
  /** Table description of table giftcard_classes. Objects of this class serve as prototypes for rows in queries. */
  class GiftcardClasses(_tableTag: Tag) extends Table[GiftcardClassesRow](_tableTag, "giftcard_classes") {
    def * = (id, name, label, description, createdAt, updatedAt, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, active) <> (GiftcardClassesRow.tupled, GiftcardClassesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), label, description, createdAt, updatedAt, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, active).shaped.<>({r=>import r._; _1.map(_=> GiftcardClassesRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(100,true) */
    val name: Rep[String] = column[String]("name", O.Length(100,varying=true))
    /** Database column label SqlType(VARCHAR), Length(100,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(100,varying=true), O.Default(None))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column active SqlType(BIT), Default(Some(false)) */
    val active: Rep[Option[Boolean]] = column[Option[Boolean]]("active", O.Default(Some(false)))
  }
  /** Collection-like TableQuery object for table GiftcardClasses */
  lazy val GiftcardClasses = new TableQuery(tag => new GiftcardClasses(tag))

  /** Entity class storing rows of table Giftcards
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param pin Database column pin SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param balance Database column balance SqlType(DECIMAL), Default(Some(0.00))
   *  @param description Database column description SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param giftcardClassId Database column giftcard_class_id SqlType(INT), Default(None)
   *  @param giftcardType Database column giftcard_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param activatedAt Database column activated_at SqlType(DATETIME), Default(None)
   *  @param deactivatedAt Database column deactivated_at SqlType(DATETIME), Default(None)
   *  @param autoReload Database column auto_reload SqlType(BIT), Default(Some(false))
   *  @param reloadThreshold Database column reload_threshold SqlType(DECIMAL), Default(Some(0.00))
   *  @param reloadAmount Database column reload_amount SqlType(DECIMAL), Default(Some(0.00))
   *  @param paymentToken Database column payment_token SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param reloadDescription Database column reload_description SqlType(TEXT), Default(None) */
  case class GiftcardsRow(id: Int, memberId: Option[Int] = None, code: Option[String] = None, pin: Option[String] = None, name: Option[String] = None, balance: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, giftcardClassId: Option[Int] = None, giftcardType: Option[String] = None, activatedAt: Option[java.sql.Timestamp] = None, deactivatedAt: Option[java.sql.Timestamp] = None, autoReload: Option[Boolean] = Some(false), reloadThreshold: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), reloadAmount: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), paymentToken: Option[String] = None, reloadDescription: Option[String] = None)
  /** GetResult implicit for fetching GiftcardsRow objects using plain SQL queries */
  implicit def GetResultGiftcardsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]]): GR[GiftcardsRow] = GR{
    prs => import prs._
    GiftcardsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean], <<?[scala.math.BigDecimal], <<?[scala.math.BigDecimal], <<?[String], <<?[String]))
  }
  /** Table description of table giftcards. Objects of this class serve as prototypes for rows in queries. */
  class Giftcards(_tableTag: Tag) extends Table[GiftcardsRow](_tableTag, "giftcards") {
    def * = (id, memberId, code, pin, name, balance, description, createdAt, updatedAt, giftcardClassId, giftcardType, activatedAt, deactivatedAt, autoReload, reloadThreshold, reloadAmount, paymentToken, reloadDescription) <> (GiftcardsRow.tupled, GiftcardsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, code, pin, name, balance, description, createdAt, updatedAt, giftcardClassId, giftcardType, activatedAt, deactivatedAt, autoReload, reloadThreshold, reloadAmount, paymentToken, reloadDescription).shaped.<>({r=>import r._; _1.map(_=> GiftcardsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(255,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(255,varying=true), O.Default(None))
    /** Database column pin SqlType(VARCHAR), Length(255,true), Default(None) */
    val pin: Rep[Option[String]] = column[Option[String]]("pin", O.Length(255,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column balance SqlType(DECIMAL), Default(Some(0.00)) */
    val balance: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("balance", O.Default(Some(BigDecimal("0.00"))))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column giftcard_class_id SqlType(INT), Default(None) */
    val giftcardClassId: Rep[Option[Int]] = column[Option[Int]]("giftcard_class_id", O.Default(None))
    /** Database column giftcard_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val giftcardType: Rep[Option[String]] = column[Option[String]]("giftcard_type", O.Length(255,varying=true), O.Default(None))
    /** Database column activated_at SqlType(DATETIME), Default(None) */
    val activatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("activated_at", O.Default(None))
    /** Database column deactivated_at SqlType(DATETIME), Default(None) */
    val deactivatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("deactivated_at", O.Default(None))
    /** Database column auto_reload SqlType(BIT), Default(Some(false)) */
    val autoReload: Rep[Option[Boolean]] = column[Option[Boolean]]("auto_reload", O.Default(Some(false)))
    /** Database column reload_threshold SqlType(DECIMAL), Default(Some(0.00)) */
    val reloadThreshold: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("reload_threshold", O.Default(Some(BigDecimal("0.00"))))
    /** Database column reload_amount SqlType(DECIMAL), Default(Some(0.00)) */
    val reloadAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("reload_amount", O.Default(Some(BigDecimal("0.00"))))
    /** Database column payment_token SqlType(VARCHAR), Length(50,true), Default(None) */
    val paymentToken: Rep[Option[String]] = column[Option[String]]("payment_token", O.Length(50,varying=true), O.Default(None))
    /** Database column reload_description SqlType(TEXT), Default(None) */
    val reloadDescription: Rep[Option[String]] = column[Option[String]]("reload_description", O.Default(None))

    /** Index over (giftcardClassId) (database name index_giftcards_on_giftcard_class_id) */
    val index1 = index("index_giftcards_on_giftcard_class_id", giftcardClassId)
    /** Index over (memberId) (database name index_giftcards_on_member_id) */
    val index2 = index("index_giftcards_on_member_id", memberId)
  }
  /** Collection-like TableQuery object for table Giftcards */
  lazy val Giftcards = new TableQuery(tag => new Giftcards(tag))

  /** Entity class storing rows of table GiftcardTransactions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param giftcardId Database column giftcard_id SqlType(INT), Default(None)
   *  @param transactionType Database column transaction_type SqlType(VARCHAR), Length(30,true), Default(None)
   *  @param amount Database column amount SqlType(DECIMAL), Default(Some(0.00))
   *  @param description Database column description SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param txnId Database column txn_id SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param paymentGateway Database column payment_gateway SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param memberId Database column member_id SqlType(INT), Default(None) */
  case class GiftcardTransactionsRow(id: Int, giftcardId: Option[Int] = None, transactionType: Option[String] = None, amount: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, txnId: Option[String] = None, paymentGateway: Option[String] = None, memberId: Option[Int] = None)
  /** GetResult implicit for fetching GiftcardTransactionsRow objects using plain SQL queries */
  implicit def GetResultGiftcardTransactionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]]): GR[GiftcardTransactionsRow] = GR{
    prs => import prs._
    GiftcardTransactionsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[scala.math.BigDecimal], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[Int]))
  }
  /** Table description of table giftcard_transactions. Objects of this class serve as prototypes for rows in queries. */
  class GiftcardTransactions(_tableTag: Tag) extends Table[GiftcardTransactionsRow](_tableTag, "giftcard_transactions") {
    def * = (id, giftcardId, transactionType, amount, description, createdAt, updatedAt, txnId, paymentGateway, memberId) <> (GiftcardTransactionsRow.tupled, GiftcardTransactionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), giftcardId, transactionType, amount, description, createdAt, updatedAt, txnId, paymentGateway, memberId).shaped.<>({r=>import r._; _1.map(_=> GiftcardTransactionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column giftcard_id SqlType(INT), Default(None) */
    val giftcardId: Rep[Option[Int]] = column[Option[Int]]("giftcard_id", O.Default(None))
    /** Database column transaction_type SqlType(VARCHAR), Length(30,true), Default(None) */
    val transactionType: Rep[Option[String]] = column[Option[String]]("transaction_type", O.Length(30,varying=true), O.Default(None))
    /** Database column amount SqlType(DECIMAL), Default(Some(0.00)) */
    val amount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("amount", O.Default(Some(BigDecimal("0.00"))))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column txn_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val txnId: Rep[Option[String]] = column[Option[String]]("txn_id", O.Length(255,varying=true), O.Default(None))
    /** Database column payment_gateway SqlType(VARCHAR), Length(255,true), Default(None) */
    val paymentGateway: Rep[Option[String]] = column[Option[String]]("payment_gateway", O.Length(255,varying=true), O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))

    /** Index over (giftcardId) (database name index_giftcard_transactions_on_giftcard_id) */
    val index1 = index("index_giftcard_transactions_on_giftcard_id", giftcardId)
    /** Index over (memberId) (database name index_giftcard_transactions_on_member_id) */
    val index2 = index("index_giftcard_transactions_on_member_id", memberId)
  }
  /** Collection-like TableQuery object for table GiftcardTransactions */
  lazy val GiftcardTransactions = new TableQuery(tag => new GiftcardTransactions(tag))

  /** Entity class storing rows of table Identities
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param uid Database column uid SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param provider Database column provider SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param secret Database column secret SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param expiresAt Database column expires_at SqlType(DATETIME), Default(None)
   *  @param email Database column email SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param nickname Database column nickname SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param firstName Database column first_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param lastName Database column last_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param avatar Database column avatar SqlType(TEXT), Default(None) */
  case class IdentitiesRow(id: Int, uid: Option[String] = None, provider: Option[String] = None, secret: Option[String] = None, expiresAt: Option[java.sql.Timestamp] = None, email: Option[String] = None, nickname: Option[String] = None, firstName: Option[String] = None, lastName: Option[String] = None, memberId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, name: Option[String] = None, avatar: Option[String] = None)
  /** GetResult implicit for fetching IdentitiesRow objects using plain SQL queries */
  implicit def GetResultIdentitiesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]]): GR[IdentitiesRow] = GR{
    prs => import prs._
    IdentitiesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String]))
  }
  /** Table description of table identities. Objects of this class serve as prototypes for rows in queries. */
  class Identities(_tableTag: Tag) extends Table[IdentitiesRow](_tableTag, "identities") {
    def * = (id, uid, provider, secret, expiresAt, email, nickname, firstName, lastName, memberId, createdAt, updatedAt, name, avatar) <> (IdentitiesRow.tupled, IdentitiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), uid, provider, secret, expiresAt, email, nickname, firstName, lastName, memberId, createdAt, updatedAt, name, avatar).shaped.<>({r=>import r._; _1.map(_=> IdentitiesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column uid SqlType(VARCHAR), Length(255,true), Default(None) */
    val uid: Rep[Option[String]] = column[Option[String]]("uid", O.Length(255,varying=true), O.Default(None))
    /** Database column provider SqlType(VARCHAR), Length(255,true), Default(None) */
    val provider: Rep[Option[String]] = column[Option[String]]("provider", O.Length(255,varying=true), O.Default(None))
    /** Database column secret SqlType(VARCHAR), Length(255,true), Default(None) */
    val secret: Rep[Option[String]] = column[Option[String]]("secret", O.Length(255,varying=true), O.Default(None))
    /** Database column expires_at SqlType(DATETIME), Default(None) */
    val expiresAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("expires_at", O.Default(None))
    /** Database column email SqlType(VARCHAR), Length(255,true), Default(None) */
    val email: Rep[Option[String]] = column[Option[String]]("email", O.Length(255,varying=true), O.Default(None))
    /** Database column nickname SqlType(VARCHAR), Length(255,true), Default(None) */
    val nickname: Rep[Option[String]] = column[Option[String]]("nickname", O.Length(255,varying=true), O.Default(None))
    /** Database column first_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val firstName: Rep[Option[String]] = column[Option[String]]("first_name", O.Length(255,varying=true), O.Default(None))
    /** Database column last_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val lastName: Rep[Option[String]] = column[Option[String]]("last_name", O.Length(255,varying=true), O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column avatar SqlType(TEXT), Default(None) */
    val avatar: Rep[Option[String]] = column[Option[String]]("avatar", O.Default(None))

    /** Uniqueness Index over (memberId,provider) (database name index_identities_on_member_id_and_provider) */
    val index1 = index("index_identities_on_member_id_and_provider", (memberId, provider), unique=true)
    /** Uniqueness Index over (uid,provider) (database name index_identities_on_uid_and_provider) */
    val index2 = index("index_identities_on_uid_and_provider", (uid, provider), unique=true)
  }
  /** Collection-like TableQuery object for table Identities */
  lazy val Identities = new TableQuery(tag => new Identities(tag))

  /** Entity class storing rows of table ImportDefinitions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param resource Database column resource SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ImportDefinitionsRow(id: Int, resource: Option[String] = None, definition: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ImportDefinitionsRow objects using plain SQL queries */
  implicit def GetResultImportDefinitionsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]]): GR[ImportDefinitionsRow] = GR{
    prs => import prs._
    ImportDefinitionsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table import_definitions. Objects of this class serve as prototypes for rows in queries. */
  class ImportDefinitions(_tableTag: Tag) extends Table[ImportDefinitionsRow](_tableTag, "import_definitions") {
    def * = (id, resource, definition, createdAt, updatedAt) <> (ImportDefinitionsRow.tupled, ImportDefinitionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), resource, definition, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ImportDefinitionsRow.tupled((_1.get, _2, _3, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column resource SqlType(VARCHAR), Length(255,true), Default(None) */
    val resource: Rep[Option[String]] = column[Option[String]]("resource", O.Length(255,varying=true), O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ImportDefinitions */
  lazy val ImportDefinitions = new TableQuery(tag => new ImportDefinitions(tag))

  /** Entity class storing rows of table Imports
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param adminId Database column admin_id SqlType(INT), Default(None)
   *  @param resource Database column resource SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param importFileId Database column import_file_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param importedRows Database column imported_rows SqlType(INT), Default(Some(0))
   *  @param failedRows Database column failed_rows SqlType(INT), Default(Some(0))
   *  @param parentResourceId Database column parent_resource_id SqlType(INT), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param lastExecutedAt Database column last_executed_at SqlType(DATETIME), Default(None)
   *  @param emailRecipients Database column email_recipients SqlType(TEXT), Default(None) */
  case class ImportsRow(id: Int, adminId: Option[Int] = None, resource: Option[String] = None, importFileId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, importedRows: Option[Int] = Some(0), failedRows: Option[Int] = Some(0), parentResourceId: Option[Int] = None, definition: Option[String] = None, lastExecutedAt: Option[java.sql.Timestamp] = None, emailRecipients: Option[String] = None)
  /** GetResult implicit for fetching ImportsRow objects using plain SQL queries */
  implicit def GetResultImportsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ImportsRow] = GR{
    prs => import prs._
    ImportsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table imports. Objects of this class serve as prototypes for rows in queries. */
  class Imports(_tableTag: Tag) extends Table[ImportsRow](_tableTag, "imports") {
    def * = (id, adminId, resource, importFileId, createdAt, updatedAt, importedRows, failedRows, parentResourceId, definition, lastExecutedAt, emailRecipients) <> (ImportsRow.tupled, ImportsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), adminId, resource, importFileId, createdAt, updatedAt, importedRows, failedRows, parentResourceId, definition, lastExecutedAt, emailRecipients).shaped.<>({r=>import r._; _1.map(_=> ImportsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column admin_id SqlType(INT), Default(None) */
    val adminId: Rep[Option[Int]] = column[Option[Int]]("admin_id", O.Default(None))
    /** Database column resource SqlType(VARCHAR), Length(255,true), Default(None) */
    val resource: Rep[Option[String]] = column[Option[String]]("resource", O.Length(255,varying=true), O.Default(None))
    /** Database column import_file_id SqlType(INT), Default(None) */
    val importFileId: Rep[Option[Int]] = column[Option[Int]]("import_file_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column imported_rows SqlType(INT), Default(Some(0)) */
    val importedRows: Rep[Option[Int]] = column[Option[Int]]("imported_rows", O.Default(Some(0)))
    /** Database column failed_rows SqlType(INT), Default(Some(0)) */
    val failedRows: Rep[Option[Int]] = column[Option[Int]]("failed_rows", O.Default(Some(0)))
    /** Database column parent_resource_id SqlType(INT), Default(None) */
    val parentResourceId: Rep[Option[Int]] = column[Option[Int]]("parent_resource_id", O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column last_executed_at SqlType(DATETIME), Default(None) */
    val lastExecutedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("last_executed_at", O.Default(None))
    /** Database column email_recipients SqlType(TEXT), Default(None) */
    val emailRecipients: Rep[Option[String]] = column[Option[String]]("email_recipients", O.Default(None))

    /** Index over (adminId) (database name index_imports_on_admin_id) */
    val index1 = index("index_imports_on_admin_id", adminId)
    /** Index over (importFileId) (database name index_imports_on_import_file_id) */
    val index2 = index("index_imports_on_import_file_id", importFileId)
  }
  /** Collection-like TableQuery object for table Imports */
  lazy val Imports = new TableQuery(tag => new Imports(tag))

  /** Entity class storing rows of table JobResults
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param jobId Database column job_id SqlType(INT), Default(None)
   *  @param executionId Database column execution_id SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param startedAt Database column started_at SqlType(DATETIME), Default(None)
   *  @param finishedAt Database column finished_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param response Database column response SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param errorMessage Database column error_message SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param results Database column results SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param resultContentType Database column result_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
  case class JobResultsRow(id: Int, jobId: Option[Int] = None, executionId: Option[String] = None, startedAt: Option[java.sql.Timestamp] = None, finishedAt: Option[java.sql.Timestamp] = None, status: Option[String] = None, response: Option[String] = None, errorMessage: Option[String] = None, results: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, resultContentType: Option[String] = None)
  /** GetResult implicit for fetching JobResultsRow objects using plain SQL queries */
  implicit def GetResultJobResultsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[JobResultsRow] = GR{
    prs => import prs._
    JobResultsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table job_results. Objects of this class serve as prototypes for rows in queries. */
  class JobResults(_tableTag: Tag) extends Table[JobResultsRow](_tableTag, "job_results") {
    def * = (id, jobId, executionId, startedAt, finishedAt, status, response, errorMessage, results, createdAt, updatedAt, resultContentType) <> (JobResultsRow.tupled, JobResultsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), jobId, executionId, startedAt, finishedAt, status, response, errorMessage, results, createdAt, updatedAt, resultContentType).shaped.<>({r=>import r._; _1.map(_=> JobResultsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column job_id SqlType(INT), Default(None) */
    val jobId: Rep[Option[Int]] = column[Option[Int]]("job_id", O.Default(None))
    /** Database column execution_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val executionId: Rep[Option[String]] = column[Option[String]]("execution_id", O.Length(255,varying=true), O.Default(None))
    /** Database column started_at SqlType(DATETIME), Default(None) */
    val startedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("started_at", O.Default(None))
    /** Database column finished_at SqlType(DATETIME), Default(None) */
    val finishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("finished_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(None))
    /** Database column response SqlType(VARCHAR), Length(255,true), Default(None) */
    val response: Rep[Option[String]] = column[Option[String]]("response", O.Length(255,varying=true), O.Default(None))
    /** Database column error_message SqlType(VARCHAR), Length(255,true), Default(None) */
    val errorMessage: Rep[Option[String]] = column[Option[String]]("error_message", O.Length(255,varying=true), O.Default(None))
    /** Database column results SqlType(TEXT), Default(None) */
    val results: Rep[Option[String]] = column[Option[String]]("results", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column result_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val resultContentType: Rep[Option[String]] = column[Option[String]]("result_content_type", O.Length(255,varying=true), O.Default(None))

    /** Index over (jobId) (database name index_job_results_on_job_id) */
    val index1 = index("index_job_results_on_job_id", jobId)
  }
  /** Collection-like TableQuery object for table JobResults */
  lazy val JobResults = new TableQuery(tag => new JobResults(tag))

  /** Row type of table Jobs */
  type JobsRow = HCons[Int,HCons[String,HCons[Option[String],HCons[String,HCons[Option[String],HCons[Option[String],HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Boolean,HCons[Boolean,HCons[java.sql.Timestamp,HCons[java.sql.Timestamp,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for JobsRow providing default values if available in the database schema. */
  def JobsRow(id: Int, name: String, description: Option[String] = None, jobId: String, log: Option[String] = None, jobClass: Option[String] = None, jobType: String, lastExecutedAt: Option[java.sql.Timestamp] = None, healthy: Option[Boolean] = None, args: Option[String] = None, freq: Option[String] = None, freqType: Option[String] = None, cron: Option[String] = None, nextExecutionOn: Option[java.sql.Timestamp] = None, options: Option[String] = None, errorMessage: Option[String] = None, notificationEmails: Option[String] = None, status: Option[String] = Some("stopped"), executionId: Option[String] = None, enabled: Boolean = true, enableLogging: Boolean = true, createdAt: java.sql.Timestamp, updatedAt: java.sql.Timestamp, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, queue: Option[String] = Some("default"), subjectId: Option[Int] = None, subjectType: Option[String] = None, backgroundColor: Option[String] = None): JobsRow = {
    id :: name :: description :: jobId :: log :: jobClass :: jobType :: lastExecutedAt :: healthy :: args :: freq :: freqType :: cron :: nextExecutionOn :: options :: errorMessage :: notificationEmails :: status :: executionId :: enabled :: enableLogging :: createdAt :: updatedAt :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: queue :: subjectId :: subjectType :: backgroundColor :: HNil
  }
  /** GetResult implicit for fetching JobsRow objects using plain SQL queries */
  implicit def GetResultJobsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]], e5: GR[Boolean], e6: GR[java.sql.Timestamp], e7: GR[Option[Int]]): GR[JobsRow] = GR{
    prs => import prs._
    <<[Int] :: <<[String] :: <<?[String] :: <<[String] :: <<?[String] :: <<?[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<[Boolean] :: <<[Boolean] :: <<[java.sql.Timestamp] :: <<[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: HNil
  }
  /** Table description of table jobs. Objects of this class serve as prototypes for rows in queries. */
  class Jobs(_tableTag: Tag) extends Table[JobsRow](_tableTag, "jobs") {
    def * = id :: name :: description :: jobId :: log :: jobClass :: jobType :: lastExecutedAt :: healthy :: args :: freq :: freqType :: cron :: nextExecutionOn :: options :: errorMessage :: notificationEmails :: status :: executionId :: enabled :: enableLogging :: createdAt :: updatedAt :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: queue :: subjectId :: subjectType :: backgroundColor :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column job_id SqlType(VARCHAR), Length(255,true) */
    val jobId: Rep[String] = column[String]("job_id", O.Length(255,varying=true))
    /** Database column log SqlType(TEXT), Default(None) */
    val log: Rep[Option[String]] = column[Option[String]]("log", O.Default(None))
    /** Database column job_class SqlType(VARCHAR), Length(255,true), Default(None) */
    val jobClass: Rep[Option[String]] = column[Option[String]]("job_class", O.Length(255,varying=true), O.Default(None))
    /** Database column job_type SqlType(VARCHAR), Length(255,true) */
    val jobType: Rep[String] = column[String]("job_type", O.Length(255,varying=true))
    /** Database column last_executed_at SqlType(DATETIME), Default(None) */
    val lastExecutedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("last_executed_at", O.Default(None))
    /** Database column healthy SqlType(BIT), Default(None) */
    val healthy: Rep[Option[Boolean]] = column[Option[Boolean]]("healthy", O.Default(None))
    /** Database column args SqlType(TEXT), Default(None) */
    val args: Rep[Option[String]] = column[Option[String]]("args", O.Default(None))
    /** Database column freq SqlType(VARCHAR), Length(255,true), Default(None) */
    val freq: Rep[Option[String]] = column[Option[String]]("freq", O.Length(255,varying=true), O.Default(None))
    /** Database column freq_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val freqType: Rep[Option[String]] = column[Option[String]]("freq_type", O.Length(255,varying=true), O.Default(None))
    /** Database column cron SqlType(VARCHAR), Length(255,true), Default(None) */
    val cron: Rep[Option[String]] = column[Option[String]]("cron", O.Length(255,varying=true), O.Default(None))
    /** Database column next_execution_on SqlType(DATETIME), Default(None) */
    val nextExecutionOn: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("next_execution_on", O.Default(None))
    /** Database column options SqlType(TEXT), Default(None) */
    val options: Rep[Option[String]] = column[Option[String]]("options", O.Default(None))
    /** Database column error_message SqlType(VARCHAR), Length(255,true), Default(None) */
    val errorMessage: Rep[Option[String]] = column[Option[String]]("error_message", O.Length(255,varying=true), O.Default(None))
    /** Database column notification_emails SqlType(VARCHAR), Length(255,true), Default(None) */
    val notificationEmails: Rep[Option[String]] = column[Option[String]]("notification_emails", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(Some(stopped)) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(Some("stopped")))
    /** Database column execution_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val executionId: Rep[Option[String]] = column[Option[String]]("execution_id", O.Length(255,varying=true), O.Default(None))
    /** Database column enabled SqlType(BIT), Default(true) */
    val enabled: Rep[Boolean] = column[Boolean]("enabled", O.Default(true))
    /** Database column enable_logging SqlType(BIT), Default(true) */
    val enableLogging: Rep[Boolean] = column[Boolean]("enable_logging", O.Default(true))
    /** Database column created_at SqlType(DATETIME) */
    val createdAt: Rep[java.sql.Timestamp] = column[java.sql.Timestamp]("created_at")
    /** Database column updated_at SqlType(DATETIME) */
    val updatedAt: Rep[java.sql.Timestamp] = column[java.sql.Timestamp]("updated_at")
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column queue SqlType(VARCHAR), Length(255,true), Default(Some(default)) */
    val queue: Rep[Option[String]] = column[Option[String]]("queue", O.Length(255,varying=true), O.Default(Some("default")))
    /** Database column subject_id SqlType(INT), Default(None) */
    val subjectId: Rep[Option[Int]] = column[Option[Int]]("subject_id", O.Default(None))
    /** Database column subject_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val subjectType: Rep[Option[String]] = column[Option[String]]("subject_type", O.Length(255,varying=true), O.Default(None))
    /** Database column background_color SqlType(VARCHAR), Length(10,true), Default(None) */
    val backgroundColor: Rep[Option[String]] = column[Option[String]]("background_color", O.Length(10,varying=true), O.Default(None))

    /** Uniqueness Index over (jobId) (database name index_jobs_on_job_id) */
    val index1 = index("index_jobs_on_job_id", jobId :: HNil, unique=true)
  }
  /** Collection-like TableQuery object for table Jobs */
  lazy val Jobs = new TableQuery(tag => new Jobs(tag))

  /** Entity class storing rows of table LocationHierarchies
   *  @param ancestorId Database column ancestor_id SqlType(INT)
   *  @param descendantId Database column descendant_id SqlType(INT)
   *  @param generations Database column generations SqlType(INT) */
  case class LocationHierarchiesRow(ancestorId: Int, descendantId: Int, generations: Int)
  /** GetResult implicit for fetching LocationHierarchiesRow objects using plain SQL queries */
  implicit def GetResultLocationHierarchiesRow(implicit e0: GR[Int]): GR[LocationHierarchiesRow] = GR{
    prs => import prs._
    LocationHierarchiesRow.tupled((<<[Int], <<[Int], <<[Int]))
  }
  /** Table description of table location_hierarchies. Objects of this class serve as prototypes for rows in queries. */
  class LocationHierarchies(_tableTag: Tag) extends Table[LocationHierarchiesRow](_tableTag, "location_hierarchies") {
    def * = (ancestorId, descendantId, generations) <> (LocationHierarchiesRow.tupled, LocationHierarchiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(ancestorId), Rep.Some(descendantId), Rep.Some(generations)).shaped.<>({r=>import r._; _1.map(_=> LocationHierarchiesRow.tupled((_1.get, _2.get, _3.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column ancestor_id SqlType(INT) */
    val ancestorId: Rep[Int] = column[Int]("ancestor_id")
    /** Database column descendant_id SqlType(INT) */
    val descendantId: Rep[Int] = column[Int]("descendant_id")
    /** Database column generations SqlType(INT) */
    val generations: Rep[Int] = column[Int]("generations")

    /** Uniqueness Index over (ancestorId,descendantId,generations) (database name location_anc_desc_idx) */
    val index1 = index("location_anc_desc_idx", (ancestorId, descendantId, generations), unique=true)
    /** Index over (descendantId) (database name location_desc_idx) */
    val index2 = index("location_desc_idx", descendantId)
  }
  /** Collection-like TableQuery object for table LocationHierarchies */
  lazy val LocationHierarchies = new TableQuery(tag => new LocationHierarchies(tag))

  /** Row type of table Locations */
  type LocationsRow = HCons[Int,HCons[Option[Int],HCons[String,HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[Int],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Int,HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for LocationsRow providing default values if available in the database schema. */
  def LocationsRow(id: Int, programId: Option[Int] = None, name: String, address: Option[String] = None, countryCode: Option[String] = None, zipCode: Option[String] = None, phone: Option[String] = None, latitude: Option[scala.math.BigDecimal] = None, longitude: Option[scala.math.BigDecimal] = None, operatingHours: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, placeId: Option[String] = None, label: Option[String] = None, status: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, parentId: Option[Int] = None, `type`: Option[String] = None, sortOrder: Option[Int] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, publishedAt: Option[java.sql.Timestamp] = None, lft: Option[Int] = None, rgt: Option[Int] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, properties: Option[String] = None, integrationId: Option[String] = None, radius: Option[scala.math.BigDecimal] = None, radiusUnit: Option[String] = None, depth: Int = 0, iataCode: Option[String] = None): LocationsRow = {
    id :: programId :: name :: address :: countryCode :: zipCode :: phone :: latitude :: longitude :: operatingHours :: createdAt :: updatedAt :: placeId :: label :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: parentId :: `type` :: sortOrder :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: publishedAt :: lft :: rgt :: recurring :: recurringSchedule :: properties :: integrationId :: radius :: radiusUnit :: depth :: iataCode :: HNil
  }
  /** GetResult implicit for fetching LocationsRow objects using plain SQL queries */
  implicit def GetResultLocationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[String]], e4: GR[Option[scala.math.BigDecimal]], e5: GR[Option[java.sql.Timestamp]], e6: GR[Option[Boolean]]): GR[LocationsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[Int] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<[Int] :: <<?[String] :: HNil
  }
  /** Table description of table locations. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Locations(_tableTag: Tag) extends Table[LocationsRow](_tableTag, "locations") {
    def * = id :: programId :: name :: address :: countryCode :: zipCode :: phone :: latitude :: longitude :: operatingHours :: createdAt :: updatedAt :: placeId :: label :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: parentId :: `type` :: sortOrder :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: publishedAt :: lft :: rgt :: recurring :: recurringSchedule :: properties :: integrationId :: radius :: radiusUnit :: depth :: iataCode :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column address SqlType(TEXT), Default(None) */
    val address: Rep[Option[String]] = column[Option[String]]("address", O.Default(None))
    /** Database column country_code SqlType(VARCHAR), Length(10,true), Default(None) */
    val countryCode: Rep[Option[String]] = column[Option[String]]("country_code", O.Length(10,varying=true), O.Default(None))
    /** Database column zip_code SqlType(VARCHAR), Length(10,true), Default(None) */
    val zipCode: Rep[Option[String]] = column[Option[String]]("zip_code", O.Length(10,varying=true), O.Default(None))
    /** Database column phone SqlType(VARCHAR), Length(100,true), Default(None) */
    val phone: Rep[Option[String]] = column[Option[String]]("phone", O.Length(100,varying=true), O.Default(None))
    /** Database column latitude SqlType(DECIMAL), Default(None) */
    val latitude: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("latitude", O.Default(None))
    /** Database column longitude SqlType(DECIMAL), Default(None) */
    val longitude: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("longitude", O.Default(None))
    /** Database column operating_hours SqlType(TEXT), Default(None) */
    val operatingHours: Rep[Option[String]] = column[Option[String]]("operating_hours", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column place_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val placeId: Rep[Option[String]] = column[Option[String]]("place_id", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(100,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(100,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column parent_id SqlType(INT), Default(None) */
    val parentId: Rep[Option[Int]] = column[Option[Int]]("parent_id", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(50,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(50,varying=true), O.Default(None))
    /** Database column sort_order SqlType(INT), Default(None) */
    val sortOrder: Rep[Option[Int]] = column[Option[Int]]("sort_order", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column lft SqlType(INT), Default(None) */
    val lft: Rep[Option[Int]] = column[Option[Int]]("lft", O.Default(None))
    /** Database column rgt SqlType(INT), Default(None) */
    val rgt: Rep[Option[Int]] = column[Option[Int]]("rgt", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column integration_id SqlType(VARCHAR), Length(100,true), Default(None) */
    val integrationId: Rep[Option[String]] = column[Option[String]]("integration_id", O.Length(100,varying=true), O.Default(None))
    /** Database column radius SqlType(DECIMAL), Default(None) */
    val radius: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("radius", O.Default(None))
    /** Database column radius_unit SqlType(VARCHAR), Length(255,true), Default(None) */
    val radiusUnit: Rep[Option[String]] = column[Option[String]]("radius_unit", O.Length(255,varying=true), O.Default(None))
    /** Database column depth SqlType(INT), Default(0) */
    val depth: Rep[Int] = column[Int]("depth", O.Default(0))
    /** Database column iata_code SqlType(VARCHAR), Length(255,true), Default(None) */
    val iataCode: Rep[Option[String]] = column[Option[String]]("iata_code", O.Length(255,varying=true), O.Default(None))

    /** Uniqueness Index over (name,`type`) (database name index_locations_on_name_and_type) */
    val index1 = index("index_locations_on_name_and_type", name :: `type` :: HNil, unique=true)
    /** Index over (parentId) (database name index_locations_on_parent_id) */
    val index2 = index("index_locations_on_parent_id", parentId :: HNil)
  }
  /** Collection-like TableQuery object for table Locations */
  lazy val Locations = new TableQuery(tag => new Locations(tag))

  /** Entity class storing rows of table LookupParameters
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param lookupId Database column lookup_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true) */
  case class LookupParametersRow(id: Int, name: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, lookupId: Option[Int] = None, label: String)
  /** GetResult implicit for fetching LookupParametersRow objects using plain SQL queries */
  implicit def GetResultLookupParametersRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]], e4: GR[String]): GR[LookupParametersRow] = GR{
    prs => import prs._
    LookupParametersRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<[String]))
  }
  /** Table description of table lookup_parameters. Objects of this class serve as prototypes for rows in queries. */
  class LookupParameters(_tableTag: Tag) extends Table[LookupParametersRow](_tableTag, "lookup_parameters") {
    def * = (id, name, description, createdAt, updatedAt, lookupId, label) <> (LookupParametersRow.tupled, LookupParametersRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, createdAt, updatedAt, lookupId, Rep.Some(label)).shaped.<>({r=>import r._; _1.map(_=> LookupParametersRow.tupled((_1.get, _2, _3, _4, _5, _6, _7.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column lookup_id SqlType(INT), Default(None) */
    val lookupId: Rep[Option[Int]] = column[Option[Int]]("lookup_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))

    /** Index over (lookupId) (database name index_lookup_parameters_on_lookup_id) */
    val index1 = index("index_lookup_parameters_on_lookup_id", lookupId)
  }
  /** Collection-like TableQuery object for table LookupParameters */
  lazy val LookupParameters = new TableQuery(tag => new LookupParameters(tag))

  /** Entity class storing rows of table Lookups
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param spreadsheetFileName Database column spreadsheet_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param spreadsheetContentType Database column spreadsheet_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param spreadsheetFileSize Database column spreadsheet_file_size SqlType(INT), Default(None)
   *  @param spreadsheetUpdatedAt Database column spreadsheet_updated_at SqlType(DATETIME), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None) */
  case class LookupsRow(id: Int, name: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Option[Int] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, status: Option[String] = None, spreadsheetFileName: Option[String] = None, spreadsheetContentType: Option[String] = None, spreadsheetFileSize: Option[Int] = None, spreadsheetUpdatedAt: Option[java.sql.Timestamp] = None, publishedAt: Option[java.sql.Timestamp] = None, label: String, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None)
  /** GetResult implicit for fetching LookupsRow objects using plain SQL queries */
  implicit def GetResultLookupsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]], e4: GR[String], e5: GR[Option[Boolean]]): GR[LookupsRow] = GR{
    prs => import prs._
    LookupsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[String], <<?[Boolean], <<?[String]))
  }
  /** Table description of table lookups. Objects of this class serve as prototypes for rows in queries. */
  class Lookups(_tableTag: Tag) extends Table[LookupsRow](_tableTag, "lookups") {
    def * = (id, name, description, createdAt, updatedAt, programId, effectivityStart, effectivityEnd, effectivityTimezone, status, spreadsheetFileName, spreadsheetContentType, spreadsheetFileSize, spreadsheetUpdatedAt, publishedAt, label, recurring, recurringSchedule) <> (LookupsRow.tupled, LookupsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, createdAt, updatedAt, programId, effectivityStart, effectivityEnd, effectivityTimezone, status, spreadsheetFileName, spreadsheetContentType, spreadsheetFileSize, spreadsheetUpdatedAt, publishedAt, Rep.Some(label), recurring, recurringSchedule).shaped.<>({r=>import r._; _1.map(_=> LookupsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16.get, _17, _18)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(100,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(100,varying=true), O.Default(None))
    /** Database column spreadsheet_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val spreadsheetFileName: Rep[Option[String]] = column[Option[String]]("spreadsheet_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column spreadsheet_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val spreadsheetContentType: Rep[Option[String]] = column[Option[String]]("spreadsheet_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column spreadsheet_file_size SqlType(INT), Default(None) */
    val spreadsheetFileSize: Rep[Option[Int]] = column[Option[Int]]("spreadsheet_file_size", O.Default(None))
    /** Database column spreadsheet_updated_at SqlType(DATETIME), Default(None) */
    val spreadsheetUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("spreadsheet_updated_at", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
  }
  /** Collection-like TableQuery object for table Lookups */
  lazy val Lookups = new TableQuery(tag => new Lookups(tag))

  /** Entity class storing rows of table LookupValues
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param lookupId Database column lookup_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param value Database column value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true) */
  case class LookupValuesRow(id: Int, name: Option[String] = None, description: Option[String] = None, lookupId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, value: Option[String] = None, label: String)
  /** GetResult implicit for fetching LookupValuesRow objects using plain SQL queries */
  implicit def GetResultLookupValuesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String]): GR[LookupValuesRow] = GR{
    prs => import prs._
    LookupValuesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<[String]))
  }
  /** Table description of table lookup_values. Objects of this class serve as prototypes for rows in queries. */
  class LookupValues(_tableTag: Tag) extends Table[LookupValuesRow](_tableTag, "lookup_values") {
    def * = (id, name, description, lookupId, createdAt, updatedAt, value, label) <> (LookupValuesRow.tupled, LookupValuesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, lookupId, createdAt, updatedAt, value, Rep.Some(label)).shaped.<>({r=>import r._; _1.map(_=> LookupValuesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column lookup_id SqlType(INT), Default(None) */
    val lookupId: Rep[Option[Int]] = column[Option[Int]]("lookup_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column value SqlType(VARCHAR), Length(255,true), Default(None) */
    val value: Rep[Option[String]] = column[Option[String]]("value", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))

    /** Index over (lookupId) (database name index_lookup_values_on_lookup_id) */
    val index1 = index("index_lookup_values_on_lookup_id", lookupId)
  }
  /** Collection-like TableQuery object for table LookupValues */
  lazy val LookupValues = new TableQuery(tag => new LookupValues(tag))

  /** Entity class storing rows of table ManageScores
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param strategy Database column strategy SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None) */
  case class ManageScoresRow(id: Int, name: Option[String] = None, description: Option[String] = None, strategy: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, status: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None)
  /** GetResult implicit for fetching ManageScoresRow objects using plain SQL queries */
  implicit def GetResultManageScoresRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Boolean]]): GR[ManageScoresRow] = GR{
    prs => import prs._
    ManageScoresRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[Boolean], <<?[String]))
  }
  /** Table description of table manage_scores. Objects of this class serve as prototypes for rows in queries. */
  class ManageScores(_tableTag: Tag) extends Table[ManageScoresRow](_tableTag, "manage_scores") {
    def * = (id, name, description, strategy, createdAt, updatedAt, status, effectivityStart, effectivityEnd, effectivityTimezone, publishedAt, recurring, recurringSchedule) <> (ManageScoresRow.tupled, ManageScoresRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, strategy, createdAt, updatedAt, status, effectivityStart, effectivityEnd, effectivityTimezone, publishedAt, recurring, recurringSchedule).shaped.<>({r=>import r._; _1.map(_=> ManageScoresRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column strategy SqlType(VARCHAR), Length(255,true), Default(None) */
    val strategy: Rep[Option[String]] = column[Option[String]]("strategy", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
  }
  /** Collection-like TableQuery object for table ManageScores */
  lazy val ManageScores = new TableQuery(tag => new ManageScores(tag))

  /** Entity class storing rows of table MemberAttributes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param sourceName Database column source_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param kind Database column kind SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT)
   *  @param readOnly Database column read_only SqlType(BIT), Default(Some(false))
   *  @param source Database column source SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param apiVisible Database column api_visible SqlType(BIT), Default(None)
   *  @param default Database column default SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param list Database column list SqlType(TEXT), Default(None)
   *  @param required Database column required SqlType(BIT), Default(Some(false))
   *  @param isCalculatedFlag Database column is_calculated_flag SqlType(BIT), Default(Some(false))
   *  @param expression Database column expression SqlType(TEXT), Default(None)
   *  @param timeToLive Database column time_to_live SqlType(INT), Default(None)
   *  @param maxLength Database column max_length SqlType(INT), Default(None) */
  case class MemberAttributesRow(id: Int, name: Option[String] = None, label: Option[String] = None, sourceName: Option[String] = None, kind: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Int, readOnly: Option[Boolean] = Some(false), source: Option[String] = None, apiVisible: Option[Boolean] = None, default: Option[String] = None, list: Option[String] = None, required: Option[Boolean] = Some(false), isCalculatedFlag: Option[Boolean] = Some(false), expression: Option[String] = None, timeToLive: Option[Int] = None, maxLength: Option[Int] = None)
  /** GetResult implicit for fetching MemberAttributesRow objects using plain SQL queries */
  implicit def GetResultMemberAttributesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Boolean]], e4: GR[Option[Int]]): GR[MemberAttributesRow] = GR{
    prs => import prs._
    MemberAttributesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[Int], <<?[Boolean], <<?[String], <<?[Boolean], <<?[String], <<?[String], <<?[Boolean], <<?[Boolean], <<?[String], <<?[Int], <<?[Int]))
  }
  /** Table description of table member_attributes. Objects of this class serve as prototypes for rows in queries. */
  class MemberAttributes(_tableTag: Tag) extends Table[MemberAttributesRow](_tableTag, "member_attributes") {
    def * = (id, name, label, sourceName, kind, description, createdAt, updatedAt, programId, readOnly, source, apiVisible, default, list, required, isCalculatedFlag, expression, timeToLive, maxLength) <> (MemberAttributesRow.tupled, MemberAttributesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, label, sourceName, kind, description, createdAt, updatedAt, Rep.Some(programId), readOnly, source, apiVisible, default, list, required, isCalculatedFlag, expression, timeToLive, maxLength).shaped.<>({r=>import r._; _1.map(_=> MemberAttributesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9.get, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column source_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val sourceName: Rep[Option[String]] = column[Option[String]]("source_name", O.Length(255,varying=true), O.Default(None))
    /** Database column kind SqlType(VARCHAR), Length(255,true), Default(None) */
    val kind: Rep[Option[String]] = column[Option[String]]("kind", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT) */
    val programId: Rep[Int] = column[Int]("program_id")
    /** Database column read_only SqlType(BIT), Default(Some(false)) */
    val readOnly: Rep[Option[Boolean]] = column[Option[Boolean]]("read_only", O.Default(Some(false)))
    /** Database column source SqlType(VARCHAR), Length(255,true), Default(None) */
    val source: Rep[Option[String]] = column[Option[String]]("source", O.Length(255,varying=true), O.Default(None))
    /** Database column api_visible SqlType(BIT), Default(None) */
    val apiVisible: Rep[Option[Boolean]] = column[Option[Boolean]]("api_visible", O.Default(None))
    /** Database column default SqlType(VARCHAR), Length(255,true), Default(None) */
    val default: Rep[Option[String]] = column[Option[String]]("default", O.Length(255,varying=true), O.Default(None))
    /** Database column list SqlType(TEXT), Default(None) */
    val list: Rep[Option[String]] = column[Option[String]]("list", O.Default(None))
    /** Database column required SqlType(BIT), Default(Some(false)) */
    val required: Rep[Option[Boolean]] = column[Option[Boolean]]("required", O.Default(Some(false)))
    /** Database column is_calculated_flag SqlType(BIT), Default(Some(false)) */
    val isCalculatedFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("is_calculated_flag", O.Default(Some(false)))
    /** Database column expression SqlType(TEXT), Default(None) */
    val expression: Rep[Option[String]] = column[Option[String]]("expression", O.Default(None))
    /** Database column time_to_live SqlType(INT), Default(None) */
    val timeToLive: Rep[Option[Int]] = column[Option[Int]]("time_to_live", O.Default(None))
    /** Database column max_length SqlType(INT), Default(None) */
    val maxLength: Rep[Option[Int]] = column[Option[Int]]("max_length", O.Default(None))
  }
  /** Collection-like TableQuery object for table MemberAttributes */
  lazy val MemberAttributes = new TableQuery(tag => new MemberAttributes(tag))

  /** Entity class storing rows of table MemberBadges
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param badgeId Database column badge_id SqlType(INT), Default(None)
   *  @param level Database column level SqlType(INT), Default(Some(1))
   *  @param grantedAt Database column granted_at SqlType(DATETIME), Default(None)
   *  @param expiresAt Database column expires_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param rewardResponseId Database column reward_response_id SqlType(INT), Default(None)
   *  @param responseCurrencyAmount Database column response_currency_amount SqlType(DECIMAL), Default(None)
   *  @param responseCurrencyName Database column response_currency_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param responseMetricAmount Database column response_metric_amount SqlType(DECIMAL), Default(None)
   *  @param responseMetricName Database column response_metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param autoReload Database column auto_reload SqlType(BIT), Default(None)
   *  @param reloadToken Database column reload_token SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param expiredAt Database column expired_at SqlType(DATETIME), Default(None) */
  case class MemberBadgesRow(id: Int, memberId: Option[Int] = None, badgeId: Option[Int] = None, level: Option[Int] = Some(1), grantedAt: Option[java.sql.Timestamp] = None, expiresAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, rewardResponseId: Option[Int] = None, responseCurrencyAmount: Option[scala.math.BigDecimal] = None, responseCurrencyName: Option[String] = None, responseMetricAmount: Option[scala.math.BigDecimal] = None, responseMetricName: Option[String] = None, autoReload: Option[Boolean] = None, reloadToken: Option[String] = None, expiredAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching MemberBadgesRow objects using plain SQL queries */
  implicit def GetResultMemberBadgesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[String]], e5: GR[Option[Boolean]]): GR[MemberBadgesRow] = GR{
    prs => import prs._
    MemberBadgesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[scala.math.BigDecimal], <<?[String], <<?[scala.math.BigDecimal], <<?[String], <<?[Boolean], <<?[String], <<?[java.sql.Timestamp]))
  }
  /** Table description of table member_badges. Objects of this class serve as prototypes for rows in queries. */
  class MemberBadges(_tableTag: Tag) extends Table[MemberBadgesRow](_tableTag, "member_badges") {
    def * = (id, memberId, badgeId, level, grantedAt, expiresAt, createdAt, updatedAt, rewardResponseId, responseCurrencyAmount, responseCurrencyName, responseMetricAmount, responseMetricName, autoReload, reloadToken, expiredAt) <> (MemberBadgesRow.tupled, MemberBadgesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, badgeId, level, grantedAt, expiresAt, createdAt, updatedAt, rewardResponseId, responseCurrencyAmount, responseCurrencyName, responseMetricAmount, responseMetricName, autoReload, reloadToken, expiredAt).shaped.<>({r=>import r._; _1.map(_=> MemberBadgesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column badge_id SqlType(INT), Default(None) */
    val badgeId: Rep[Option[Int]] = column[Option[Int]]("badge_id", O.Default(None))
    /** Database column level SqlType(INT), Default(Some(1)) */
    val level: Rep[Option[Int]] = column[Option[Int]]("level", O.Default(Some(1)))
    /** Database column granted_at SqlType(DATETIME), Default(None) */
    val grantedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("granted_at", O.Default(None))
    /** Database column expires_at SqlType(DATETIME), Default(None) */
    val expiresAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("expires_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column reward_response_id SqlType(INT), Default(None) */
    val rewardResponseId: Rep[Option[Int]] = column[Option[Int]]("reward_response_id", O.Default(None))
    /** Database column response_currency_amount SqlType(DECIMAL), Default(None) */
    val responseCurrencyAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("response_currency_amount", O.Default(None))
    /** Database column response_currency_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val responseCurrencyName: Rep[Option[String]] = column[Option[String]]("response_currency_name", O.Length(255,varying=true), O.Default(None))
    /** Database column response_metric_amount SqlType(DECIMAL), Default(None) */
    val responseMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("response_metric_amount", O.Default(None))
    /** Database column response_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val responseMetricName: Rep[Option[String]] = column[Option[String]]("response_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column auto_reload SqlType(BIT), Default(None) */
    val autoReload: Rep[Option[Boolean]] = column[Option[Boolean]]("auto_reload", O.Default(None))
    /** Database column reload_token SqlType(VARCHAR), Length(255,true), Default(None) */
    val reloadToken: Rep[Option[String]] = column[Option[String]]("reload_token", O.Length(255,varying=true), O.Default(None))
    /** Database column expired_at SqlType(DATETIME), Default(None) */
    val expiredAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("expired_at", O.Default(None))

    /** Index over (badgeId) (database name index_member_badges_on_badge_id) */
    val index1 = index("index_member_badges_on_badge_id", badgeId)
    /** Index over (memberId,badgeId) (database name index_member_badges_on_member_id_and_badge_id) */
    val index2 = index("index_member_badges_on_member_id_and_badge_id", (memberId, badgeId))
    /** Index over (rewardResponseId) (database name index_member_badges_on_reward_response_id) */
    val index3 = index("index_member_badges_on_reward_response_id", rewardResponseId)
  }
  /** Collection-like TableQuery object for table MemberBadges */
  lazy val MemberBadges = new TableQuery(tag => new MemberBadges(tag))

  /** Entity class storing rows of table MemberClasses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(150,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(150,true), Default(None)
   *  @param description Database column description SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param active Database column active SqlType(BIT), Default(Some(false))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class MemberClassesRow(id: Int, name: Option[String] = None, label: Option[String] = None, description: Option[String] = None, active: Option[Boolean] = Some(false), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching MemberClassesRow objects using plain SQL queries */
  implicit def GetResultMemberClassesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Boolean]], e3: GR[Option[java.sql.Timestamp]]): GR[MemberClassesRow] = GR{
    prs => import prs._
    MemberClassesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table member_classes. Objects of this class serve as prototypes for rows in queries. */
  class MemberClasses(_tableTag: Tag) extends Table[MemberClassesRow](_tableTag, "member_classes") {
    def * = (id, name, label, description, active, createdAt, updatedAt) <> (MemberClassesRow.tupled, MemberClassesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, label, description, active, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> MemberClassesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(150,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(150,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(150,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(150,varying=true), O.Default(None))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column active SqlType(BIT), Default(Some(false)) */
    val active: Rep[Option[Boolean]] = column[Option[Boolean]]("active", O.Default(Some(false)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table MemberClasses */
  lazy val MemberClasses = new TableQuery(tag => new MemberClasses(tag))

  /** Entity class storing rows of table MemberDocuments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param documentFileName Database column document_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param documentContentType Database column document_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param documentFileSize Database column document_file_size SqlType(INT), Default(None)
   *  @param documentUpdatedAt Database column document_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param kind Database column kind SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param period Database column period SqlType(VARCHAR), Length(255,true), Default(None) */
  case class MemberDocumentsRow(id: Int, memberId: Option[Int] = None, documentFileName: Option[String] = None, documentContentType: Option[String] = None, documentFileSize: Option[Int] = None, documentUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, name: Option[String] = None, kind: Option[String] = None, period: Option[String] = None)
  /** GetResult implicit for fetching MemberDocumentsRow objects using plain SQL queries */
  implicit def GetResultMemberDocumentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[MemberDocumentsRow] = GR{
    prs => import prs._
    MemberDocumentsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String]))
  }
  /** Table description of table member_documents. Objects of this class serve as prototypes for rows in queries. */
  class MemberDocuments(_tableTag: Tag) extends Table[MemberDocumentsRow](_tableTag, "member_documents") {
    def * = (id, memberId, documentFileName, documentContentType, documentFileSize, documentUpdatedAt, createdAt, updatedAt, name, kind, period) <> (MemberDocumentsRow.tupled, MemberDocumentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, documentFileName, documentContentType, documentFileSize, documentUpdatedAt, createdAt, updatedAt, name, kind, period).shaped.<>({r=>import r._; _1.map(_=> MemberDocumentsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column document_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val documentFileName: Rep[Option[String]] = column[Option[String]]("document_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column document_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val documentContentType: Rep[Option[String]] = column[Option[String]]("document_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column document_file_size SqlType(INT), Default(None) */
    val documentFileSize: Rep[Option[Int]] = column[Option[Int]]("document_file_size", O.Default(None))
    /** Database column document_updated_at SqlType(DATETIME), Default(None) */
    val documentUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("document_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column kind SqlType(VARCHAR), Length(255,true), Default(None) */
    val kind: Rep[Option[String]] = column[Option[String]]("kind", O.Length(255,varying=true), O.Default(None))
    /** Database column period SqlType(VARCHAR), Length(255,true), Default(None) */
    val period: Rep[Option[String]] = column[Option[String]]("period", O.Length(255,varying=true), O.Default(None))

    /** Index over (kind) (database name index_member_documents_on_kind) */
    val index1 = index("index_member_documents_on_kind", kind)
    /** Index over (memberId) (database name index_member_documents_on_member_id) */
    val index2 = index("index_member_documents_on_member_id", memberId)
    /** Index over (period) (database name index_member_documents_on_period) */
    val index3 = index("index_member_documents_on_period", period)
  }
  /** Collection-like TableQuery object for table MemberDocuments */
  lazy val MemberDocuments = new TableQuery(tag => new MemberDocuments(tag))

  /** Entity class storing rows of table MemberFunctions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param category Database column category SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param values Database column values SqlType(TEXT), Default(None)
   *  @param arguments Database column arguments SqlType(TEXT), Default(None) */
  case class MemberFunctionsRow(id: Int, name: Option[String] = None, label: Option[String] = None, category: Option[String] = None, definition: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Option[Int] = None, values: Option[String] = None, arguments: Option[String] = None)
  /** GetResult implicit for fetching MemberFunctionsRow objects using plain SQL queries */
  implicit def GetResultMemberFunctionsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]]): GR[MemberFunctionsRow] = GR{
    prs => import prs._
    MemberFunctionsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String], <<?[String]))
  }
  /** Table description of table member_functions. Objects of this class serve as prototypes for rows in queries. */
  class MemberFunctions(_tableTag: Tag) extends Table[MemberFunctionsRow](_tableTag, "member_functions") {
    def * = (id, name, label, category, definition, description, createdAt, updatedAt, programId, values, arguments) <> (MemberFunctionsRow.tupled, MemberFunctionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, label, category, definition, description, createdAt, updatedAt, programId, values, arguments).shaped.<>({r=>import r._; _1.map(_=> MemberFunctionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column category SqlType(VARCHAR), Length(255,true), Default(None) */
    val category: Rep[Option[String]] = column[Option[String]]("category", O.Length(255,varying=true), O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column values SqlType(TEXT), Default(None) */
    val values: Rep[Option[String]] = column[Option[String]]("values", O.Default(None))
    /** Database column arguments SqlType(TEXT), Default(None) */
    val arguments: Rep[Option[String]] = column[Option[String]]("arguments", O.Default(None))
  }
  /** Collection-like TableQuery object for table MemberFunctions */
  lazy val MemberFunctions = new TableQuery(tag => new MemberFunctions(tag))

  /** Entity class storing rows of table MemberLinks
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param ancestorId Database column ancestor_id SqlType(INT), Default(None)
   *  @param ancestorType Database column ancestor_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param descendantId Database column descendant_id SqlType(INT), Default(None)
   *  @param descendantType Database column descendant_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param direct Database column direct SqlType(BIT), Default(None)
   *  @param count Database column count SqlType(INT), Default(None) */
  case class MemberLinksRow(id: Int, ancestorId: Option[Int] = None, ancestorType: Option[String] = None, descendantId: Option[Int] = None, descendantType: Option[String] = None, direct: Option[Boolean] = None, count: Option[Int] = None)
  /** GetResult implicit for fetching MemberLinksRow objects using plain SQL queries */
  implicit def GetResultMemberLinksRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]]): GR[MemberLinksRow] = GR{
    prs => import prs._
    MemberLinksRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[Boolean], <<?[Int]))
  }
  /** Table description of table member_links. Objects of this class serve as prototypes for rows in queries. */
  class MemberLinks(_tableTag: Tag) extends Table[MemberLinksRow](_tableTag, "member_links") {
    def * = (id, ancestorId, ancestorType, descendantId, descendantType, direct, count) <> (MemberLinksRow.tupled, MemberLinksRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), ancestorId, ancestorType, descendantId, descendantType, direct, count).shaped.<>({r=>import r._; _1.map(_=> MemberLinksRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column ancestor_id SqlType(INT), Default(None) */
    val ancestorId: Rep[Option[Int]] = column[Option[Int]]("ancestor_id", O.Default(None))
    /** Database column ancestor_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ancestorType: Rep[Option[String]] = column[Option[String]]("ancestor_type", O.Length(255,varying=true), O.Default(None))
    /** Database column descendant_id SqlType(INT), Default(None) */
    val descendantId: Rep[Option[Int]] = column[Option[Int]]("descendant_id", O.Default(None))
    /** Database column descendant_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val descendantType: Rep[Option[String]] = column[Option[String]]("descendant_type", O.Length(255,varying=true), O.Default(None))
    /** Database column direct SqlType(BIT), Default(None) */
    val direct: Rep[Option[Boolean]] = column[Option[Boolean]]("direct", O.Default(None))
    /** Database column count SqlType(INT), Default(None) */
    val count: Rep[Option[Int]] = column[Option[Int]]("count", O.Default(None))

    /** Index over (ancestorId) (database name index_member_links_on_ancestor_id) */
    val index1 = index("index_member_links_on_ancestor_id", ancestorId)
    /** Index over (descendantId) (database name index_member_links_on_descendant_id) */
    val index2 = index("index_member_links_on_descendant_id", descendantId)
  }
  /** Collection-like TableQuery object for table MemberLinks */
  lazy val MemberLinks = new TableQuery(tag => new MemberLinks(tag))

  /** Entity class storing rows of table MemberPreferences
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param isUnbounded Database column is_unbounded SqlType(BIT), Default(None)
   *  @param isMultiSelect Database column is_multi_select SqlType(BIT), Default(Some(false))
   *  @param uiHint Database column ui_hint SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param list Database column list SqlType(TEXT), Default(None) */
  case class MemberPreferencesRow(id: Int, name: Option[String] = None, label: Option[String] = None, description: Option[String] = None, isUnbounded: Option[Boolean] = None, isMultiSelect: Option[Boolean] = Some(false), uiHint: Option[String] = None, programId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, list: Option[String] = None)
  /** GetResult implicit for fetching MemberPreferencesRow objects using plain SQL queries */
  implicit def GetResultMemberPreferencesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Boolean]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[MemberPreferencesRow] = GR{
    prs => import prs._
    MemberPreferencesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[Boolean], <<?[Boolean], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table member_preferences. Objects of this class serve as prototypes for rows in queries. */
  class MemberPreferences(_tableTag: Tag) extends Table[MemberPreferencesRow](_tableTag, "member_preferences") {
    def * = (id, name, label, description, isUnbounded, isMultiSelect, uiHint, programId, createdAt, updatedAt, list) <> (MemberPreferencesRow.tupled, MemberPreferencesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, label, description, isUnbounded, isMultiSelect, uiHint, programId, createdAt, updatedAt, list).shaped.<>({r=>import r._; _1.map(_=> MemberPreferencesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column is_unbounded SqlType(BIT), Default(None) */
    val isUnbounded: Rep[Option[Boolean]] = column[Option[Boolean]]("is_unbounded", O.Default(None))
    /** Database column is_multi_select SqlType(BIT), Default(Some(false)) */
    val isMultiSelect: Rep[Option[Boolean]] = column[Option[Boolean]]("is_multi_select", O.Default(Some(false)))
    /** Database column ui_hint SqlType(VARCHAR), Length(255,true), Default(None) */
    val uiHint: Rep[Option[String]] = column[Option[String]]("ui_hint", O.Length(255,varying=true), O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column list SqlType(TEXT), Default(None) */
    val list: Rep[Option[String]] = column[Option[String]]("list", O.Default(None))
  }
  /** Collection-like TableQuery object for table MemberPreferences */
  lazy val MemberPreferences = new TableQuery(tag => new MemberPreferences(tag))

  /** Row type of table Members */
  type MembersRow = HCons[Int,HCons[String,HCons[String,HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Int,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Boolean,HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[String,HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[String,HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for MembersRow providing default values if available in the database schema. */
  def MembersRow(id: Int, email: String = "", encryptedPassword: String = "", resetPasswordToken: Option[String] = None, resetPasswordSentAt: Option[java.sql.Timestamp] = None, rememberCreatedAt: Option[java.sql.Timestamp] = None, signInCount: Int = 0, currentSignInAt: Option[java.sql.Timestamp] = None, lastSignInAt: Option[java.sql.Timestamp] = None, currentSignInIp: Option[String] = None, lastSignInIp: Option[String] = None, confirmationToken: Option[String] = None, confirmedAt: Option[java.sql.Timestamp] = None, confirmationSentAt: Option[java.sql.Timestamp] = None, unconfirmedEmail: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, salesforceId: Option[String] = None, domains: Option[String] = None, selections: Option[String] = None, oldUserAttributes: Option[String] = None, avatarFileName: Option[String] = None, avatarContentType: Option[String] = None, avatarFileSize: Option[Int] = None, avatarUpdatedAt: Option[java.sql.Timestamp] = None, memberId: Option[String] = None, testMember: Boolean = false, deviceBadge: Option[Int] = Some(0), lastActiveAt: Option[java.sql.Timestamp] = None, firstName: Option[String] = None, lastName: Option[String] = None, `type`: String, description: Option[String] = None, showToPublic: Option[Boolean] = Some(false), deactivated: Option[Boolean] = Some(false), integrationId: Option[String] = None, memberSince: Option[java.sql.Timestamp] = None, visitor: Option[Boolean] = Some(false), oldPrevAttrs: Option[String] = None, mobilePhone: Option[String] = None, cardId: Option[String] = None, memberClassId: Option[Int] = None, messengerId: String = ""): MembersRow = {
    id :: email :: encryptedPassword :: resetPasswordToken :: resetPasswordSentAt :: rememberCreatedAt :: signInCount :: currentSignInAt :: lastSignInAt :: currentSignInIp :: lastSignInIp :: confirmationToken :: confirmedAt :: confirmationSentAt :: unconfirmedEmail :: createdAt :: updatedAt :: salesforceId :: domains :: selections :: oldUserAttributes :: avatarFileName :: avatarContentType :: avatarFileSize :: avatarUpdatedAt :: memberId :: testMember :: deviceBadge :: lastActiveAt :: firstName :: lastName :: `type` :: description :: showToPublic :: deactivated :: integrationId :: memberSince :: visitor :: oldPrevAttrs :: mobilePhone :: cardId :: memberClassId :: messengerId :: HNil
  }

  /** GetResult implicit for fetching MembersRow objects using plain SQL queries */
  implicit def GetResultMembersRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Int]], e5: GR[Boolean], e6: GR[Option[Boolean]]): GR[MembersRow] = GR{
    prs => import prs._
    <<[Int] :: <<[String] :: <<[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<[Boolean] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<[String] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<[String] :: HNil
  }
  /** Table description of table members. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Members(_tableTag: Tag) extends Table[MembersRow](_tableTag, "members") {
    def * = id :: email :: encryptedPassword :: resetPasswordToken :: resetPasswordSentAt :: rememberCreatedAt :: signInCount :: currentSignInAt :: lastSignInAt :: currentSignInIp :: lastSignInIp :: confirmationToken :: confirmedAt :: confirmationSentAt :: unconfirmedEmail :: createdAt :: updatedAt :: salesforceId :: domains :: selections :: oldUserAttributes :: avatarFileName :: avatarContentType :: avatarFileSize :: avatarUpdatedAt :: memberId :: testMember :: deviceBadge :: lastActiveAt :: firstName :: lastName :: `type` :: description :: showToPublic :: deactivated :: integrationId :: memberSince :: visitor :: oldPrevAttrs :: mobilePhone :: cardId :: memberClassId :: messengerId :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column email SqlType(VARCHAR), Length(255,true), Default() */
    val email: Rep[String] = column[String]("email", O.Length(255,varying=true), O.Default(""))
    /** Database column encrypted_password SqlType(VARCHAR), Length(255,true), Default() */
    val encryptedPassword: Rep[String] = column[String]("encrypted_password", O.Length(255,varying=true), O.Default(""))
    /** Database column reset_password_token SqlType(VARCHAR), Length(255,true), Default(None) */
    val resetPasswordToken: Rep[Option[String]] = column[Option[String]]("reset_password_token", O.Length(255,varying=true), O.Default(None))
    /** Database column reset_password_sent_at SqlType(DATETIME), Default(None) */
    val resetPasswordSentAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("reset_password_sent_at", O.Default(None))
    /** Database column remember_created_at SqlType(DATETIME), Default(None) */
    val rememberCreatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("remember_created_at", O.Default(None))
    /** Database column sign_in_count SqlType(INT), Default(0) */
    val signInCount: Rep[Int] = column[Int]("sign_in_count", O.Default(0))
    /** Database column current_sign_in_at SqlType(DATETIME), Default(None) */
    val currentSignInAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("current_sign_in_at", O.Default(None))
    /** Database column last_sign_in_at SqlType(DATETIME), Default(None) */
    val lastSignInAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("last_sign_in_at", O.Default(None))
    /** Database column current_sign_in_ip SqlType(VARCHAR), Length(255,true), Default(None) */
    val currentSignInIp: Rep[Option[String]] = column[Option[String]]("current_sign_in_ip", O.Length(255,varying=true), O.Default(None))
    /** Database column last_sign_in_ip SqlType(VARCHAR), Length(255,true), Default(None) */
    val lastSignInIp: Rep[Option[String]] = column[Option[String]]("last_sign_in_ip", O.Length(255,varying=true), O.Default(None))
    /** Database column confirmation_token SqlType(VARCHAR), Length(255,true), Default(None) */
    val confirmationToken: Rep[Option[String]] = column[Option[String]]("confirmation_token", O.Length(255,varying=true), O.Default(None))
    /** Database column confirmed_at SqlType(DATETIME), Default(None) */
    val confirmedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("confirmed_at", O.Default(None))
    /** Database column confirmation_sent_at SqlType(DATETIME), Default(None) */
    val confirmationSentAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("confirmation_sent_at", O.Default(None))
    /** Database column unconfirmed_email SqlType(VARCHAR), Length(255,true), Default(None) */
    val unconfirmedEmail: Rep[Option[String]] = column[Option[String]]("unconfirmed_email", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column salesforce_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val salesforceId: Rep[Option[String]] = column[Option[String]]("salesforce_id", O.Length(50,varying=true), O.Default(None))
    /** Database column domains SqlType(TEXT), Default(None) */
    val domains: Rep[Option[String]] = column[Option[String]]("domains", O.Default(None))
    /** Database column selections SqlType(TEXT), Default(None) */
    val selections: Rep[Option[String]] = column[Option[String]]("selections", O.Default(None))
    /** Database column old_user_attributes SqlType(TEXT), Default(None) */
    val oldUserAttributes: Rep[Option[String]] = column[Option[String]]("old_user_attributes", O.Default(None))
    /** Database column avatar_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val avatarFileName: Rep[Option[String]] = column[Option[String]]("avatar_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column avatar_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val avatarContentType: Rep[Option[String]] = column[Option[String]]("avatar_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column avatar_file_size SqlType(INT), Default(None) */
    val avatarFileSize: Rep[Option[Int]] = column[Option[Int]]("avatar_file_size", O.Default(None))
    /** Database column avatar_updated_at SqlType(DATETIME), Default(None) */
    val avatarUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("avatar_updated_at", O.Default(None))
    /** Database column member_id SqlType(VARCHAR), Length(100,true), Default(None) */
    val memberId: Rep[Option[String]] = column[Option[String]]("member_id", O.Length(100,varying=true), O.Default(None))
    /** Database column test_member SqlType(BIT), Default(false) */
    val testMember: Rep[Boolean] = column[Boolean]("test_member", O.Default(false))
    /** Database column device_badge SqlType(INT), Default(Some(0)) */
    val deviceBadge: Rep[Option[Int]] = column[Option[Int]]("device_badge", O.Default(Some(0)))
    /** Database column last_active_at SqlType(DATETIME), Default(None) */
    val lastActiveAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("last_active_at", O.Default(None))
    /** Database column first_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val firstName: Rep[Option[String]] = column[Option[String]]("first_name", O.Length(255,varying=true), O.Default(None))
    /** Database column last_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val lastName: Rep[Option[String]] = column[Option[String]]("last_name", O.Length(255,varying=true), O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(50,true)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[String] = column[String]("type", O.Length(50,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))
    /** Database column deactivated SqlType(BIT), Default(Some(false)) */
    val deactivated: Rep[Option[Boolean]] = column[Option[Boolean]]("deactivated", O.Default(Some(false)))
    /** Database column integration_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val integrationId: Rep[Option[String]] = column[Option[String]]("integration_id", O.Length(255,varying=true), O.Default(None))
    /** Database column member_since SqlType(DATETIME), Default(None) */
    val memberSince: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("member_since", O.Default(None))
    /** Database column visitor SqlType(BIT), Default(Some(false)) */
    val visitor: Rep[Option[Boolean]] = column[Option[Boolean]]("visitor", O.Default(Some(false)))
    /** Database column old_prev_attrs SqlType(TEXT), Default(None) */
    val oldPrevAttrs: Rep[Option[String]] = column[Option[String]]("old_prev_attrs", O.Default(None))
    /** Database column mobile_phone SqlType(VARCHAR), Length(255,true), Default(None) */
    val mobilePhone: Rep[Option[String]] = column[Option[String]]("mobile_phone", O.Length(255,varying=true), O.Default(None))
    /** Database column card_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val cardId: Rep[Option[String]] = column[Option[String]]("card_id", O.Length(255,varying=true), O.Default(None))
    /** Database column member_class_id SqlType(INT), Default(None) */
    val memberClassId: Rep[Option[Int]] = column[Option[Int]]("member_class_id", O.Default(None))
    /** Database column messenger_id SqlType(VARCHAR), Length(255,true), Default() */
    val messengerId: Rep[String] = column[String]("messenger_id", O.Length(255,varying=true), O.Default(""))

    /** Uniqueness Index over (cardId) (database name index_members_on_card_id) */
    val index1 = index("index_members_on_card_id", cardId :: HNil, unique=true)
    /** Uniqueness Index over (confirmationToken) (database name index_members_on_confirmation_token) */
    val index2 = index("index_members_on_confirmation_token", confirmationToken :: HNil, unique=true)
    /** Index over (email) (database name index_members_on_email) */
    val index3 = index("index_members_on_email", email :: HNil)
    /** Index over (firstName) (database name index_members_on_first_name) */
    val index4 = index("index_members_on_first_name", firstName :: HNil)
    /** Uniqueness Index over (integrationId) (database name index_members_on_integration_id) */
    val index5 = index("index_members_on_integration_id", integrationId :: HNil, unique=true)
    /** Index over (lastName) (database name index_members_on_last_name) */
    val index6 = index("index_members_on_last_name", lastName :: HNil)
    /** Index over (memberClassId) (database name index_members_on_member_class_id) */
    val index7 = index("index_members_on_member_class_id", memberClassId :: HNil)
    /** Uniqueness Index over (memberId) (database name index_members_on_member_id) */
    val index8 = index("index_members_on_member_id", memberId :: HNil, unique=true)
    /** Index over (mobilePhone) (database name index_members_on_mobile_phone) */
    val index9 = index("index_members_on_mobile_phone", mobilePhone :: HNil)
    /** Uniqueness Index over (resetPasswordToken) (database name index_members_on_reset_password_token) */
    val index10 = index("index_members_on_reset_password_token", resetPasswordToken :: HNil, unique=true)
    /** Index over (salesforceId) (database name index_members_on_salesforce_id) */
    val index11 = index("index_members_on_salesforce_id", salesforceId :: HNil)
  }
  /** Collection-like TableQuery object for table Members */
  lazy val Members = new TableQuery(tag => new Members(tag))

  /** Entity class storing rows of table MessageActions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param messageId Database column message_id SqlType(INT), Default(None)
   *  @param deliveredAt Database column delivered_at SqlType(DATETIME), Default(None)
   *  @param openedAt Database column opened_at SqlType(DATETIME), Default(None)
   *  @param clickedAt Database column clicked_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param sentAt Database column sent_at SqlType(DATETIME), Default(None)
   *  @param bouncedAt Database column bounced_at SqlType(DATETIME), Default(None)
   *  @param flaggedAt Database column flagged_at SqlType(DATETIME), Default(None)
   *  @param droppedAt Database column dropped_at SqlType(DATETIME), Default(None)
   *  @param respondedAt Database column responded_at SqlType(DATETIME), Default(None)
   *  @param batchId Database column batch_id SqlType(VARCHAR), Length(255,true), Default(None) */
  case class MessageActionsRow(id: Int, memberId: Option[Int] = None, messageId: Option[Int] = None, deliveredAt: Option[java.sql.Timestamp] = None, openedAt: Option[java.sql.Timestamp] = None, clickedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, sentAt: Option[java.sql.Timestamp] = None, bouncedAt: Option[java.sql.Timestamp] = None, flaggedAt: Option[java.sql.Timestamp] = None, droppedAt: Option[java.sql.Timestamp] = None, respondedAt: Option[java.sql.Timestamp] = None, batchId: Option[String] = None)
  /** GetResult implicit for fetching MessageActionsRow objects using plain SQL queries */
  implicit def GetResultMessageActionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]]): GR[MessageActionsRow] = GR{
    prs => import prs._
    MessageActionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table message_actions. Objects of this class serve as prototypes for rows in queries. */
  class MessageActions(_tableTag: Tag) extends Table[MessageActionsRow](_tableTag, "message_actions") {
    def * = (id, memberId, messageId, deliveredAt, openedAt, clickedAt, createdAt, updatedAt, sentAt, bouncedAt, flaggedAt, droppedAt, respondedAt, batchId) <> (MessageActionsRow.tupled, MessageActionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, messageId, deliveredAt, openedAt, clickedAt, createdAt, updatedAt, sentAt, bouncedAt, flaggedAt, droppedAt, respondedAt, batchId).shaped.<>({r=>import r._; _1.map(_=> MessageActionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column message_id SqlType(INT), Default(None) */
    val messageId: Rep[Option[Int]] = column[Option[Int]]("message_id", O.Default(None))
    /** Database column delivered_at SqlType(DATETIME), Default(None) */
    val deliveredAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("delivered_at", O.Default(None))
    /** Database column opened_at SqlType(DATETIME), Default(None) */
    val openedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("opened_at", O.Default(None))
    /** Database column clicked_at SqlType(DATETIME), Default(None) */
    val clickedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("clicked_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column sent_at SqlType(DATETIME), Default(None) */
    val sentAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("sent_at", O.Default(None))
    /** Database column bounced_at SqlType(DATETIME), Default(None) */
    val bouncedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("bounced_at", O.Default(None))
    /** Database column flagged_at SqlType(DATETIME), Default(None) */
    val flaggedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("flagged_at", O.Default(None))
    /** Database column dropped_at SqlType(DATETIME), Default(None) */
    val droppedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("dropped_at", O.Default(None))
    /** Database column responded_at SqlType(DATETIME), Default(None) */
    val respondedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("responded_at", O.Default(None))
    /** Database column batch_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val batchId: Rep[Option[String]] = column[Option[String]]("batch_id", O.Length(255,varying=true), O.Default(None))

    /** Uniqueness Index over (memberId,messageId,batchId) (database name index_message_actions_on_member_id_and_message_id_and_batch_id) */
    val index1 = index("index_message_actions_on_member_id_and_message_id_and_batch_id", (memberId, messageId, batchId), unique=true)
    /** Index over (messageId) (database name index_message_actions_on_message_id) */
    val index2 = index("index_message_actions_on_message_id", messageId)
  }
  /** Collection-like TableQuery object for table MessageActions */
  lazy val MessageActions = new TableQuery(tag => new MessageActions(tag))

  /** Entity class storing rows of table MessageLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param messageId Database column message_id SqlType(INT), Default(None)
   *  @param locationId Database column location_id SqlType(INT), Default(None)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(false))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class MessageLocationsRow(id: Int, messageId: Option[Int] = None, locationId: Option[Int] = None, locationType: Option[String] = None, included: Option[Boolean] = Some(false), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching MessageLocationsRow objects using plain SQL queries */
  implicit def GetResultMessageLocationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]], e4: GR[Option[java.sql.Timestamp]]): GR[MessageLocationsRow] = GR{
    prs => import prs._
    MessageLocationsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table message_locations. Objects of this class serve as prototypes for rows in queries. */
  class MessageLocations(_tableTag: Tag) extends Table[MessageLocationsRow](_tableTag, "message_locations") {
    def * = (id, messageId, locationId, locationType, included, createdAt, updatedAt) <> (MessageLocationsRow.tupled, MessageLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), messageId, locationId, locationType, included, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> MessageLocationsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column message_id SqlType(INT), Default(None) */
    val messageId: Rep[Option[Int]] = column[Option[Int]]("message_id", O.Default(None))
    /** Database column location_id SqlType(INT), Default(None) */
    val locationId: Rep[Option[Int]] = column[Option[Int]]("location_id", O.Default(None))
    /** Database column location_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val locationType: Rep[Option[String]] = column[Option[String]]("location_type", O.Length(25,varying=true), O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(false)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(false)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (locationId) (database name index_message_locations_on_location_id) */
    val index1 = index("index_message_locations_on_location_id", locationId)
    /** Uniqueness Index over (messageId,locationId) (database name index_message_locations_on_message_id_and_location_id) */
    val index2 = index("index_message_locations_on_message_id_and_location_id", (messageId, locationId), unique=true)
  }
  /** Collection-like TableQuery object for table MessageLocations */
  lazy val MessageLocations = new TableQuery(tag => new MessageLocations(tag))

  /** Entity class storing rows of table MessageResponses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param messageId Database column message_id SqlType(INT), Default(None)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param activity Database column activity SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param content Database column content SqlType(TEXT), Default(None)
   *  @param pushTargetableId Database column push_targetable_id SqlType(INT), Default(None)
   *  @param pushTargetableType Database column push_targetable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param actorId Database column actor_id SqlType(INT), Default(None)
   *  @param actorType Database column actor_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param messageActionId Database column message_action_id SqlType(INT), Default(None) */
  case class MessageResponsesRow(id: Int, messageId: Option[Int] = None, memberId: Option[Int] = None, activity: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, content: Option[String] = None, pushTargetableId: Option[Int] = None, pushTargetableType: Option[String] = None, actorId: Option[Int] = None, actorType: Option[String] = None, messageActionId: Option[Int] = None)
  /** GetResult implicit for fetching MessageResponsesRow objects using plain SQL queries */
  implicit def GetResultMessageResponsesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[MessageResponsesRow] = GR{
    prs => import prs._
    MessageResponsesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[Int]))
  }
  /** Table description of table message_responses. Objects of this class serve as prototypes for rows in queries. */
  class MessageResponses(_tableTag: Tag) extends Table[MessageResponsesRow](_tableTag, "message_responses") {
    def * = (id, messageId, memberId, activity, createdAt, updatedAt, content, pushTargetableId, pushTargetableType, actorId, actorType, messageActionId) <> (MessageResponsesRow.tupled, MessageResponsesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), messageId, memberId, activity, createdAt, updatedAt, content, pushTargetableId, pushTargetableType, actorId, actorType, messageActionId).shaped.<>({r=>import r._; _1.map(_=> MessageResponsesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column message_id SqlType(INT), Default(None) */
    val messageId: Rep[Option[Int]] = column[Option[Int]]("message_id", O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column activity SqlType(VARCHAR), Length(25,true), Default(None) */
    val activity: Rep[Option[String]] = column[Option[String]]("activity", O.Length(25,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column content SqlType(TEXT), Default(None) */
    val content: Rep[Option[String]] = column[Option[String]]("content", O.Default(None))
    /** Database column push_targetable_id SqlType(INT), Default(None) */
    val pushTargetableId: Rep[Option[Int]] = column[Option[Int]]("push_targetable_id", O.Default(None))
    /** Database column push_targetable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val pushTargetableType: Rep[Option[String]] = column[Option[String]]("push_targetable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column actor_id SqlType(INT), Default(None) */
    val actorId: Rep[Option[Int]] = column[Option[Int]]("actor_id", O.Default(None))
    /** Database column actor_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val actorType: Rep[Option[String]] = column[Option[String]]("actor_type", O.Length(255,varying=true), O.Default(None))
    /** Database column message_action_id SqlType(INT), Default(None) */
    val messageActionId: Rep[Option[Int]] = column[Option[Int]]("message_action_id", O.Default(None))

    /** Index over (memberId,messageId) (database name index_message_responses_on_member_id_and_message_id) */
    val index1 = index("index_message_responses_on_member_id_and_message_id", (memberId, messageId))
    /** Index over (messageId) (database name index_message_responses_on_message_id) */
    val index2 = index("index_message_responses_on_message_id", messageId)
  }
  /** Collection-like TableQuery object for table MessageResponses */
  lazy val MessageResponses = new TableQuery(tag => new MessageResponses(tag))

  /** Row type of table Messages */
  type MessagesRow = HCons[Int,HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[String,HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[String,HCons[Option[java.sql.Timestamp],HCons[String,HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for MessagesRow providing default values if available in the database schema. */
  def MessagesRow(id: Int, name: Option[String] = None, description: Option[String] = None, categories: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, text: Option[String] = None, messageStatus: Option[String] = None, sentDate: Option[java.sql.Timestamp] = None, scheduledDate: Option[java.sql.Timestamp] = None, `type`: Option[String] = None, targetableId: Option[Int] = None, targetableType: Option[String] = None, label: String, sendMethod: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, templateSetVersionId: Option[Int] = Some(0), triggered: Option[Boolean] = Some(false), operational: Option[Boolean] = Some(false), sendToVisitors: Option[Boolean] = Some(false), campaignId: Option[Int] = None, dispatchedVia: Option[String] = None, sendMode: Option[String] = Some("manual"), status: String = "draft", publishedAt: Option[java.sql.Timestamp] = None, sendStatus: String = "not sent", triggerActivityType: Option[String] = None): MessagesRow = {
    id :: name :: description :: categories :: createdAt :: updatedAt :: text :: messageStatus :: sentDate :: scheduledDate :: `type` :: targetableId :: targetableType :: label :: sendMethod :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: templateSetVersionId :: triggered :: operational :: sendToVisitors :: campaignId :: dispatchedVia :: sendMode :: status :: publishedAt :: sendStatus :: triggerActivityType :: HNil
  }
  /** GetResult implicit for fetching MessagesRow objects using plain SQL queries */
  implicit def GetResultMessagesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]], e4: GR[String], e5: GR[Option[Boolean]]): GR[MessagesRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<[String] :: <<?[String] :: HNil
  }
  /** Table description of table messages. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Messages(_tableTag: Tag) extends Table[MessagesRow](_tableTag, "messages") {
    def * = id :: name :: description :: categories :: createdAt :: updatedAt :: text :: messageStatus :: sentDate :: scheduledDate :: `type` :: targetableId :: targetableType :: label :: sendMethod :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: templateSetVersionId :: triggered :: operational :: sendToVisitors :: campaignId :: dispatchedVia :: sendMode :: status :: publishedAt :: sendStatus :: triggerActivityType :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column categories SqlType(VARCHAR), Length(255,true), Default(None) */
    val categories: Rep[Option[String]] = column[Option[String]]("categories", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column text SqlType(TEXT), Default(None) */
    val text: Rep[Option[String]] = column[Option[String]]("text", O.Default(None))
    /** Database column message_status SqlType(VARCHAR), Length(50,true), Default(None) */
    val messageStatus: Rep[Option[String]] = column[Option[String]]("message_status", O.Length(50,varying=true), O.Default(None))
    /** Database column sent_date SqlType(DATETIME), Default(None) */
    val sentDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("sent_date", O.Default(None))
    /** Database column scheduled_date SqlType(DATETIME), Default(None) */
    val scheduledDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("scheduled_date", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column targetable_id SqlType(INT), Default(None) */
    val targetableId: Rep[Option[Int]] = column[Option[Int]]("targetable_id", O.Default(None))
    /** Database column targetable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val targetableType: Rep[Option[String]] = column[Option[String]]("targetable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column send_method SqlType(VARCHAR), Length(20,true), Default(None) */
    val sendMethod: Rep[Option[String]] = column[Option[String]]("send_method", O.Length(20,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
    /** Database column triggered SqlType(BIT), Default(Some(false)) */
    val triggered: Rep[Option[Boolean]] = column[Option[Boolean]]("triggered", O.Default(Some(false)))
    /** Database column operational SqlType(BIT), Default(Some(false)) */
    val operational: Rep[Option[Boolean]] = column[Option[Boolean]]("operational", O.Default(Some(false)))
    /** Database column send_to_visitors SqlType(BIT), Default(Some(false)) */
    val sendToVisitors: Rep[Option[Boolean]] = column[Option[Boolean]]("send_to_visitors", O.Default(Some(false)))
    /** Database column campaign_id SqlType(INT), Default(None) */
    val campaignId: Rep[Option[Int]] = column[Option[Int]]("campaign_id", O.Default(None))
    /** Database column dispatched_via SqlType(VARCHAR), Length(255,true), Default(None) */
    val dispatchedVia: Rep[Option[String]] = column[Option[String]]("dispatched_via", O.Length(255,varying=true), O.Default(None))
    /** Database column send_mode SqlType(VARCHAR), Length(20,true), Default(Some(manual)) */
    val sendMode: Rep[Option[String]] = column[Option[String]]("send_mode", O.Length(20,varying=true), O.Default(Some("manual")))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column send_status SqlType(VARCHAR), Length(20,true), Default(not sent) */
    val sendStatus: Rep[String] = column[String]("send_status", O.Length(20,varying=true), O.Default("not sent"))
    /** Database column trigger_activity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val triggerActivityType: Rep[Option[String]] = column[Option[String]]("trigger_activity_type", O.Length(255,varying=true), O.Default(None))

    /** Index over (campaignId) (database name index_messages_on_campaign_id) */
    val index1 = index("index_messages_on_campaign_id", campaignId :: HNil)
    /** Index over (name) (database name index_messages_on_name) */
    val index2 = index("index_messages_on_name", name :: HNil)
    /** Index over (targetableId) (database name index_messages_on_targetable_id) */
    val index3 = index("index_messages_on_targetable_id", targetableId :: HNil)
    /** Index over (templateSetVersionId) (database name index_messages_on_template_set_version_id) */
    val index4 = index("index_messages_on_template_set_version_id", templateSetVersionId :: HNil)
  }
  /** Collection-like TableQuery object for table Messages */
  lazy val Messages = new TableQuery(tag => new Messages(tag))

  /** Entity class storing rows of table MessageSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param messageId Database column message_id SqlType(INT), Default(None)
   *  @param segmentId Database column segment_id SqlType(INT), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(true))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class MessageSegmentsRow(id: Int, messageId: Option[Int] = None, segmentId: Option[Int] = None, included: Option[Boolean] = Some(true), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching MessageSegmentsRow objects using plain SQL queries */
  implicit def GetResultMessageSegmentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[Boolean]], e3: GR[Option[java.sql.Timestamp]]): GR[MessageSegmentsRow] = GR{
    prs => import prs._
    MessageSegmentsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table message_segments. Objects of this class serve as prototypes for rows in queries. */
  class MessageSegments(_tableTag: Tag) extends Table[MessageSegmentsRow](_tableTag, "message_segments") {
    def * = (id, messageId, segmentId, included, createdAt, updatedAt) <> (MessageSegmentsRow.tupled, MessageSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), messageId, segmentId, included, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> MessageSegmentsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column message_id SqlType(INT), Default(None) */
    val messageId: Rep[Option[Int]] = column[Option[Int]]("message_id", O.Default(None))
    /** Database column segment_id SqlType(INT), Default(None) */
    val segmentId: Rep[Option[Int]] = column[Option[Int]]("segment_id", O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(true)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(true)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (messageId,segmentId) (database name index_message_segments_on_message_id_and_segment_id) */
    val index1 = index("index_message_segments_on_message_id_and_segment_id", (messageId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_message_segments_on_segment_id) */
    val index2 = index("index_message_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table MessageSegments */
  lazy val MessageSegments = new TableQuery(tag => new MessageSegments(tag))

  /** Entity class storing rows of table Metrics
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(100,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param kind Database column kind SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param programId Database column program_id SqlType(INT)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(10,true), Default(None)
   *  @param decimalPlace Database column decimal_place SqlType(INT), Default(Some(0))
   *  @param expirable Database column expirable SqlType(BIT), Default(None) */
  case class MetricsRow(id: Int, name: String, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, kind: Option[String] = None, programId: Int, label: Option[String] = None, code: Option[String] = None, decimalPlace: Option[Int] = Some(0), expirable: Option[Boolean] = None)
  /** GetResult implicit for fetching MetricsRow objects using plain SQL queries */
  implicit def GetResultMetricsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Int]], e5: GR[Option[Boolean]]): GR[MetricsRow] = GR{
    prs => import prs._
    MetricsRow.tupled((<<[Int], <<[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<[Int], <<?[String], <<?[String], <<?[Int], <<?[Boolean]))
  }
  /** Table description of table metrics. Objects of this class serve as prototypes for rows in queries. */
  class Metrics(_tableTag: Tag) extends Table[MetricsRow](_tableTag, "metrics") {
    def * = (id, name, description, createdAt, updatedAt, kind, programId, label, code, decimalPlace, expirable) <> (MetricsRow.tupled, MetricsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), description, createdAt, updatedAt, kind, Rep.Some(programId), label, code, decimalPlace, expirable).shaped.<>({r=>import r._; _1.map(_=> MetricsRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7.get, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(100,true) */
    val name: Rep[String] = column[String]("name", O.Length(100,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column kind SqlType(VARCHAR), Length(255,true), Default(None) */
    val kind: Rep[Option[String]] = column[Option[String]]("kind", O.Length(255,varying=true), O.Default(None))
    /** Database column program_id SqlType(INT) */
    val programId: Rep[Int] = column[Int]("program_id")
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(10,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(10,varying=true), O.Default(None))
    /** Database column decimal_place SqlType(INT), Default(Some(0)) */
    val decimalPlace: Rep[Option[Int]] = column[Option[Int]]("decimal_place", O.Default(Some(0)))
    /** Database column expirable SqlType(BIT), Default(None) */
    val expirable: Rep[Option[Boolean]] = column[Option[Boolean]]("expirable", O.Default(None))

    /** Uniqueness Index over (name) (database name index_metrics_on_name) */
    val index1 = index("index_metrics_on_name", name, unique=true)
  }
  /** Collection-like TableQuery object for table Metrics */
  lazy val Metrics = new TableQuery(tag => new Metrics(tag))

  /** Entity class storing rows of table NewsFeedLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param newsFeedId Database column news_feed_id SqlType(INT)
   *  @param locationId Database column location_id SqlType(INT)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(255,true)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class NewsFeedLocationsRow(id: Int, newsFeedId: Int, locationId: Int, locationType: String, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching NewsFeedLocationsRow objects using plain SQL queries */
  implicit def GetResultNewsFeedLocationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Boolean], e3: GR[Option[java.sql.Timestamp]]): GR[NewsFeedLocationsRow] = GR{
    prs => import prs._
    NewsFeedLocationsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table news_feed_locations. Objects of this class serve as prototypes for rows in queries. */
  class NewsFeedLocations(_tableTag: Tag) extends Table[NewsFeedLocationsRow](_tableTag, "news_feed_locations") {
    def * = (id, newsFeedId, locationId, locationType, included, createdAt, updatedAt) <> (NewsFeedLocationsRow.tupled, NewsFeedLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(newsFeedId), Rep.Some(locationId), Rep.Some(locationType), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> NewsFeedLocationsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column news_feed_id SqlType(INT) */
    val newsFeedId: Rep[Int] = column[Int]("news_feed_id")
    /** Database column location_id SqlType(INT) */
    val locationId: Rep[Int] = column[Int]("location_id")
    /** Database column location_type SqlType(VARCHAR), Length(255,true) */
    val locationType: Rep[String] = column[String]("location_type", O.Length(255,varying=true))
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (locationId) (database name index_news_feed_locations_on_location_id) */
    val index1 = index("index_news_feed_locations_on_location_id", locationId)
    /** Uniqueness Index over (newsFeedId,locationId) (database name index_news_feed_locations_on_news_feed_id_and_location_id) */
    val index2 = index("index_news_feed_locations_on_news_feed_id_and_location_id", (newsFeedId, locationId), unique=true)
  }
  /** Collection-like TableQuery object for table NewsFeedLocations */
  lazy val NewsFeedLocations = new TableQuery(tag => new NewsFeedLocations(tag))

  /** Entity class storing rows of table NewsFeeds
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param tag Database column tag SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param showToPublic Database column show_to_public SqlType(BIT), Default(Some(false))
   *  @param settings Database column settings SqlType(TEXT), Default(None) */
  case class NewsFeedsRow(id: Int, name: Option[String] = None, tag: Option[String] = None, description: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Option[Int] = None, label: String, showToPublic: Option[Boolean] = Some(false), settings: Option[String] = None)
  /** GetResult implicit for fetching NewsFeedsRow objects using plain SQL queries */
  implicit def GetResultNewsFeedsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String], e5: GR[Option[Boolean]]): GR[NewsFeedsRow] = GR{
    prs => import prs._
    NewsFeedsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<[String], <<?[Boolean], <<?[String]))
  }
  /** Table description of table news_feeds. Objects of this class serve as prototypes for rows in queries. */
  class NewsFeeds(_tableTag: Tag) extends Table[NewsFeedsRow](_tableTag, "news_feeds") {
    def * = (id, name, tag, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt, programId, label, showToPublic, settings) <> (NewsFeedsRow.tupled, NewsFeedsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, tag, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt, programId, Rep.Some(label), showToPublic, settings).shaped.<>({r=>import r._; _1.map(_=> NewsFeedsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12.get, _13, _14)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column tag SqlType(VARCHAR), Length(255,true), Default(None) */
    val tag: Rep[Option[String]] = column[Option[String]]("tag", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))
    /** Database column settings SqlType(TEXT), Default(None) */
    val settings: Rep[Option[String]] = column[Option[String]]("settings", O.Default(None))
  }
  /** Collection-like TableQuery object for table NewsFeeds */
  lazy val NewsFeeds = new TableQuery(tag => new NewsFeeds(tag))

  /** Entity class storing rows of table NewsFeedSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param newsFeedId Database column news_feed_id SqlType(INT)
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class NewsFeedSegmentsRow(id: Int, newsFeedId: Int, segmentId: Int, included: Boolean = true, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching NewsFeedSegmentsRow objects using plain SQL queries */
  implicit def GetResultNewsFeedSegmentsRow(implicit e0: GR[Int], e1: GR[Boolean], e2: GR[Option[java.sql.Timestamp]]): GR[NewsFeedSegmentsRow] = GR{
    prs => import prs._
    NewsFeedSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table news_feed_segments. Objects of this class serve as prototypes for rows in queries. */
  class NewsFeedSegments(_tableTag: Tag) extends Table[NewsFeedSegmentsRow](_tableTag, "news_feed_segments") {
    def * = (id, newsFeedId, segmentId, included, createdAt, updatedAt) <> (NewsFeedSegmentsRow.tupled, NewsFeedSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(newsFeedId), Rep.Some(segmentId), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> NewsFeedSegmentsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column news_feed_id SqlType(INT) */
    val newsFeedId: Rep[Int] = column[Int]("news_feed_id")
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column included SqlType(BIT), Default(true) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (newsFeedId,segmentId) (database name index_news_feed_segments_on_news_feed_id_and_segment_id) */
    val index1 = index("index_news_feed_segments_on_news_feed_id_and_segment_id", (newsFeedId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_news_feed_segments_on_segment_id) */
    val index2 = index("index_news_feed_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table NewsFeedSegments */
  lazy val NewsFeedSegments = new TableQuery(tag => new NewsFeedSegments(tag))

  /** Entity class storing rows of table OauthAccessGrants
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param resourceOwnerId Database column resource_owner_id SqlType(INT)
   *  @param applicationId Database column application_id SqlType(INT)
   *  @param token Database column token SqlType(VARCHAR), Length(255,true)
   *  @param expiresIn Database column expires_in SqlType(INT)
   *  @param redirectUri Database column redirect_uri SqlType(TEXT)
   *  @param createdAt Database column created_at SqlType(DATETIME)
   *  @param revokedAt Database column revoked_at SqlType(DATETIME), Default(None)
   *  @param scopes Database column scopes SqlType(VARCHAR), Length(255,true), Default(None) */
  case class OauthAccessGrantsRow(id: Int, resourceOwnerId: Int, applicationId: Int, token: String, expiresIn: Int, redirectUri: String, createdAt: java.sql.Timestamp, revokedAt: Option[java.sql.Timestamp] = None, scopes: Option[String] = None)
  /** GetResult implicit for fetching OauthAccessGrantsRow objects using plain SQL queries */
  implicit def GetResultOauthAccessGrantsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[java.sql.Timestamp], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[String]]): GR[OauthAccessGrantsRow] = GR{
    prs => import prs._
    OauthAccessGrantsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<[Int], <<[String], <<[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table oauth_access_grants. Objects of this class serve as prototypes for rows in queries. */
  class OauthAccessGrants(_tableTag: Tag) extends Table[OauthAccessGrantsRow](_tableTag, "oauth_access_grants") {
    def * = (id, resourceOwnerId, applicationId, token, expiresIn, redirectUri, createdAt, revokedAt, scopes) <> (OauthAccessGrantsRow.tupled, OauthAccessGrantsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(resourceOwnerId), Rep.Some(applicationId), Rep.Some(token), Rep.Some(expiresIn), Rep.Some(redirectUri), Rep.Some(createdAt), revokedAt, scopes).shaped.<>({r=>import r._; _1.map(_=> OauthAccessGrantsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6.get, _7.get, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column resource_owner_id SqlType(INT) */
    val resourceOwnerId: Rep[Int] = column[Int]("resource_owner_id")
    /** Database column application_id SqlType(INT) */
    val applicationId: Rep[Int] = column[Int]("application_id")
    /** Database column token SqlType(VARCHAR), Length(255,true) */
    val token: Rep[String] = column[String]("token", O.Length(255,varying=true))
    /** Database column expires_in SqlType(INT) */
    val expiresIn: Rep[Int] = column[Int]("expires_in")
    /** Database column redirect_uri SqlType(TEXT) */
    val redirectUri: Rep[String] = column[String]("redirect_uri")
    /** Database column created_at SqlType(DATETIME) */
    val createdAt: Rep[java.sql.Timestamp] = column[java.sql.Timestamp]("created_at")
    /** Database column revoked_at SqlType(DATETIME), Default(None) */
    val revokedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("revoked_at", O.Default(None))
    /** Database column scopes SqlType(VARCHAR), Length(255,true), Default(None) */
    val scopes: Rep[Option[String]] = column[Option[String]]("scopes", O.Length(255,varying=true), O.Default(None))

    /** Uniqueness Index over (token) (database name index_oauth_access_grants_on_token) */
    val index1 = index("index_oauth_access_grants_on_token", token, unique=true)
  }
  /** Collection-like TableQuery object for table OauthAccessGrants */
  lazy val OauthAccessGrants = new TableQuery(tag => new OauthAccessGrants(tag))

  /** Entity class storing rows of table OauthAccessTokens
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param resourceOwnerId Database column resource_owner_id SqlType(INT), Default(None)
   *  @param applicationId Database column application_id SqlType(INT), Default(None)
   *  @param token Database column token SqlType(VARCHAR), Length(255,true)
   *  @param refreshToken Database column refresh_token SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param expiresIn Database column expires_in SqlType(INT), Default(None)
   *  @param revokedAt Database column revoked_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME)
   *  @param scopes Database column scopes SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param locationId Database column location_id SqlType(INT), Default(None) */
  case class OauthAccessTokensRow(id: Int, resourceOwnerId: Option[Int] = None, applicationId: Option[Int] = None, token: String, refreshToken: Option[String] = None, expiresIn: Option[Int] = None, revokedAt: Option[java.sql.Timestamp] = None, createdAt: java.sql.Timestamp, scopes: Option[String] = None, locationId: Option[Int] = None)
  /** GetResult implicit for fetching OauthAccessTokensRow objects using plain SQL queries */
  implicit def GetResultOauthAccessTokensRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]], e5: GR[java.sql.Timestamp]): GR[OauthAccessTokensRow] = GR{
    prs => import prs._
    OauthAccessTokensRow.tupled((<<[Int], <<?[Int], <<?[Int], <<[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<[java.sql.Timestamp], <<?[String], <<?[Int]))
  }
  /** Table description of table oauth_access_tokens. Objects of this class serve as prototypes for rows in queries. */
  class OauthAccessTokens(_tableTag: Tag) extends Table[OauthAccessTokensRow](_tableTag, "oauth_access_tokens") {
    def * = (id, resourceOwnerId, applicationId, token, refreshToken, expiresIn, revokedAt, createdAt, scopes, locationId) <> (OauthAccessTokensRow.tupled, OauthAccessTokensRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), resourceOwnerId, applicationId, Rep.Some(token), refreshToken, expiresIn, revokedAt, Rep.Some(createdAt), scopes, locationId).shaped.<>({r=>import r._; _1.map(_=> OauthAccessTokensRow.tupled((_1.get, _2, _3, _4.get, _5, _6, _7, _8.get, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column resource_owner_id SqlType(INT), Default(None) */
    val resourceOwnerId: Rep[Option[Int]] = column[Option[Int]]("resource_owner_id", O.Default(None))
    /** Database column application_id SqlType(INT), Default(None) */
    val applicationId: Rep[Option[Int]] = column[Option[Int]]("application_id", O.Default(None))
    /** Database column token SqlType(VARCHAR), Length(255,true) */
    val token: Rep[String] = column[String]("token", O.Length(255,varying=true))
    /** Database column refresh_token SqlType(VARCHAR), Length(255,true), Default(None) */
    val refreshToken: Rep[Option[String]] = column[Option[String]]("refresh_token", O.Length(255,varying=true), O.Default(None))
    /** Database column expires_in SqlType(INT), Default(None) */
    val expiresIn: Rep[Option[Int]] = column[Option[Int]]("expires_in", O.Default(None))
    /** Database column revoked_at SqlType(DATETIME), Default(None) */
    val revokedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("revoked_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME) */
    val createdAt: Rep[java.sql.Timestamp] = column[java.sql.Timestamp]("created_at")
    /** Database column scopes SqlType(VARCHAR), Length(255,true), Default(None) */
    val scopes: Rep[Option[String]] = column[Option[String]]("scopes", O.Length(255,varying=true), O.Default(None))
    /** Database column location_id SqlType(INT), Default(None) */
    val locationId: Rep[Option[Int]] = column[Option[Int]]("location_id", O.Default(None))

    /** Uniqueness Index over (refreshToken) (database name index_oauth_access_tokens_on_refresh_token) */
    val index1 = index("index_oauth_access_tokens_on_refresh_token", refreshToken, unique=true)
    /** Index over (resourceOwnerId) (database name index_oauth_access_tokens_on_resource_owner_id) */
    val index2 = index("index_oauth_access_tokens_on_resource_owner_id", resourceOwnerId)
    /** Uniqueness Index over (token) (database name index_oauth_access_tokens_on_token) */
    val index3 = index("index_oauth_access_tokens_on_token", token, unique=true)
  }
  /** Collection-like TableQuery object for table OauthAccessTokens */
  lazy val OauthAccessTokens = new TableQuery(tag => new OauthAccessTokens(tag))

  /** Entity class storing rows of table OauthApplications
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param uid Database column uid SqlType(VARCHAR), Length(255,true)
   *  @param secret Database column secret SqlType(VARCHAR), Length(255,true)
   *  @param redirectUri Database column redirect_uri SqlType(TEXT)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param scopes Database column scopes SqlType(VARCHAR), Length(255,true), Default(member)
   *  @param clientPlatformType Database column client_platform_type SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None) */
  case class OauthApplicationsRow(id: Int, name: String, uid: String, secret: String, redirectUri: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, scopes: String = "member", clientPlatformType: Option[String] = None, label: Option[String] = None, description: Option[String] = None)
  /** GetResult implicit for fetching OauthApplicationsRow objects using plain SQL queries */
  implicit def GetResultOauthApplicationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]]): GR[OauthApplicationsRow] = GR{
    prs => import prs._
    OauthApplicationsRow.tupled((<<[Int], <<[String], <<[String], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[String], <<?[String], <<?[String], <<?[String]))
  }
  /** Table description of table oauth_applications. Objects of this class serve as prototypes for rows in queries. */
  class OauthApplications(_tableTag: Tag) extends Table[OauthApplicationsRow](_tableTag, "oauth_applications") {
    def * = (id, name, uid, secret, redirectUri, createdAt, updatedAt, scopes, clientPlatformType, label, description) <> (OauthApplicationsRow.tupled, OauthApplicationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(uid), Rep.Some(secret), Rep.Some(redirectUri), createdAt, updatedAt, Rep.Some(scopes), clientPlatformType, label, description).shaped.<>({r=>import r._; _1.map(_=> OauthApplicationsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6, _7, _8.get, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column uid SqlType(VARCHAR), Length(255,true) */
    val uid: Rep[String] = column[String]("uid", O.Length(255,varying=true))
    /** Database column secret SqlType(VARCHAR), Length(255,true) */
    val secret: Rep[String] = column[String]("secret", O.Length(255,varying=true))
    /** Database column redirect_uri SqlType(TEXT) */
    val redirectUri: Rep[String] = column[String]("redirect_uri")
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column scopes SqlType(VARCHAR), Length(255,true), Default(member) */
    val scopes: Rep[String] = column[String]("scopes", O.Length(255,varying=true), O.Default("member"))
    /** Database column client_platform_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val clientPlatformType: Rep[Option[String]] = column[Option[String]]("client_platform_type", O.Length(25,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))

    /** Uniqueness Index over (uid) (database name index_oauth_applications_on_uid) */
    val index1 = index("index_oauth_applications_on_uid", uid, unique=true)
  }
  /** Collection-like TableQuery object for table OauthApplications */
  lazy val OauthApplications = new TableQuery(tag => new OauthApplications(tag))

  /** Entity class storing rows of table ObjectiveFactors
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param templateValues Database column template_values SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ObjectiveFactorsRow(id: Int, entityId: Option[Int] = None, entityType: Option[String] = None, `type`: Option[String] = None, templateValues: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ObjectiveFactorsRow objects using plain SQL queries */
  implicit def GetResultObjectiveFactorsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ObjectiveFactorsRow] = GR{
    prs => import prs._
    ObjectiveFactorsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table objective_factors. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class ObjectiveFactors(_tableTag: Tag) extends Table[ObjectiveFactorsRow](_tableTag, "objective_factors") {
    def * = (id, entityId, entityType, `type`, templateValues, createdAt, updatedAt) <> (ObjectiveFactorsRow.tupled, ObjectiveFactorsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), entityId, entityType, `type`, templateValues, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ObjectiveFactorsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column template_values SqlType(TEXT), Default(None) */
    val templateValues: Rep[Option[String]] = column[Option[String]]("template_values", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table ObjectiveFactors */
  lazy val ObjectiveFactors = new TableQuery(tag => new ObjectiveFactors(tag))

  /** Entity class storing rows of table OfferActions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param offerId Database column offer_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param viewedAt Database column viewed_at SqlType(DATETIME), Default(None)
   *  @param respondedAt Database column responded_at SqlType(DATETIME), Default(None) */
  case class OfferActionsRow(id: Int, memberId: Option[Int] = None, offerId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, viewedAt: Option[java.sql.Timestamp] = None, respondedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching OfferActionsRow objects using plain SQL queries */
  implicit def GetResultOfferActionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[OfferActionsRow] = GR{
    prs => import prs._
    OfferActionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table offer_actions. Objects of this class serve as prototypes for rows in queries. */
  class OfferActions(_tableTag: Tag) extends Table[OfferActionsRow](_tableTag, "offer_actions") {
    def * = (id, memberId, offerId, createdAt, updatedAt, viewedAt, respondedAt) <> (OfferActionsRow.tupled, OfferActionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, offerId, createdAt, updatedAt, viewedAt, respondedAt).shaped.<>({r=>import r._; _1.map(_=> OfferActionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column offer_id SqlType(INT), Default(None) */
    val offerId: Rep[Option[Int]] = column[Option[Int]]("offer_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column viewed_at SqlType(DATETIME), Default(None) */
    val viewedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("viewed_at", O.Default(None))
    /** Database column responded_at SqlType(DATETIME), Default(None) */
    val respondedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("responded_at", O.Default(None))

    /** Uniqueness Index over (memberId,offerId) (database name index_offer_actions_on_member_id_and_offer_id) */
    val index1 = index("index_offer_actions_on_member_id_and_offer_id", (memberId, offerId), unique=true)
    /** Index over (offerId) (database name index_offer_actions_on_offer_id) */
    val index2 = index("index_offer_actions_on_offer_id", offerId)
  }
  /** Collection-like TableQuery object for table OfferActions */
  lazy val OfferActions = new TableQuery(tag => new OfferActions(tag))

  /** Entity class storing rows of table OfferCertificates
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param offerId Database column offer_id SqlType(INT)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param offerResponseId Database column offer_response_id SqlType(INT), Default(None) */
  case class OfferCertificatesRow(id: Int, offerId: Int, memberId: Option[Int] = None, code: Option[String] = None, status: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, offerResponseId: Option[Int] = None)
  /** GetResult implicit for fetching OfferCertificatesRow objects using plain SQL queries */
  implicit def GetResultOfferCertificatesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[OfferCertificatesRow] = GR{
    prs => import prs._
    OfferCertificatesRow.tupled((<<[Int], <<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table offer_certificates. Objects of this class serve as prototypes for rows in queries. */
  class OfferCertificates(_tableTag: Tag) extends Table[OfferCertificatesRow](_tableTag, "offer_certificates") {
    def * = (id, offerId, memberId, code, status, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, offerResponseId) <> (OfferCertificatesRow.tupled, OfferCertificatesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(offerId), memberId, code, status, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, offerResponseId).shaped.<>({r=>import r._; _1.map(_=> OfferCertificatesRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column offer_id SqlType(INT) */
    val offerId: Rep[Int] = column[Int]("offer_id")
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(255,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column offer_response_id SqlType(INT), Default(None) */
    val offerResponseId: Rep[Option[Int]] = column[Option[Int]]("offer_response_id", O.Default(None))

    /** Uniqueness Index over (code,offerId) (database name index_offer_certificates_on_code_and_offer_id) */
    val index1 = index("index_offer_certificates_on_code_and_offer_id", (code, offerId), unique=true)
    /** Index over (memberId) (database name index_offer_certificates_on_member_id) */
    val index2 = index("index_offer_certificates_on_member_id", memberId)
    /** Index over (offerResponseId) (database name index_offer_certificates_on_offer_response_id) */
    val index3 = index("index_offer_certificates_on_offer_response_id", offerResponseId)
  }
  /** Collection-like TableQuery object for table OfferCertificates */
  lazy val OfferCertificates = new TableQuery(tag => new OfferCertificates(tag))

  /** Entity class storing rows of table OfferLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param locationId Database column location_id SqlType(INT), Default(None)
   *  @param offerId Database column offer_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(25,true), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(false)) */
  case class OfferLocationsRow(id: Int, locationId: Option[Int] = None, offerId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, locationType: Option[String] = None, included: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching OfferLocationsRow objects using plain SQL queries */
  implicit def GetResultOfferLocationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]], e4: GR[Option[Boolean]]): GR[OfferLocationsRow] = GR{
    prs => import prs._
    OfferLocationsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Boolean]))
  }
  /** Table description of table offer_locations. Objects of this class serve as prototypes for rows in queries. */
  class OfferLocations(_tableTag: Tag) extends Table[OfferLocationsRow](_tableTag, "offer_locations") {
    def * = (id, locationId, offerId, createdAt, updatedAt, locationType, included) <> (OfferLocationsRow.tupled, OfferLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), locationId, offerId, createdAt, updatedAt, locationType, included).shaped.<>({r=>import r._; _1.map(_=> OfferLocationsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column location_id SqlType(INT), Default(None) */
    val locationId: Rep[Option[Int]] = column[Option[Int]]("location_id", O.Default(None))
    /** Database column offer_id SqlType(INT), Default(None) */
    val offerId: Rep[Option[Int]] = column[Option[Int]]("offer_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column location_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val locationType: Rep[Option[String]] = column[Option[String]]("location_type", O.Length(25,varying=true), O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(false)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(false)))

    /** Index over (locationId) (database name index_offer_locations_on_location_id) */
    val index1 = index("index_offer_locations_on_location_id", locationId)
    /** Uniqueness Index over (offerId,locationId) (database name index_offer_locations_on_offer_id_and_location_id) */
    val index2 = index("index_offer_locations_on_offer_id_and_location_id", (offerId, locationId), unique=true)
  }
  /** Collection-like TableQuery object for table OfferLocations */
  lazy val OfferLocations = new TableQuery(tag => new OfferLocations(tag))

  /** Entity class storing rows of table OfferResponses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param offerId Database column offer_id SqlType(INT), Default(None)
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param approvalStatus Database column approval_status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param metricAmount Database column metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeMetricName Database column prize_metric_name SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeMetricAmount Database column prize_metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeId Database column prize_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param businessValue Database column business_value SqlType(DECIMAL), Default(0.00)
   *  @param certificateCodes Database column certificate_codes SqlType(TEXT), Default(None)
   *  @param activityContext Database column activity_context SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param processingStatus Database column processing_status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param messageId Database column message_id SqlType(INT), Default(None)
   *  @param clippedFromObject Database column clipped_from_object SqlType(BIT), Default(Some(false))
   *  @param messageActionId Database column message_action_id SqlType(INT), Default(None) */
  case class OfferResponsesRow(id: Int, offerId: Option[Int] = None, memberId: Option[Int] = None, approvalStatus: Option[String] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), certificateCodes: Option[String] = None, activityContext: Option[String] = None, processingStatus: Option[String] = None, messageId: Option[Int] = None, clippedFromObject: Option[Boolean] = Some(false), messageActionId: Option[Int] = None)
  /** GetResult implicit for fetching OfferResponsesRow objects using plain SQL queries */
  implicit def GetResultOfferResponsesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]], e5: GR[scala.math.BigDecimal], e6: GR[Option[Boolean]]): GR[OfferResponsesRow] = GR{
    prs => import prs._
    OfferResponsesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[scala.math.BigDecimal], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[Boolean], <<?[Int]))
  }
  /** Table description of table offer_responses. Objects of this class serve as prototypes for rows in queries. */
  class OfferResponses(_tableTag: Tag) extends Table[OfferResponsesRow](_tableTag, "offer_responses") {
    def * = (id, offerId, memberId, approvalStatus, metricName, metricAmount, prizeType, prizeMetricName, prizeMetricAmount, prizeId, createdAt, updatedAt, businessValue, certificateCodes, activityContext, processingStatus, messageId, clippedFromObject, messageActionId) <> (OfferResponsesRow.tupled, OfferResponsesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), offerId, memberId, approvalStatus, metricName, metricAmount, prizeType, prizeMetricName, prizeMetricAmount, prizeId, createdAt, updatedAt, Rep.Some(businessValue), certificateCodes, activityContext, processingStatus, messageId, clippedFromObject, messageActionId).shaped.<>({r=>import r._; _1.map(_=> OfferResponsesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13.get, _14, _15, _16, _17, _18, _19)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column offer_id SqlType(INT), Default(None) */
    val offerId: Rep[Option[Int]] = column[Option[Int]]("offer_id", O.Default(None))
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column approval_status SqlType(VARCHAR), Length(50,true), Default(None) */
    val approvalStatus: Rep[Option[String]] = column[Option[String]]("approval_status", O.Length(50,varying=true), O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(50,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(50,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column certificate_codes SqlType(TEXT), Default(None) */
    val certificateCodes: Rep[Option[String]] = column[Option[String]]("certificate_codes", O.Default(None))
    /** Database column activity_context SqlType(VARCHAR), Length(255,true), Default(None) */
    val activityContext: Rep[Option[String]] = column[Option[String]]("activity_context", O.Length(255,varying=true), O.Default(None))
    /** Database column processing_status SqlType(VARCHAR), Length(50,true), Default(None) */
    val processingStatus: Rep[Option[String]] = column[Option[String]]("processing_status", O.Length(50,varying=true), O.Default(None))
    /** Database column message_id SqlType(INT), Default(None) */
    val messageId: Rep[Option[Int]] = column[Option[Int]]("message_id", O.Default(None))
    /** Database column clipped_from_object SqlType(BIT), Default(Some(false)) */
    val clippedFromObject: Rep[Option[Boolean]] = column[Option[Boolean]]("clipped_from_object", O.Default(Some(false)))
    /** Database column message_action_id SqlType(INT), Default(None) */
    val messageActionId: Rep[Option[Int]] = column[Option[Int]]("message_action_id", O.Default(None))

    /** Index over (memberId,offerId) (database name index_offer_responses_on_member_id_and_offer_id) */
    val index1 = index("index_offer_responses_on_member_id_and_offer_id", (memberId, offerId))
    /** Index over (offerId) (database name index_offer_responses_on_offer_id) */
    val index2 = index("index_offer_responses_on_offer_id", offerId)
  }
  /** Collection-like TableQuery object for table OfferResponses */
  lazy val OfferResponses = new TableQuery(tag => new OfferResponses(tag))

  /** Row type of table Offers */
  type OffersRow = HCons[Int,HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[String,HCons[Option[Int],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[Boolean],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HCons[scala.math.BigDecimal,HCons[scala.math.BigDecimal,HCons[Int,HCons[scala.math.BigDecimal,HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Boolean],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for OffersRow providing default values if available in the database schema. */
  def OffersRow(id: Int, name: Option[String] = None, description: Option[String] = None, saves: Option[Int] = None, offeredAt: Option[java.sql.Timestamp] = None, expiresAt: Option[java.sql.Timestamp] = None, value: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, categories: Option[String] = None, eligibility: Option[String] = None, effectivity: Option[String] = None, offerType: Option[String] = None, offerAction: Option[String] = None, barcode: Option[String] = None, offerGoal: Option[String] = None, valueToCustomers: Option[String] = None, numberAvailable: Option[String] = None, numberUse: Option[String] = None, defaultScore: Option[Int] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, targetUrl: Option[String] = None, status: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, responseMaxPerMember: Option[Int] = None, responseMaxPerMemberUnit: Option[String] = None, responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, responseTier: Option[String] = None, responseInterval: Option[Int] = None, responseIntervalUnit: Option[String] = None, label: String, programId: Option[Int] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, barcodeStd: Option[String] = Some("Code39"), templateSetVersionId: Option[Int] = Some(0), showInOffers: Option[Boolean] = Some(true), allowResponses: Option[Boolean] = Some(true), metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, showToPublic: Option[Boolean] = Some(false), newsFeedId: Option[Int] = None, shareOnNewsFeed: Option[String] = None, targetableId: Option[Int] = None, targetableType: Option[String] = None, prizeType: Option[String] = None, prizeId: Option[Int] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeMetricName: Option[String] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[scala.math.BigDecimal] = None, campaignId: Option[Int] = None, rowOrder: Option[Int] = None, weight: Option[scala.math.BigDecimal] = None, rank: Option[scala.math.BigDecimal] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), aggregatedBusinessValue: scala.math.BigDecimal = BigDecimal("0.00"), responsesCount: Int = 0, aggregatedMetricAmount: scala.math.BigDecimal = BigDecimal("0.00"), triggerActivityType: Option[String] = None, discountType: Option[String] = None, discountValue: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), discountMinSubtotal: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), couponCode: Option[String] = None, responsePeriodType: Option[String] = None, responseStart: Option[java.sql.Timestamp] = None, responseEnd: Option[java.sql.Timestamp] = None, responseTimezone: Option[String] = None, responseRecurring: Option[Boolean] = None, responseRecurringSchedule: Option[String] = None, responseStartIntervalType: Option[String] = None, responseStartInterval: Option[Int] = None, responseEndIntervalType: Option[String] = None, responseEndInterval: Option[Int] = None, usagePeriodType: Option[String] = None, usageStart: Option[java.sql.Timestamp] = None, usageEnd: Option[java.sql.Timestamp] = None, usageTimezone: Option[String] = None, usageRecurring: Option[Boolean] = None, usageRecurringSchedule: Option[String] = None, usageStartIntervalType: Option[String] = None, usageStartInterval: Option[Int] = None, usageEndIntervalType: Option[String] = None, usageEndInterval: Option[Int] = None, gs1SaveType: Option[String] = None, gs1SaveValue: Option[String] = None, gs1SaveItem: Option[String] = None, gs1SaveItemCount: Option[String] = None, gs1StoreCouponFlag: Option[Boolean] = None, gs1MultiplyOfferFlag: Option[Boolean] = None, gs1UsagePerResponse: Option[String] = None, gs1PrimaryRequirementType: Option[String] = None, gs1PrimaryRequirement: Option[String] = None, gs1PrimaryFamilyCode: Option[String] = None, gs1PrimaryCompanyPrefix: Option[String] = None, gs1PurchaseRulesType: Option[String] = None, encodeCouponFlag: Option[Boolean] = Some(false)): OffersRow = {
    id :: name :: description :: saves :: offeredAt :: expiresAt :: value :: createdAt :: updatedAt :: categories :: eligibility :: effectivity :: offerType :: offerAction :: barcode :: offerGoal :: valueToCustomers :: numberAvailable :: numberUse :: defaultScore :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: targetUrl :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: publishedAt :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseInterval :: responseIntervalUnit :: label :: programId :: recurring :: recurringSchedule :: barcodeStd :: templateSetVersionId :: showInOffers :: allowResponses :: metricName :: metricAmount :: showToPublic :: newsFeedId :: shareOnNewsFeed :: targetableId :: targetableType :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: campaignId :: rowOrder :: weight :: rank :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: triggerActivityType :: discountType :: discountValue :: discountMinSubtotal :: couponCode :: responsePeriodType :: responseStart :: responseEnd :: responseTimezone :: responseRecurring :: responseRecurringSchedule :: responseStartIntervalType :: responseStartInterval :: responseEndIntervalType :: responseEndInterval :: usagePeriodType :: usageStart :: usageEnd :: usageTimezone :: usageRecurring :: usageRecurringSchedule :: usageStartIntervalType :: usageStartInterval :: usageEndIntervalType :: usageEndInterval :: gs1SaveType :: gs1SaveValue :: gs1SaveItem :: gs1SaveItemCount :: gs1StoreCouponFlag :: gs1MultiplyOfferFlag :: gs1UsagePerResponse :: gs1PrimaryRequirementType :: gs1PrimaryRequirement :: gs1PrimaryFamilyCode :: gs1PrimaryCompanyPrefix :: gs1PurchaseRulesType :: encodeCouponFlag :: HNil
  }
  /** GetResult implicit for fetching OffersRow objects using plain SQL queries */
  implicit def GetResultOffersRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String], e5: GR[Option[Boolean]], e6: GR[Option[scala.math.BigDecimal]], e7: GR[scala.math.BigDecimal]): GR[OffersRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<[String] :: <<?[Int] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[Boolean] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<[Int] :: <<[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Boolean] :: HNil
  }
  /** Table description of table offers. Objects of this class serve as prototypes for rows in queries. */
  class Offers(_tableTag: Tag) extends Table[OffersRow](_tableTag, "offers") {
    def * = id :: name :: description :: saves :: offeredAt :: expiresAt :: value :: createdAt :: updatedAt :: categories :: eligibility :: effectivity :: offerType :: offerAction :: barcode :: offerGoal :: valueToCustomers :: numberAvailable :: numberUse :: defaultScore :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: targetUrl :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: publishedAt :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseInterval :: responseIntervalUnit :: label :: programId :: recurring :: recurringSchedule :: barcodeStd :: templateSetVersionId :: showInOffers :: allowResponses :: metricName :: metricAmount :: showToPublic :: newsFeedId :: shareOnNewsFeed :: targetableId :: targetableType :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: campaignId :: rowOrder :: weight :: rank :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: triggerActivityType :: discountType :: discountValue :: discountMinSubtotal :: couponCode :: responsePeriodType :: responseStart :: responseEnd :: responseTimezone :: responseRecurring :: responseRecurringSchedule :: responseStartIntervalType :: responseStartInterval :: responseEndIntervalType :: responseEndInterval :: usagePeriodType :: usageStart :: usageEnd :: usageTimezone :: usageRecurring :: usageRecurringSchedule :: usageStartIntervalType :: usageStartInterval :: usageEndIntervalType :: usageEndInterval :: gs1SaveType :: gs1SaveValue :: gs1SaveItem :: gs1SaveItemCount :: gs1StoreCouponFlag :: gs1MultiplyOfferFlag :: gs1UsagePerResponse :: gs1PrimaryRequirementType :: gs1PrimaryRequirement :: gs1PrimaryFamilyCode :: gs1PrimaryCompanyPrefix :: gs1PurchaseRulesType :: encodeCouponFlag :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column saves SqlType(INT), Default(None) */
    val saves: Rep[Option[Int]] = column[Option[Int]]("saves", O.Default(None))
    /** Database column offered_at SqlType(DATETIME), Default(None) */
    val offeredAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("offered_at", O.Default(None))
    /** Database column expires_at SqlType(DATETIME), Default(None) */
    val expiresAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("expires_at", O.Default(None))
    /** Database column value SqlType(INT), Default(None) */
    val value: Rep[Option[Int]] = column[Option[Int]]("value", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column categories SqlType(VARCHAR), Length(255,true), Default(None) */
    val categories: Rep[Option[String]] = column[Option[String]]("categories", O.Length(255,varying=true), O.Default(None))
    /** Database column eligibility SqlType(VARCHAR), Length(255,true), Default(None) */
    val eligibility: Rep[Option[String]] = column[Option[String]]("eligibility", O.Length(255,varying=true), O.Default(None))
    /** Database column effectivity SqlType(VARCHAR), Length(255,true), Default(None) */
    val effectivity: Rep[Option[String]] = column[Option[String]]("effectivity", O.Length(255,varying=true), O.Default(None))
    /** Database column offer_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val offerType: Rep[Option[String]] = column[Option[String]]("offer_type", O.Length(255,varying=true), O.Default(None))
    /** Database column offer_action SqlType(VARCHAR), Length(255,true), Default(None) */
    val offerAction: Rep[Option[String]] = column[Option[String]]("offer_action", O.Length(255,varying=true), O.Default(None))
    /** Database column barcode SqlType(VARCHAR), Length(255,true), Default(None) */
    val barcode: Rep[Option[String]] = column[Option[String]]("barcode", O.Length(255,varying=true), O.Default(None))
    /** Database column offer_goal SqlType(VARCHAR), Length(255,true), Default(None) */
    val offerGoal: Rep[Option[String]] = column[Option[String]]("offer_goal", O.Length(255,varying=true), O.Default(None))
    /** Database column value_to_customers SqlType(VARCHAR), Length(255,true), Default(None) */
    val valueToCustomers: Rep[Option[String]] = column[Option[String]]("value_to_customers", O.Length(255,varying=true), O.Default(None))
    /** Database column number_available SqlType(VARCHAR), Length(255,true), Default(None) */
    val numberAvailable: Rep[Option[String]] = column[Option[String]]("number_available", O.Length(255,varying=true), O.Default(None))
    /** Database column number_use SqlType(VARCHAR), Length(255,true), Default(None) */
    val numberUse: Rep[Option[String]] = column[Option[String]]("number_use", O.Length(255,varying=true), O.Default(None))
    /** Database column default_score SqlType(INT), Default(None) */
    val defaultScore: Rep[Option[Int]] = column[Option[Int]]("default_score", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column target_url SqlType(TEXT), Default(None) */
    val targetUrl: Rep[Option[String]] = column[Option[String]]("target_url", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(100,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(100,varying=true), O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column response_max_per_member SqlType(INT), Default(None) */
    val responseMaxPerMember: Rep[Option[Int]] = column[Option[Int]]("response_max_per_member", O.Default(None))
    /** Database column response_max_per_member_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxPerMemberUnit: Rep[Option[String]] = column[Option[String]]("response_max_per_member_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column response_interval SqlType(INT), Default(None) */
    val responseInterval: Rep[Option[Int]] = column[Option[Int]]("response_interval", O.Default(None))
    /** Database column response_interval_unit SqlType(VARCHAR), Length(255,true), Default(None) */
    val responseIntervalUnit: Rep[Option[String]] = column[Option[String]]("response_interval_unit", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column barcode_std SqlType(VARCHAR), Length(255,true), Default(Some(Code39)) */
    val barcodeStd: Rep[Option[String]] = column[Option[String]]("barcode_std", O.Length(255,varying=true), O.Default(Some("Code39")))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
    /** Database column show_in_offers SqlType(BIT), Default(Some(true)) */
    val showInOffers: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_offers", O.Default(Some(true)))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))
    /** Database column news_feed_id SqlType(INT), Default(None) */
    val newsFeedId: Rep[Option[Int]] = column[Option[Int]]("news_feed_id", O.Default(None))
    /** Database column share_on_news_feed SqlType(VARCHAR), Length(25,true), Default(None) */
    val shareOnNewsFeed: Rep[Option[String]] = column[Option[String]]("share_on_news_feed", O.Length(25,varying=true), O.Default(None))
    /** Database column targetable_id SqlType(INT), Default(None) */
    val targetableId: Rep[Option[Int]] = column[Option[Int]]("targetable_id", O.Default(None))
    /** Database column targetable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val targetableType: Rep[Option[String]] = column[Option[String]]("targetable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(DECIMAL), Default(None) */
    val prizeProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_probability", O.Default(None))
    /** Database column campaign_id SqlType(INT), Default(None) */
    val campaignId: Rep[Option[Int]] = column[Option[Int]]("campaign_id", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column weight SqlType(DECIMAL), Default(None) */
    val weight: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("weight", O.Default(None))
    /** Database column rank SqlType(DECIMAL), Default(None) */
    val rank: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("rank", O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column aggregated_business_value SqlType(DECIMAL), Default(0.00) */
    val aggregatedBusinessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_business_value", O.Default(BigDecimal("0.00")))
    /** Database column responses_count SqlType(INT), Default(0) */
    val responsesCount: Rep[Int] = column[Int]("responses_count", O.Default(0))
    /** Database column aggregated_metric_amount SqlType(DECIMAL), Default(0.00) */
    val aggregatedMetricAmount: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_metric_amount", O.Default(BigDecimal("0.00")))
    /** Database column trigger_activity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val triggerActivityType: Rep[Option[String]] = column[Option[String]]("trigger_activity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column discount_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val discountType: Rep[Option[String]] = column[Option[String]]("discount_type", O.Length(25,varying=true), O.Default(None))
    /** Database column discount_value SqlType(DECIMAL), Default(Some(0.00)) */
    val discountValue: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_value", O.Default(Some(BigDecimal("0.00"))))
    /** Database column discount_min_subtotal SqlType(DECIMAL), Default(Some(0.00)) */
    val discountMinSubtotal: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_min_subtotal", O.Default(Some(BigDecimal("0.00"))))
    /** Database column coupon_code SqlType(VARCHAR), Length(50,true), Default(None) */
    val couponCode: Rep[Option[String]] = column[Option[String]]("coupon_code", O.Length(50,varying=true), O.Default(None))
    /** Database column response_period_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val responsePeriodType: Rep[Option[String]] = column[Option[String]]("response_period_type", O.Length(25,varying=true), O.Default(None))
    /** Database column response_start SqlType(DATETIME), Default(None) */
    val responseStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("response_start", O.Default(None))
    /** Database column response_end SqlType(DATETIME), Default(None) */
    val responseEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("response_end", O.Default(None))
    /** Database column response_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val responseTimezone: Rep[Option[String]] = column[Option[String]]("response_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column response_recurring SqlType(BIT), Default(None) */
    val responseRecurring: Rep[Option[Boolean]] = column[Option[Boolean]]("response_recurring", O.Default(None))
    /** Database column response_recurring_schedule SqlType(TEXT), Default(None) */
    val responseRecurringSchedule: Rep[Option[String]] = column[Option[String]]("response_recurring_schedule", O.Default(None))
    /** Database column response_start_interval_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseStartIntervalType: Rep[Option[String]] = column[Option[String]]("response_start_interval_type", O.Length(25,varying=true), O.Default(None))
    /** Database column response_start_interval SqlType(INT), Default(None) */
    val responseStartInterval: Rep[Option[Int]] = column[Option[Int]]("response_start_interval", O.Default(None))
    /** Database column response_end_interval_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseEndIntervalType: Rep[Option[String]] = column[Option[String]]("response_end_interval_type", O.Length(25,varying=true), O.Default(None))
    /** Database column response_end_interval SqlType(INT), Default(None) */
    val responseEndInterval: Rep[Option[Int]] = column[Option[Int]]("response_end_interval", O.Default(None))
    /** Database column usage_period_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val usagePeriodType: Rep[Option[String]] = column[Option[String]]("usage_period_type", O.Length(25,varying=true), O.Default(None))
    /** Database column usage_start SqlType(DATETIME), Default(None) */
    val usageStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("usage_start", O.Default(None))
    /** Database column usage_end SqlType(DATETIME), Default(None) */
    val usageEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("usage_end", O.Default(None))
    /** Database column usage_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val usageTimezone: Rep[Option[String]] = column[Option[String]]("usage_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column usage_recurring SqlType(BIT), Default(None) */
    val usageRecurring: Rep[Option[Boolean]] = column[Option[Boolean]]("usage_recurring", O.Default(None))
    /** Database column usage_recurring_schedule SqlType(TEXT), Default(None) */
    val usageRecurringSchedule: Rep[Option[String]] = column[Option[String]]("usage_recurring_schedule", O.Default(None))
    /** Database column usage_start_interval_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val usageStartIntervalType: Rep[Option[String]] = column[Option[String]]("usage_start_interval_type", O.Length(25,varying=true), O.Default(None))
    /** Database column usage_start_interval SqlType(INT), Default(None) */
    val usageStartInterval: Rep[Option[Int]] = column[Option[Int]]("usage_start_interval", O.Default(None))
    /** Database column usage_end_interval_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val usageEndIntervalType: Rep[Option[String]] = column[Option[String]]("usage_end_interval_type", O.Length(25,varying=true), O.Default(None))
    /** Database column usage_end_interval SqlType(INT), Default(None) */
    val usageEndInterval: Rep[Option[Int]] = column[Option[Int]]("usage_end_interval", O.Default(None))
    /** Database column gs1_save_type SqlType(VARCHAR), Length(5,true), Default(None) */
    val gs1SaveType: Rep[Option[String]] = column[Option[String]]("gs1_save_type", O.Length(5,varying=true), O.Default(None))
    /** Database column gs1_save_value SqlType(VARCHAR), Length(10,true), Default(None) */
    val gs1SaveValue: Rep[Option[String]] = column[Option[String]]("gs1_save_value", O.Length(10,varying=true), O.Default(None))
    /** Database column gs1_save_item SqlType(VARCHAR), Length(5,true), Default(None) */
    val gs1SaveItem: Rep[Option[String]] = column[Option[String]]("gs1_save_item", O.Length(5,varying=true), O.Default(None))
    /** Database column gs1_save_item_count SqlType(VARCHAR), Length(5,true), Default(None) */
    val gs1SaveItemCount: Rep[Option[String]] = column[Option[String]]("gs1_save_item_count", O.Length(5,varying=true), O.Default(None))
    /** Database column gs1_store_coupon_flag SqlType(BIT), Default(None) */
    val gs1StoreCouponFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("gs1_store_coupon_flag", O.Default(None))
    /** Database column gs1_multiply_offer_flag SqlType(BIT), Default(None) */
    val gs1MultiplyOfferFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("gs1_multiply_offer_flag", O.Default(None))
    /** Database column gs1_usage_per_response SqlType(VARCHAR), Length(5,true), Default(None) */
    val gs1UsagePerResponse: Rep[Option[String]] = column[Option[String]]("gs1_usage_per_response", O.Length(5,varying=true), O.Default(None))
    /** Database column gs1_primary_requirement_type SqlType(VARCHAR), Length(5,true), Default(None) */
    val gs1PrimaryRequirementType: Rep[Option[String]] = column[Option[String]]("gs1_primary_requirement_type", O.Length(5,varying=true), O.Default(None))
    /** Database column gs1_primary_requirement SqlType(VARCHAR), Length(10,true), Default(None) */
    val gs1PrimaryRequirement: Rep[Option[String]] = column[Option[String]]("gs1_primary_requirement", O.Length(10,varying=true), O.Default(None))
    /** Database column gs1_primary_family_code SqlType(VARCHAR), Length(10,true), Default(None) */
    val gs1PrimaryFamilyCode: Rep[Option[String]] = column[Option[String]]("gs1_primary_family_code", O.Length(10,varying=true), O.Default(None))
    /** Database column gs1_primary_company_prefix SqlType(VARCHAR), Length(20,true), Default(None) */
    val gs1PrimaryCompanyPrefix: Rep[Option[String]] = column[Option[String]]("gs1_primary_company_prefix", O.Length(20,varying=true), O.Default(None))
    /** Database column gs1_purchase_rules_type SqlType(VARCHAR), Length(5,true), Default(None) */
    val gs1PurchaseRulesType: Rep[Option[String]] = column[Option[String]]("gs1_purchase_rules_type", O.Length(5,varying=true), O.Default(None))
    /** Database column encode_coupon_flag SqlType(BIT), Default(Some(false)) */
    val encodeCouponFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("encode_coupon_flag", O.Default(Some(false)))

    /** Index over (campaignId) (database name index_offers_on_campaign_id) */
    val index1 = index("index_offers_on_campaign_id", campaignId :: HNil)
    /** Index over (name) (database name index_offers_on_name) */
    val index2 = index("index_offers_on_name", name :: HNil)
    /** Index over (newsFeedId) (database name index_offers_on_news_feed_id) */
    val index3 = index("index_offers_on_news_feed_id", newsFeedId :: HNil)
    /** Index over (templateSetVersionId) (database name index_offers_on_template_set_version_id) */
    val index4 = index("index_offers_on_template_set_version_id", templateSetVersionId :: HNil)
  }
  /** Collection-like TableQuery object for table Offers */
  lazy val Offers = new TableQuery(tag => new Offers(tag))

  /** Entity class storing rows of table OfferSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param segmentId Database column segment_id SqlType(INT), Default(None)
   *  @param offerId Database column offer_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param included Database column included SqlType(BIT), Default(Some(true)) */
  case class OfferSegmentsRow(id: Int, segmentId: Option[Int] = None, offerId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, included: Option[Boolean] = Some(true))
  /** GetResult implicit for fetching OfferSegmentsRow objects using plain SQL queries */
  implicit def GetResultOfferSegmentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Boolean]]): GR[OfferSegmentsRow] = GR{
    prs => import prs._
    OfferSegmentsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean]))
  }
  /** Table description of table offer_segments. Objects of this class serve as prototypes for rows in queries. */
  class OfferSegments(_tableTag: Tag) extends Table[OfferSegmentsRow](_tableTag, "offer_segments") {
    def * = (id, segmentId, offerId, createdAt, updatedAt, included) <> (OfferSegmentsRow.tupled, OfferSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), segmentId, offerId, createdAt, updatedAt, included).shaped.<>({r=>import r._; _1.map(_=> OfferSegmentsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column segment_id SqlType(INT), Default(None) */
    val segmentId: Rep[Option[Int]] = column[Option[Int]]("segment_id", O.Default(None))
    /** Database column offer_id SqlType(INT), Default(None) */
    val offerId: Rep[Option[Int]] = column[Option[Int]]("offer_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column included SqlType(BIT), Default(Some(true)) */
    val included: Rep[Option[Boolean]] = column[Option[Boolean]]("included", O.Default(Some(true)))

    /** Uniqueness Index over (offerId,segmentId) (database name index_offer_segments_on_offer_id_and_segment_id) */
    val index1 = index("index_offer_segments_on_offer_id_and_segment_id", (offerId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_offer_segments_on_segment_id) */
    val index2 = index("index_offer_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table OfferSegments */
  lazy val OfferSegments = new TableQuery(tag => new OfferSegments(tag))

  /** Entity class storing rows of table OptionCombinations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param classificationAttributeOptionId Database column classification_attribute_option_id SqlType(INT), Default(None)
   *  @param classifiableAttributeMappingId Database column classifiable_attribute_mapping_id SqlType(INT), Default(None)
   *  @param combinationValueId Database column combination_value_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class OptionCombinationsRow(id: Int, classificationAttributeOptionId: Option[Int] = None, classifiableAttributeMappingId: Option[Int] = None, combinationValueId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching OptionCombinationsRow objects using plain SQL queries */
  implicit def GetResultOptionCombinationsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[OptionCombinationsRow] = GR{
    prs => import prs._
    OptionCombinationsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table option_combinations. Objects of this class serve as prototypes for rows in queries. */
  class OptionCombinations(_tableTag: Tag) extends Table[OptionCombinationsRow](_tableTag, "option_combinations") {
    def * = (id, classificationAttributeOptionId, classifiableAttributeMappingId, combinationValueId, createdAt, updatedAt) <> (OptionCombinationsRow.tupled, OptionCombinationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), classificationAttributeOptionId, classifiableAttributeMappingId, combinationValueId, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> OptionCombinationsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column classification_attribute_option_id SqlType(INT), Default(None) */
    val classificationAttributeOptionId: Rep[Option[Int]] = column[Option[Int]]("classification_attribute_option_id", O.Default(None))
    /** Database column classifiable_attribute_mapping_id SqlType(INT), Default(None) */
    val classifiableAttributeMappingId: Rep[Option[Int]] = column[Option[Int]]("classifiable_attribute_mapping_id", O.Default(None))
    /** Database column combination_value_id SqlType(INT), Default(None) */
    val combinationValueId: Rep[Option[Int]] = column[Option[Int]]("combination_value_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (combinationValueId) (database name index_option_combinations_on_combination_value_id) */
    val index1 = index("index_option_combinations_on_combination_value_id", combinationValueId)
  }
  /** Collection-like TableQuery object for table OptionCombinations */
  lazy val OptionCombinations = new TableQuery(tag => new OptionCombinations(tag))

  /** Entity class storing rows of table Permissions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param resourceName Database column resource_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param privilege Database column privilege SqlType(VARCHAR), Length(10,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param authorizableId Database column authorizable_id SqlType(INT), Default(None)
   *  @param authorizableType Database column authorizable_type SqlType(VARCHAR), Length(255,true), Default(None) */
  case class PermissionsRow(id: Int, resourceName: Option[String] = None, privilege: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, authorizableId: Option[Int] = None, authorizableType: Option[String] = None)
  /** GetResult implicit for fetching PermissionsRow objects using plain SQL queries */
  implicit def GetResultPermissionsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]]): GR[PermissionsRow] = GR{
    prs => import prs._
    PermissionsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String]))
  }
  /** Table description of table permissions. Objects of this class serve as prototypes for rows in queries. */
  class Permissions(_tableTag: Tag) extends Table[PermissionsRow](_tableTag, "permissions") {
    def * = (id, resourceName, privilege, createdAt, updatedAt, authorizableId, authorizableType) <> (PermissionsRow.tupled, PermissionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), resourceName, privilege, createdAt, updatedAt, authorizableId, authorizableType).shaped.<>({r=>import r._; _1.map(_=> PermissionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column resource_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val resourceName: Rep[Option[String]] = column[Option[String]]("resource_name", O.Length(255,varying=true), O.Default(None))
    /** Database column privilege SqlType(VARCHAR), Length(10,true), Default(None) */
    val privilege: Rep[Option[String]] = column[Option[String]]("privilege", O.Length(10,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column authorizable_id SqlType(INT), Default(None) */
    val authorizableId: Rep[Option[Int]] = column[Option[Int]]("authorizable_id", O.Default(None))
    /** Database column authorizable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val authorizableType: Rep[Option[String]] = column[Option[String]]("authorizable_type", O.Length(255,varying=true), O.Default(None))

    /** Index over (authorizableId,authorizableType) (database name index_permissions_on_authorizable_id_and_authorizable_type) */
    val index1 = index("index_permissions_on_authorizable_id_and_authorizable_type", (authorizableId, authorizableType))
  }
  /** Collection-like TableQuery object for table Permissions */
  lazy val Permissions = new TableQuery(tag => new Permissions(tag))

  /** Entity class storing rows of table Placements
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param platform Database column platform SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param url Database column url SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class PlacementsRow(id: Int, name: String, label: String, publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", description: Option[String] = None, platform: Option[String] = None, url: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching PlacementsRow objects using plain SQL queries */
  implicit def GetResultPlacementsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]]): GR[PlacementsRow] = GR{
    prs => import prs._
    PlacementsRow.tupled((<<[Int], <<[String], <<[String], <<?[java.sql.Timestamp], <<[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table placements. Objects of this class serve as prototypes for rows in queries. */
  class Placements(_tableTag: Tag) extends Table[PlacementsRow](_tableTag, "placements") {
    def * = (id, name, label, publishedAt, status, description, platform, url, createdAt, updatedAt) <> (PlacementsRow.tupled, PlacementsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), publishedAt, Rep.Some(status), description, platform, url, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> PlacementsRow.tupled((_1.get, _2.get, _3.get, _4, _5.get, _6, _7, _8, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column platform SqlType(VARCHAR), Length(100,true), Default(None) */
    val platform: Rep[Option[String]] = column[Option[String]]("platform", O.Length(100,varying=true), O.Default(None))
    /** Database column url SqlType(VARCHAR), Length(255,true), Default(None) */
    val url: Rep[Option[String]] = column[Option[String]]("url", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table Placements */
  lazy val Placements = new TableQuery(tag => new Placements(tag))

  /** Entity class storing rows of table Posts
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param trackableId Database column trackable_id SqlType(INT), Default(None)
   *  @param ownerId Database column owner_id SqlType(INT), Default(None)
   *  @param recipientId Database column recipient_id SqlType(INT), Default(None)
   *  @param trackableType Database column trackable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param ownerType Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param recipientType Database column recipient_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param key Database column key SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param visible Database column visible SqlType(BIT), Default(Some(true))
   *  @param pinnedAt Database column pinned_at SqlType(DATETIME), Default(None)
   *  @param postDate Database column post_date SqlType(DATETIME), Default(None)
   *  @param newsFeedId Database column news_feed_id SqlType(INT), Default(None)
   *  @param body Database column body SqlType(TEXT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param sourceUid Database column source_uid SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param targetableId Database column targetable_id SqlType(INT), Default(None)
   *  @param targetableType Database column targetable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param targetUrl Database column target_url SqlType(TEXT), Default(None) */
  case class PostsRow(id: Int, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, trackableId: Option[Int] = None, ownerId: Option[Int] = None, recipientId: Option[Int] = None, trackableType: Option[String] = None, ownerType: Option[String] = None, recipientType: Option[String] = None, properties: Option[String] = None, key: Option[String] = None, visible: Option[Boolean] = Some(true), pinnedAt: Option[java.sql.Timestamp] = None, postDate: Option[java.sql.Timestamp] = None, newsFeedId: Option[Int] = None, body: Option[String] = None, `type`: Option[String] = None, sourceUid: Option[String] = None, targetableId: Option[Int] = None, targetableType: Option[String] = None, targetUrl: Option[String] = None)
  /** GetResult implicit for fetching PostsRow objects using plain SQL queries */
  implicit def GetResultPostsRow(implicit e0: GR[Int], e1: GR[Option[java.sql.Timestamp]], e2: GR[Option[Int]], e3: GR[Option[String]], e4: GR[Option[Boolean]]): GR[PostsRow] = GR{
    prs => import prs._
    PostsRow.tupled((<<[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[String], <<?[String]))
  }
  /** Table description of table posts. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Posts(_tableTag: Tag) extends Table[PostsRow](_tableTag, "posts") {
    def * = (id, createdAt, updatedAt, trackableId, ownerId, recipientId, trackableType, ownerType, recipientType, properties, key, visible, pinnedAt, postDate, newsFeedId, body, `type`, sourceUid, targetableId, targetableType, targetUrl) <> (PostsRow.tupled, PostsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), createdAt, updatedAt, trackableId, ownerId, recipientId, trackableType, ownerType, recipientType, properties, key, visible, pinnedAt, postDate, newsFeedId, body, `type`, sourceUid, targetableId, targetableType, targetUrl).shaped.<>({r=>import r._; _1.map(_=> PostsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column trackable_id SqlType(INT), Default(None) */
    val trackableId: Rep[Option[Int]] = column[Option[Int]]("trackable_id", O.Default(None))
    /** Database column owner_id SqlType(INT), Default(None) */
    val ownerId: Rep[Option[Int]] = column[Option[Int]]("owner_id", O.Default(None))
    /** Database column recipient_id SqlType(INT), Default(None) */
    val recipientId: Rep[Option[Int]] = column[Option[Int]]("recipient_id", O.Default(None))
    /** Database column trackable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val trackableType: Rep[Option[String]] = column[Option[String]]("trackable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ownerType: Rep[Option[String]] = column[Option[String]]("owner_type", O.Length(255,varying=true), O.Default(None))
    /** Database column recipient_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val recipientType: Rep[Option[String]] = column[Option[String]]("recipient_type", O.Length(255,varying=true), O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column key SqlType(VARCHAR), Length(255,true), Default(None) */
    val key: Rep[Option[String]] = column[Option[String]]("key", O.Length(255,varying=true), O.Default(None))
    /** Database column visible SqlType(BIT), Default(Some(true)) */
    val visible: Rep[Option[Boolean]] = column[Option[Boolean]]("visible", O.Default(Some(true)))
    /** Database column pinned_at SqlType(DATETIME), Default(None) */
    val pinnedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("pinned_at", O.Default(None))
    /** Database column post_date SqlType(DATETIME), Default(None) */
    val postDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("post_date", O.Default(None))
    /** Database column news_feed_id SqlType(INT), Default(None) */
    val newsFeedId: Rep[Option[Int]] = column[Option[Int]]("news_feed_id", O.Default(None))
    /** Database column body SqlType(TEXT), Default(None) */
    val body: Rep[Option[String]] = column[Option[String]]("body", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(100,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(100,varying=true), O.Default(None))
    /** Database column source_uid SqlType(VARCHAR), Length(255,true), Default(None) */
    val sourceUid: Rep[Option[String]] = column[Option[String]]("source_uid", O.Length(255,varying=true), O.Default(None))
    /** Database column targetable_id SqlType(INT), Default(None) */
    val targetableId: Rep[Option[Int]] = column[Option[Int]]("targetable_id", O.Default(None))
    /** Database column targetable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val targetableType: Rep[Option[String]] = column[Option[String]]("targetable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column target_url SqlType(TEXT), Default(None) */
    val targetUrl: Rep[Option[String]] = column[Option[String]]("target_url", O.Default(None))

    /** Index over (ownerId,ownerType) (database name index_posts_on_owner_id_and_owner_type) */
    val index1 = index("index_posts_on_owner_id_and_owner_type", (ownerId, ownerType))
    /** Index over (pinnedAt) (database name index_posts_on_pinned_at) */
    val index2 = index("index_posts_on_pinned_at", pinnedAt)
    /** Index over (recipientId,recipientType) (database name index_posts_on_recipient_id_and_recipient_type) */
    val index3 = index("index_posts_on_recipient_id_and_recipient_type", (recipientId, recipientType))
    /** Index over (trackableId,trackableType) (database name index_posts_on_trackable_id_and_trackable_type) */
    val index4 = index("index_posts_on_trackable_id_and_trackable_type", (trackableId, trackableType))
    /** Index over (newsFeedId,visible) (database name news_feed_visible) */
    val index5 = index("news_feed_visible", (newsFeedId, visible))
  }
  /** Collection-like TableQuery object for table Posts */
  lazy val Posts = new TableQuery(tag => new Posts(tag))

  /** Entity class storing rows of table ProductActions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param productId Database column product_id SqlType(INT), Default(None)
   *  @param viewedAt Database column viewed_at SqlType(DATETIME), Default(None)
   *  @param respondedAt Database column responded_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ProductActionsRow(id: Int, memberId: Option[Int] = None, productId: Option[Int] = None, viewedAt: Option[java.sql.Timestamp] = None, respondedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ProductActionsRow objects using plain SQL queries */
  implicit def GetResultProductActionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[ProductActionsRow] = GR{
    prs => import prs._
    ProductActionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table product_actions. Objects of this class serve as prototypes for rows in queries. */
  class ProductActions(_tableTag: Tag) extends Table[ProductActionsRow](_tableTag, "product_actions") {
    def * = (id, memberId, productId, viewedAt, respondedAt, createdAt, updatedAt) <> (ProductActionsRow.tupled, ProductActionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, productId, viewedAt, respondedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ProductActionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column product_id SqlType(INT), Default(None) */
    val productId: Rep[Option[Int]] = column[Option[Int]]("product_id", O.Default(None))
    /** Database column viewed_at SqlType(DATETIME), Default(None) */
    val viewedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("viewed_at", O.Default(None))
    /** Database column responded_at SqlType(DATETIME), Default(None) */
    val respondedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("responded_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (memberId) (database name index_product_actions_on_member_id) */
    val index1 = index("index_product_actions_on_member_id", memberId)
    /** Index over (productId) (database name index_product_actions_on_product_id) */
    val index2 = index("index_product_actions_on_product_id", productId)
  }
  /** Collection-like TableQuery object for table ProductActions */
  lazy val ProductActions = new TableQuery(tag => new ProductActions(tag))

  /** Entity class storing rows of table ProductEdges
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param ancestorId Database column ancestor_id SqlType(INT), Default(None)
   *  @param ancestorType Database column ancestor_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param descendantId Database column descendant_id SqlType(INT), Default(None)
   *  @param descendantType Database column descendant_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param direct Database column direct SqlType(BIT), Default(None)
   *  @param count Database column count SqlType(INT), Default(None)
   *  @param selected Database column selected SqlType(VARCHAR), Length(10,true), Default(Some(no))
   *  @param extra Database column extra SqlType(VARCHAR), Length(10,true), Default(Some(no))
   *  @param configureAttributeId Database column configure_attribute_id SqlType(INT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class ProductEdgesRow(id: Int, ancestorId: Option[Int] = None, ancestorType: Option[String] = None, descendantId: Option[Int] = None, descendantType: Option[String] = None, direct: Option[Boolean] = None, count: Option[Int] = None, selected: Option[String] = Some("no"), extra: Option[String] = Some("no"), configureAttributeId: Option[Int] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching ProductEdgesRow objects using plain SQL queries */
  implicit def GetResultProductEdgesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]]): GR[ProductEdgesRow] = GR{
    prs => import prs._
    ProductEdgesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[Boolean], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[Int]))
  }
  /** Table description of table product_edges. Objects of this class serve as prototypes for rows in queries. */
  class ProductEdges(_tableTag: Tag) extends Table[ProductEdgesRow](_tableTag, "product_edges") {
    def * = (id, ancestorId, ancestorType, descendantId, descendantType, direct, count, selected, extra, configureAttributeId, rowOrder) <> (ProductEdgesRow.tupled, ProductEdgesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), ancestorId, ancestorType, descendantId, descendantType, direct, count, selected, extra, configureAttributeId, rowOrder).shaped.<>({r=>import r._; _1.map(_=> ProductEdgesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column ancestor_id SqlType(INT), Default(None) */
    val ancestorId: Rep[Option[Int]] = column[Option[Int]]("ancestor_id", O.Default(None))
    /** Database column ancestor_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ancestorType: Rep[Option[String]] = column[Option[String]]("ancestor_type", O.Length(255,varying=true), O.Default(None))
    /** Database column descendant_id SqlType(INT), Default(None) */
    val descendantId: Rep[Option[Int]] = column[Option[Int]]("descendant_id", O.Default(None))
    /** Database column descendant_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val descendantType: Rep[Option[String]] = column[Option[String]]("descendant_type", O.Length(255,varying=true), O.Default(None))
    /** Database column direct SqlType(BIT), Default(None) */
    val direct: Rep[Option[Boolean]] = column[Option[Boolean]]("direct", O.Default(None))
    /** Database column count SqlType(INT), Default(None) */
    val count: Rep[Option[Int]] = column[Option[Int]]("count", O.Default(None))
    /** Database column selected SqlType(VARCHAR), Length(10,true), Default(Some(no)) */
    val selected: Rep[Option[String]] = column[Option[String]]("selected", O.Length(10,varying=true), O.Default(Some("no")))
    /** Database column extra SqlType(VARCHAR), Length(10,true), Default(Some(no)) */
    val extra: Rep[Option[String]] = column[Option[String]]("extra", O.Length(10,varying=true), O.Default(Some("no")))
    /** Database column configure_attribute_id SqlType(INT), Default(None) */
    val configureAttributeId: Rep[Option[Int]] = column[Option[Int]]("configure_attribute_id", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
  }
  /** Collection-like TableQuery object for table ProductEdges */
  lazy val ProductEdges = new TableQuery(tag => new ProductEdges(tag))

  /** Entity class storing rows of table ProductHierarchies
   *  @param ancestorId Database column ancestor_id SqlType(INT)
   *  @param descendantId Database column descendant_id SqlType(INT)
   *  @param generations Database column generations SqlType(INT) */
  case class ProductHierarchiesRow(ancestorId: Int, descendantId: Int, generations: Int)
  /** GetResult implicit for fetching ProductHierarchiesRow objects using plain SQL queries */
  implicit def GetResultProductHierarchiesRow(implicit e0: GR[Int]): GR[ProductHierarchiesRow] = GR{
    prs => import prs._
    ProductHierarchiesRow.tupled((<<[Int], <<[Int], <<[Int]))
  }
  /** Table description of table product_hierarchies. Objects of this class serve as prototypes for rows in queries. */
  class ProductHierarchies(_tableTag: Tag) extends Table[ProductHierarchiesRow](_tableTag, "product_hierarchies") {
    def * = (ancestorId, descendantId, generations) <> (ProductHierarchiesRow.tupled, ProductHierarchiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(ancestorId), Rep.Some(descendantId), Rep.Some(generations)).shaped.<>({r=>import r._; _1.map(_=> ProductHierarchiesRow.tupled((_1.get, _2.get, _3.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column ancestor_id SqlType(INT) */
    val ancestorId: Rep[Int] = column[Int]("ancestor_id")
    /** Database column descendant_id SqlType(INT) */
    val descendantId: Rep[Int] = column[Int]("descendant_id")
    /** Database column generations SqlType(INT) */
    val generations: Rep[Int] = column[Int]("generations")

    /** Uniqueness Index over (ancestorId,descendantId,generations) (database name product_anc_desc_idx) */
    val index1 = index("product_anc_desc_idx", (ancestorId, descendantId, generations), unique=true)
    /** Index over (descendantId) (database name product_desc_idx) */
    val index2 = index("product_desc_idx", descendantId)
  }
  /** Collection-like TableQuery object for table ProductHierarchies */
  lazy val ProductHierarchies = new TableQuery(tag => new ProductHierarchies(tag))

  /** Entity class storing rows of table ProductLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param productId Database column product_id SqlType(INT)
   *  @param locationId Database column location_id SqlType(INT)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(255,true)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ProductLocationsRow(id: Int, productId: Int, locationId: Int, locationType: String, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ProductLocationsRow objects using plain SQL queries */
  implicit def GetResultProductLocationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Boolean], e3: GR[Option[java.sql.Timestamp]]): GR[ProductLocationsRow] = GR{
    prs => import prs._
    ProductLocationsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table product_locations. Objects of this class serve as prototypes for rows in queries. */
  class ProductLocations(_tableTag: Tag) extends Table[ProductLocationsRow](_tableTag, "product_locations") {
    def * = (id, productId, locationId, locationType, included, createdAt, updatedAt) <> (ProductLocationsRow.tupled, ProductLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(productId), Rep.Some(locationId), Rep.Some(locationType), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ProductLocationsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column product_id SqlType(INT) */
    val productId: Rep[Int] = column[Int]("product_id")
    /** Database column location_id SqlType(INT) */
    val locationId: Rep[Int] = column[Int]("location_id")
    /** Database column location_type SqlType(VARCHAR), Length(255,true) */
    val locationType: Rep[String] = column[String]("location_type", O.Length(255,varying=true))
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (locationId) (database name index_product_locations_on_location_id) */
    val index1 = index("index_product_locations_on_location_id", locationId)
    /** Uniqueness Index over (productId,locationId) (database name index_product_locations_on_product_id_and_location_id) */
    val index2 = index("index_product_locations_on_product_id_and_location_id", (productId, locationId), unique=true)
  }
  /** Collection-like TableQuery object for table ProductLocations */
  lazy val ProductLocations = new TableQuery(tag => new ProductLocations(tag))

  /** Row type of table Products */
  type ProductsRow = HCons[Int,HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[String,HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[String],HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for ProductsRow providing default values if available in the database schema. */
  def ProductsRow(id: Int, programId: Option[Int] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, name: String, label: String, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, metricName: Option[String] = None, `type`: Option[String] = None, status: String = "draft", publishedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, description: Option[String] = None, sku: Option[String] = None, templateSetVersionId: Option[Int] = Some(0), prizeType: Option[String] = None, prizeId: Option[Int] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeMetricName: Option[String] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[scala.math.BigDecimal] = None, responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, responseTier: Option[String] = None, responseMaxPerMember: Option[Int] = None, responseMaxPerMemberUnit: Option[String] = None, responseInterval: Option[Int] = None, responseIntervalUnit: Option[String] = None, showInList: Option[Boolean] = Some(true), allowResponses: Option[Boolean] = Some(true), showToPublic: Option[Boolean] = Some(true), discountType: Option[String] = None, discountValue: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), discountMinSubtotal: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00"))): ProductsRow = {
    id :: programId :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: name :: label :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: metricAmount :: metricName :: `type` :: status :: publishedAt :: createdAt :: updatedAt :: description :: sku :: templateSetVersionId :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: showInList :: allowResponses :: showToPublic :: discountType :: discountValue :: discountMinSubtotal :: HNil
  }
  /** GetResult implicit for fetching ProductsRow objects using plain SQL queries */
  implicit def GetResultProductsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String], e5: GR[Option[Boolean]], e6: GR[Option[scala.math.BigDecimal]]): GR[ProductsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: HNil
  }
  /** Table description of table products. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Products(_tableTag: Tag) extends Table[ProductsRow](_tableTag, "products") {
    def * = id :: programId :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: name :: label :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: metricAmount :: metricName :: `type` :: status :: publishedAt :: createdAt :: updatedAt :: description :: sku :: templateSetVersionId :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: showInList :: allowResponses :: showToPublic :: discountType :: discountValue :: discountMinSubtotal :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(100,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(100,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column sku SqlType(VARCHAR), Length(255,true), Default(None) */
    val sku: Rep[Option[String]] = column[Option[String]]("sku", O.Length(255,varying=true), O.Default(None))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(DECIMAL), Default(None) */
    val prizeProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_probability", O.Default(None))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_per_member SqlType(INT), Default(None) */
    val responseMaxPerMember: Rep[Option[Int]] = column[Option[Int]]("response_max_per_member", O.Default(None))
    /** Database column response_max_per_member_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxPerMemberUnit: Rep[Option[String]] = column[Option[String]]("response_max_per_member_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_interval SqlType(INT), Default(None) */
    val responseInterval: Rep[Option[Int]] = column[Option[Int]]("response_interval", O.Default(None))
    /** Database column response_interval_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseIntervalUnit: Rep[Option[String]] = column[Option[String]]("response_interval_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column show_in_list SqlType(BIT), Default(Some(true)) */
    val showInList: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_list", O.Default(Some(true)))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column show_to_public SqlType(BIT), Default(Some(true)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(true)))
    /** Database column discount_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val discountType: Rep[Option[String]] = column[Option[String]]("discount_type", O.Length(25,varying=true), O.Default(None))
    /** Database column discount_value SqlType(DECIMAL), Default(Some(0.00)) */
    val discountValue: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_value", O.Default(Some(BigDecimal("0.00"))))
    /** Database column discount_min_subtotal SqlType(DECIMAL), Default(Some(0.00)) */
    val discountMinSubtotal: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_min_subtotal", O.Default(Some(BigDecimal("0.00"))))

    /** Index over (templateSetVersionId) (database name index_products_on_template_set_version_id) */
    val index1 = index("index_products_on_template_set_version_id", templateSetVersionId :: HNil)
  }
  /** Collection-like TableQuery object for table Products */
  lazy val Products = new TableQuery(tag => new Products(tag))

  /** Entity class storing rows of table ProductSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param productId Database column product_id SqlType(INT)
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ProductSegmentsRow(id: Int, productId: Int, segmentId: Int, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ProductSegmentsRow objects using plain SQL queries */
  implicit def GetResultProductSegmentsRow(implicit e0: GR[Int], e1: GR[Boolean], e2: GR[Option[java.sql.Timestamp]]): GR[ProductSegmentsRow] = GR{
    prs => import prs._
    ProductSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table product_segments. Objects of this class serve as prototypes for rows in queries. */
  class ProductSegments(_tableTag: Tag) extends Table[ProductSegmentsRow](_tableTag, "product_segments") {
    def * = (id, productId, segmentId, included, createdAt, updatedAt) <> (ProductSegmentsRow.tupled, ProductSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(productId), Rep.Some(segmentId), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ProductSegmentsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column product_id SqlType(INT) */
    val productId: Rep[Int] = column[Int]("product_id")
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (productId,segmentId) (database name index_product_segments_on_product_id_and_segment_id) */
    val index1 = index("index_product_segments_on_product_id_and_segment_id", (productId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_product_segments_on_segment_id) */
    val index2 = index("index_product_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table ProductSegments */
  lazy val ProductSegments = new TableQuery(tag => new ProductSegments(tag))

  /** Entity class storing rows of table Programs
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param tagLine Database column tag_line SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param configuration Database column configuration SqlType(TEXT), Default(None)
   *  @param lastMemberId Database column last_member_id SqlType(VARCHAR), Length(255,true), Default(None) */
  case class ProgramsRow(id: Int, name: String, tagLine: Option[String] = None, description: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, configuration: Option[String] = None, lastMemberId: Option[String] = None)
  /** GetResult implicit for fetching ProgramsRow objects using plain SQL queries */
  implicit def GetResultProgramsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[ProgramsRow] = GR{
    prs => import prs._
    ProgramsRow.tupled((<<[Int], <<[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String]))
  }
  /** Table description of table programs. Objects of this class serve as prototypes for rows in queries. */
  class Programs(_tableTag: Tag) extends Table[ProgramsRow](_tableTag, "programs") {
    def * = (id, name, tagLine, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt, configuration, lastMemberId) <> (ProgramsRow.tupled, ProgramsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), tagLine, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt, configuration, lastMemberId).shaped.<>({r=>import r._; _1.map(_=> ProgramsRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column tag_line SqlType(VARCHAR), Length(255,true), Default(None) */
    val tagLine: Rep[Option[String]] = column[Option[String]]("tag_line", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column configuration SqlType(TEXT), Default(None) */
    val configuration: Rep[Option[String]] = column[Option[String]]("configuration", O.Default(None))
    /** Database column last_member_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val lastMemberId: Rep[Option[String]] = column[Option[String]]("last_member_id", O.Length(255,varying=true), O.Default(None))

    /** Index over (name) (database name index_programs_on_name) */
    val index1 = index("index_programs_on_name", name)
  }
  /** Collection-like TableQuery object for table Programs */
  lazy val Programs = new TableQuery(tag => new Programs(tag))

  /** Entity class storing rows of table ProgramSettings
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param `var` Database column var SqlType(VARCHAR), Length(255,true)
   *  @param value Database column value SqlType(TEXT), Default(None)
   *  @param thingId Database column thing_id SqlType(INT), Default(None)
   *  @param thingType Database column thing_type SqlType(VARCHAR), Length(30,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param resource Database column resource SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param minimumPermission Database column minimum_permission SqlType(VARCHAR), Length(50,true), Default(Some(update)) */
  case class ProgramSettingsRow(id: Int, `var`: String, value: Option[String] = None, thingId: Option[Int] = None, thingType: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, resource: Option[String] = None, label: Option[String] = None, description: Option[String] = None, minimumPermission: Option[String] = Some("update"))
  /** GetResult implicit for fetching ProgramSettingsRow objects using plain SQL queries */
  implicit def GetResultProgramSettingsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[ProgramSettingsRow] = GR{
    prs => import prs._
    ProgramSettingsRow.tupled((<<[Int], <<[String], <<?[String], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String], <<?[String]))
  }
  /** Table description of table program_settings. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: var */
  class ProgramSettings(_tableTag: Tag) extends Table[ProgramSettingsRow](_tableTag, "program_settings") {
    def * = (id, `var`, value, thingId, thingType, createdAt, updatedAt, resource, label, description, minimumPermission) <> (ProgramSettingsRow.tupled, ProgramSettingsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(`var`), value, thingId, thingType, createdAt, updatedAt, resource, label, description, minimumPermission).shaped.<>({r=>import r._; _1.map(_=> ProgramSettingsRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column var SqlType(VARCHAR), Length(255,true)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `var`: Rep[String] = column[String]("var", O.Length(255,varying=true))
    /** Database column value SqlType(TEXT), Default(None) */
    val value: Rep[Option[String]] = column[Option[String]]("value", O.Default(None))
    /** Database column thing_id SqlType(INT), Default(None) */
    val thingId: Rep[Option[Int]] = column[Option[Int]]("thing_id", O.Default(None))
    /** Database column thing_type SqlType(VARCHAR), Length(30,true), Default(None) */
    val thingType: Rep[Option[String]] = column[Option[String]]("thing_type", O.Length(30,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column resource SqlType(VARCHAR), Length(100,true), Default(None) */
    val resource: Rep[Option[String]] = column[Option[String]]("resource", O.Length(100,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column minimum_permission SqlType(VARCHAR), Length(50,true), Default(Some(update)) */
    val minimumPermission: Rep[Option[String]] = column[Option[String]]("minimum_permission", O.Length(50,varying=true), O.Default(Some("update")))

    /** Index over (resource) (database name index_program_settings_on_resource) */
    val index1 = index("index_program_settings_on_resource", resource)
    /** Uniqueness Index over (thingType,thingId,`var`) (database name index_program_settings_on_thing_type_and_thing_id_and_var) */
    val index2 = index("index_program_settings_on_thing_type_and_thing_id_and_var", (thingType, thingId, `var`), unique=true)
  }
  /** Collection-like TableQuery object for table ProgramSettings */
  lazy val ProgramSettings = new TableQuery(tag => new ProgramSettings(tag))

  /** Entity class storing rows of table Properties
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class PropertiesRow(id: Int, name: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching PropertiesRow objects using plain SQL queries */
  implicit def GetResultPropertiesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]]): GR[PropertiesRow] = GR{
    prs => import prs._
    PropertiesRow.tupled((<<[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table properties. Objects of this class serve as prototypes for rows in queries. */
  class Properties(_tableTag: Tag) extends Table[PropertiesRow](_tableTag, "properties") {
    def * = (id, name, createdAt, updatedAt) <> (PropertiesRow.tupled, PropertiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> PropertiesRow.tupled((_1.get, _2, _3, _4)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (name) (database name index_properties_on_name) */
    val index1 = index("index_properties_on_name", name)
  }
  /** Collection-like TableQuery object for table Properties */
  lazy val Properties = new TableQuery(tag => new Properties(tag))

  /** Entity class storing rows of table PunchCards
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param punchCardTypeId Database column punch_card_type_id SqlType(INT), Default(None)
   *  @param punchCardTransactionsCount Database column punch_card_transactions_count SqlType(INT), Default(Some(0))
   *  @param status Database column status SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param totalAmount Database column total_amount SqlType(DECIMAL), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param numPunches Database column num_punches SqlType(INT), Default(Some(0))
   *  @param prizeId Database column prize_id SqlType(INT), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param firstPunchDate Database column first_punch_date SqlType(DATETIME), Default(None)
   *  @param currentPunches Database column current_punches SqlType(INT), Default(0) */
  case class PunchCardsRow(id: Int, memberId: Option[Int] = None, punchCardTypeId: Option[Int] = None, punchCardTransactionsCount: Option[Int] = Some(0), status: Option[String] = None, totalAmount: Option[scala.math.BigDecimal] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, numPunches: Option[Int] = Some(0), prizeId: Option[Int] = None, prizeType: Option[String] = None, firstPunchDate: Option[java.sql.Timestamp] = None, currentPunches: Int = 0)
  /** GetResult implicit for fetching PunchCardsRow objects using plain SQL queries */
  implicit def GetResultPunchCardsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]]): GR[PunchCardsRow] = GR{
    prs => import prs._
    PunchCardsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[Int], <<?[String], <<?[scala.math.BigDecimal], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<[Int]))
  }
  /** Table description of table punch_cards. Objects of this class serve as prototypes for rows in queries. */
  class PunchCards(_tableTag: Tag) extends Table[PunchCardsRow](_tableTag, "punch_cards") {
    def * = (id, memberId, punchCardTypeId, punchCardTransactionsCount, status, totalAmount, createdAt, updatedAt, numPunches, prizeId, prizeType, firstPunchDate, currentPunches) <> (PunchCardsRow.tupled, PunchCardsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, punchCardTypeId, punchCardTransactionsCount, status, totalAmount, createdAt, updatedAt, numPunches, prizeId, prizeType, firstPunchDate, Rep.Some(currentPunches)).shaped.<>({r=>import r._; _1.map(_=> PunchCardsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column punch_card_type_id SqlType(INT), Default(None) */
    val punchCardTypeId: Rep[Option[Int]] = column[Option[Int]]("punch_card_type_id", O.Default(None))
    /** Database column punch_card_transactions_count SqlType(INT), Default(Some(0)) */
    val punchCardTransactionsCount: Rep[Option[Int]] = column[Option[Int]]("punch_card_transactions_count", O.Default(Some(0)))
    /** Database column status SqlType(VARCHAR), Length(255,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(255,varying=true), O.Default(None))
    /** Database column total_amount SqlType(DECIMAL), Default(None) */
    val totalAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("total_amount", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column num_punches SqlType(INT), Default(Some(0)) */
    val numPunches: Rep[Option[Int]] = column[Option[Int]]("num_punches", O.Default(Some(0)))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(255,varying=true), O.Default(None))
    /** Database column first_punch_date SqlType(DATETIME), Default(None) */
    val firstPunchDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("first_punch_date", O.Default(None))
    /** Database column current_punches SqlType(INT), Default(0) */
    val currentPunches: Rep[Int] = column[Int]("current_punches", O.Default(0))
  }
  /** Collection-like TableQuery object for table PunchCards */
  lazy val PunchCards = new TableQuery(tag => new PunchCards(tag))

  /** Entity class storing rows of table PunchCardTransactions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param punchCardId Database column punch_card_id SqlType(INT), Default(None)
   *  @param totalAmount Database column total_amount SqlType(DECIMAL), Default(None)
   *  @param purchaseDate Database column purchase_date SqlType(DATETIME), Default(None)
   *  @param items Database column items SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param punches Database column punches SqlType(INT), Default(Some(1)) */
  case class PunchCardTransactionsRow(id: Int, punchCardId: Option[Int] = None, totalAmount: Option[scala.math.BigDecimal] = None, purchaseDate: Option[java.sql.Timestamp] = None, items: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, punches: Option[Int] = Some(1))
  /** GetResult implicit for fetching PunchCardTransactionsRow objects using plain SQL queries */
  implicit def GetResultPunchCardTransactionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[scala.math.BigDecimal]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[String]]): GR[PunchCardTransactionsRow] = GR{
    prs => import prs._
    PunchCardTransactionsRow.tupled((<<[Int], <<?[Int], <<?[scala.math.BigDecimal], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table punch_card_transactions. Objects of this class serve as prototypes for rows in queries. */
  class PunchCardTransactions(_tableTag: Tag) extends Table[PunchCardTransactionsRow](_tableTag, "punch_card_transactions") {
    def * = (id, punchCardId, totalAmount, purchaseDate, items, createdAt, updatedAt, punches) <> (PunchCardTransactionsRow.tupled, PunchCardTransactionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), punchCardId, totalAmount, purchaseDate, items, createdAt, updatedAt, punches).shaped.<>({r=>import r._; _1.map(_=> PunchCardTransactionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column punch_card_id SqlType(INT), Default(None) */
    val punchCardId: Rep[Option[Int]] = column[Option[Int]]("punch_card_id", O.Default(None))
    /** Database column total_amount SqlType(DECIMAL), Default(None) */
    val totalAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("total_amount", O.Default(None))
    /** Database column purchase_date SqlType(DATETIME), Default(None) */
    val purchaseDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("purchase_date", O.Default(None))
    /** Database column items SqlType(TEXT), Default(None) */
    val items: Rep[Option[String]] = column[Option[String]]("items", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column punches SqlType(INT), Default(Some(1)) */
    val punches: Rep[Option[Int]] = column[Option[Int]]("punches", O.Default(Some(1)))
  }
  /** Collection-like TableQuery object for table PunchCardTransactions */
  lazy val PunchCardTransactions = new TableQuery(tag => new PunchCardTransactions(tag))

  /** Row type of table PunchCardTypes */
  type PunchCardTypesRow = HCons[Int,HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Int,HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[String],HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[Int],HCons[Option[Int],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for PunchCardTypesRow providing default values if available in the database schema. */
  def PunchCardTypesRow(id: Int, name: Option[String] = None, description: Option[String] = None, numPunches: Option[Int] = None, default: Option[Boolean] = None, perStore: Option[Boolean] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, label: Option[String] = None, prizeId: Option[Int] = None, prizeType: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, punchCardsCount: Int = 0, responseInterval: Option[Int] = None, responseIntervalUnit: Option[String] = None, responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, responseMaxPerMember: Option[Int] = None, responseMaxPerMemberUnit: Option[String] = None, allowResponses: Option[Boolean] = Some(true), responseTier: Option[String] = None, responseMetricAmount: Option[scala.math.BigDecimal] = None, responseMetricName: Option[String] = None, metricName: Option[String] = None, expirationType: String = "none", expirationDate: Option[java.sql.Timestamp] = None, expirationNumDays: Option[Int] = None, templateSetVersionId: Option[Int] = Some(0)): PunchCardTypesRow = {
    id :: name :: description :: numPunches :: default :: perStore :: createdAt :: updatedAt :: publishedAt :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: label :: prizeId :: prizeType :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: punchCardsCount :: responseInterval :: responseIntervalUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseMaxPerMember :: responseMaxPerMemberUnit :: allowResponses :: responseTier :: responseMetricAmount :: responseMetricName :: metricName :: expirationType :: expirationDate :: expirationNumDays :: templateSetVersionId :: HNil
  }
  /** GetResult implicit for fetching PunchCardTypesRow objects using plain SQL queries */
  implicit def GetResultPunchCardTypesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[Boolean]], e4: GR[Option[java.sql.Timestamp]], e5: GR[String], e6: GR[Option[scala.math.BigDecimal]]): GR[PunchCardTypesRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[Boolean] :: <<?[Boolean] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<[Int] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[Int] :: <<?[Int] :: HNil
  }
  /** Table description of table punch_card_types. Objects of this class serve as prototypes for rows in queries. */
  class PunchCardTypes(_tableTag: Tag) extends Table[PunchCardTypesRow](_tableTag, "punch_card_types") {
    def * = id :: name :: description :: numPunches :: default :: perStore :: createdAt :: updatedAt :: publishedAt :: status :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: label :: prizeId :: prizeType :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: punchCardsCount :: responseInterval :: responseIntervalUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseMaxPerMember :: responseMaxPerMemberUnit :: allowResponses :: responseTier :: responseMetricAmount :: responseMetricName :: metricName :: expirationType :: expirationDate :: expirationNumDays :: templateSetVersionId :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column num_punches SqlType(INT), Default(None) */
    val numPunches: Rep[Option[Int]] = column[Option[Int]]("num_punches", O.Default(None))
    /** Database column default SqlType(BIT), Default(None) */
    val default: Rep[Option[Boolean]] = column[Option[Boolean]]("default", O.Default(None))
    /** Database column per_store SqlType(BIT), Default(None) */
    val perStore: Rep[Option[Boolean]] = column[Option[Boolean]]("per_store", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column punch_cards_count SqlType(INT), Default(0) */
    val punchCardsCount: Rep[Int] = column[Int]("punch_cards_count", O.Default(0))
    /** Database column response_interval SqlType(INT), Default(None) */
    val responseInterval: Rep[Option[Int]] = column[Option[Int]]("response_interval", O.Default(None))
    /** Database column response_interval_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseIntervalUnit: Rep[Option[String]] = column[Option[String]]("response_interval_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_per_member SqlType(INT), Default(None) */
    val responseMaxPerMember: Rep[Option[Int]] = column[Option[Int]]("response_max_per_member", O.Default(None))
    /** Database column response_max_per_member_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxPerMemberUnit: Rep[Option[String]] = column[Option[String]]("response_max_per_member_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column response_metric_amount SqlType(DECIMAL), Default(None) */
    val responseMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("response_metric_amount", O.Default(None))
    /** Database column response_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val responseMetricName: Rep[Option[String]] = column[Option[String]]("response_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column expiration_type SqlType(VARCHAR), Length(10,true), Default(none) */
    val expirationType: Rep[String] = column[String]("expiration_type", O.Length(10,varying=true), O.Default("none"))
    /** Database column expiration_date SqlType(DATETIME), Default(None) */
    val expirationDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("expiration_date", O.Default(None))
    /** Database column expiration_num_days SqlType(INT), Default(None) */
    val expirationNumDays: Rep[Option[Int]] = column[Option[Int]]("expiration_num_days", O.Default(None))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
  }
  /** Collection-like TableQuery object for table PunchCardTypes */
  lazy val PunchCardTypes = new TableQuery(tag => new PunchCardTypes(tag))

  /** Entity class storing rows of table ReceiptItems
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param receiptId Database column receipt_id SqlType(INT), Default(None)
   *  @param codeId Database column code_id SqlType(INT), Default(None)
   *  @param scannedCodeValue Database column scanned_code_value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param amount Database column amount SqlType(DECIMAL), Default(None)
   *  @param submissionType Database column submission_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param comment Database column comment SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param metricAmount Database column metric_amount SqlType(DECIMAL), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdById Database column created_by_id SqlType(INT), Default(None)
   *  @param lastUpdatedById Database column last_updated_by_id SqlType(INT), Default(None)
   *  @param scannedCodeDescription Database column scanned_code_description SqlType(TEXT), Default(None)
   *  @param scannedCodeLabel Database column scanned_code_label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None) */
  case class ReceiptItemsRow(id: Int, receiptId: Option[Int] = None, codeId: Option[Int] = None, scannedCodeValue: Option[String] = None, amount: Option[scala.math.BigDecimal] = None, submissionType: Option[String] = None, comment: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, metricAmount: Option[scala.math.BigDecimal] = None, metricName: Option[String] = None, createdById: Option[Int] = None, lastUpdatedById: Option[Int] = None, scannedCodeDescription: Option[String] = None, scannedCodeLabel: Option[String] = None, properties: Option[String] = None)
  /** GetResult implicit for fetching ReceiptItemsRow objects using plain SQL queries */
  implicit def GetResultReceiptItemsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]]): GR[ReceiptItemsRow] = GR{
    prs => import prs._
    ReceiptItemsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[scala.math.BigDecimal], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[scala.math.BigDecimal], <<?[String], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String]))
  }
  /** Table description of table receipt_items. Objects of this class serve as prototypes for rows in queries. */
  class ReceiptItems(_tableTag: Tag) extends Table[ReceiptItemsRow](_tableTag, "receipt_items") {
    def * = (id, receiptId, codeId, scannedCodeValue, amount, submissionType, comment, createdAt, updatedAt, metricAmount, metricName, createdById, lastUpdatedById, scannedCodeDescription, scannedCodeLabel, properties) <> (ReceiptItemsRow.tupled, ReceiptItemsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), receiptId, codeId, scannedCodeValue, amount, submissionType, comment, createdAt, updatedAt, metricAmount, metricName, createdById, lastUpdatedById, scannedCodeDescription, scannedCodeLabel, properties).shaped.<>({r=>import r._; _1.map(_=> ReceiptItemsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column receipt_id SqlType(INT), Default(None) */
    val receiptId: Rep[Option[Int]] = column[Option[Int]]("receipt_id", O.Default(None))
    /** Database column code_id SqlType(INT), Default(None) */
    val codeId: Rep[Option[Int]] = column[Option[Int]]("code_id", O.Default(None))
    /** Database column scanned_code_value SqlType(VARCHAR), Length(255,true), Default(None) */
    val scannedCodeValue: Rep[Option[String]] = column[Option[String]]("scanned_code_value", O.Length(255,varying=true), O.Default(None))
    /** Database column amount SqlType(DECIMAL), Default(None) */
    val amount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("amount", O.Default(None))
    /** Database column submission_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val submissionType: Rep[Option[String]] = column[Option[String]]("submission_type", O.Length(50,varying=true), O.Default(None))
    /** Database column comment SqlType(TEXT), Default(None) */
    val comment: Rep[Option[String]] = column[Option[String]]("comment", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column created_by_id SqlType(INT), Default(None) */
    val createdById: Rep[Option[Int]] = column[Option[Int]]("created_by_id", O.Default(None))
    /** Database column last_updated_by_id SqlType(INT), Default(None) */
    val lastUpdatedById: Rep[Option[Int]] = column[Option[Int]]("last_updated_by_id", O.Default(None))
    /** Database column scanned_code_description SqlType(TEXT), Default(None) */
    val scannedCodeDescription: Rep[Option[String]] = column[Option[String]]("scanned_code_description", O.Default(None))
    /** Database column scanned_code_label SqlType(VARCHAR), Length(255,true), Default(None) */
    val scannedCodeLabel: Rep[Option[String]] = column[Option[String]]("scanned_code_label", O.Length(255,varying=true), O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))

    /** Index over (receiptId) (database name index_receipt_items_on_receipt_id) */
    val index1 = index("index_receipt_items_on_receipt_id", receiptId)
    /** Index over (receiptId,codeId) (database name index_receipt_items_on_receipt_id_and_code_id) */
    val index2 = index("index_receipt_items_on_receipt_id_and_code_id", (receiptId, codeId))
  }
  /** Collection-like TableQuery object for table ReceiptItems */
  lazy val ReceiptItems = new TableQuery(tag => new ReceiptItems(tag))

  /** Row type of table Receipts */
  type ReceiptsRow = HCons[Int,HCons[Option[Int],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for ReceiptsRow providing default values if available in the database schema. */
  def ReceiptsRow(id: Int, memberId: Option[Int] = None, orNumber: Option[String] = None, orDate: Option[java.sql.Timestamp] = None, attachmentFileName: Option[String] = None, attachmentContentType: Option[String] = None, attachmentFileSize: Option[Int] = None, attachmentUpdatedAt: Option[java.sql.Timestamp] = None, amount: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), uploadedVia: Option[String] = None, emailSubject: Option[String] = None, receiptStatus: Option[String] = None, outcome: Option[String] = None, orContent: Option[String] = None, comment: Option[String] = None, parserUsed: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, metricAmount: Option[scala.math.BigDecimal] = None, metricName: Option[String] = None, activitySubmitted: Option[Boolean] = Some(false), vendor: Option[String] = None, createdById: Option[Int] = None, lastUpdatedById: Option[Int] = None, processingType: Option[String] = None, scanResult: Option[String] = None, integrationId: Option[String] = None, purchaseType: Option[String] = None, email: Option[String] = None, phone: Option[String] = None, optIn: Option[Boolean] = None, skipEarnRule: Option[Boolean] = Some(true), mimeUrl: Option[String] = None, properties: Option[String] = None, placeId: Option[Int] = None): ReceiptsRow = {
    id :: memberId :: orNumber :: orDate :: attachmentFileName :: attachmentContentType :: attachmentFileSize :: attachmentUpdatedAt :: amount :: uploadedVia :: emailSubject :: receiptStatus :: outcome :: orContent :: comment :: parserUsed :: createdAt :: updatedAt :: metricAmount :: metricName :: activitySubmitted :: vendor :: createdById :: lastUpdatedById :: processingType :: scanResult :: integrationId :: purchaseType :: email :: phone :: optIn :: skipEarnRule :: mimeUrl :: properties :: placeId :: HNil
  }
  /** GetResult implicit for fetching ReceiptsRow objects using plain SQL queries */
  implicit def GetResultReceiptsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[scala.math.BigDecimal]], e5: GR[Option[Boolean]]): GR[ReceiptsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Int] :: HNil
  }
  /** Table description of table receipts. Objects of this class serve as prototypes for rows in queries. */
  class Receipts(_tableTag: Tag) extends Table[ReceiptsRow](_tableTag, "receipts") {
    def * = id :: memberId :: orNumber :: orDate :: attachmentFileName :: attachmentContentType :: attachmentFileSize :: attachmentUpdatedAt :: amount :: uploadedVia :: emailSubject :: receiptStatus :: outcome :: orContent :: comment :: parserUsed :: createdAt :: updatedAt :: metricAmount :: metricName :: activitySubmitted :: vendor :: createdById :: lastUpdatedById :: processingType :: scanResult :: integrationId :: purchaseType :: email :: phone :: optIn :: skipEarnRule :: mimeUrl :: properties :: placeId :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column or_number SqlType(VARCHAR), Length(255,true), Default(None) */
    val orNumber: Rep[Option[String]] = column[Option[String]]("or_number", O.Length(255,varying=true), O.Default(None))
    /** Database column or_date SqlType(DATETIME), Default(None) */
    val orDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("or_date", O.Default(None))
    /** Database column attachment_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentFileName: Rep[Option[String]] = column[Option[String]]("attachment_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val attachmentContentType: Rep[Option[String]] = column[Option[String]]("attachment_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column attachment_file_size SqlType(INT), Default(None) */
    val attachmentFileSize: Rep[Option[Int]] = column[Option[Int]]("attachment_file_size", O.Default(None))
    /** Database column attachment_updated_at SqlType(DATETIME), Default(None) */
    val attachmentUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("attachment_updated_at", O.Default(None))
    /** Database column amount SqlType(DECIMAL), Default(Some(0.00)) */
    val amount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("amount", O.Default(Some(BigDecimal("0.00"))))
    /** Database column uploaded_via SqlType(VARCHAR), Length(255,true), Default(None) */
    val uploadedVia: Rep[Option[String]] = column[Option[String]]("uploaded_via", O.Length(255,varying=true), O.Default(None))
    /** Database column email_subject SqlType(VARCHAR), Length(255,true), Default(None) */
    val emailSubject: Rep[Option[String]] = column[Option[String]]("email_subject", O.Length(255,varying=true), O.Default(None))
    /** Database column receipt_status SqlType(VARCHAR), Length(50,true), Default(None) */
    val receiptStatus: Rep[Option[String]] = column[Option[String]]("receipt_status", O.Length(50,varying=true), O.Default(None))
    /** Database column outcome SqlType(VARCHAR), Length(100,true), Default(None) */
    val outcome: Rep[Option[String]] = column[Option[String]]("outcome", O.Length(100,varying=true), O.Default(None))
    /** Database column or_content SqlType(LONGTEXT), Length(2147483647,true), Default(None) */
    val orContent: Rep[Option[String]] = column[Option[String]]("or_content", O.Length(2147483647,varying=true), O.Default(None))
    /** Database column comment SqlType(TEXT), Default(None) */
    val comment: Rep[Option[String]] = column[Option[String]]("comment", O.Default(None))
    /** Database column parser_used SqlType(VARCHAR), Length(255,true), Default(None) */
    val parserUsed: Rep[Option[String]] = column[Option[String]]("parser_used", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column activity_submitted SqlType(BIT), Default(Some(false)) */
    val activitySubmitted: Rep[Option[Boolean]] = column[Option[Boolean]]("activity_submitted", O.Default(Some(false)))
    /** Database column vendor SqlType(VARCHAR), Length(255,true), Default(None) */
    val vendor: Rep[Option[String]] = column[Option[String]]("vendor", O.Length(255,varying=true), O.Default(None))
    /** Database column created_by_id SqlType(INT), Default(None) */
    val createdById: Rep[Option[Int]] = column[Option[Int]]("created_by_id", O.Default(None))
    /** Database column last_updated_by_id SqlType(INT), Default(None) */
    val lastUpdatedById: Rep[Option[Int]] = column[Option[Int]]("last_updated_by_id", O.Default(None))
    /** Database column processing_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val processingType: Rep[Option[String]] = column[Option[String]]("processing_type", O.Length(50,varying=true), O.Default(None))
    /** Database column scan_result SqlType(MEDIUMTEXT), Length(16777215,true), Default(None) */
    val scanResult: Rep[Option[String]] = column[Option[String]]("scan_result", O.Length(16777215,varying=true), O.Default(None))
    /** Database column integration_id SqlType(VARCHAR), Length(255,true), Default(None) */
    val integrationId: Rep[Option[String]] = column[Option[String]]("integration_id", O.Length(255,varying=true), O.Default(None))
    /** Database column purchase_type SqlType(VARCHAR), Length(150,true), Default(None) */
    val purchaseType: Rep[Option[String]] = column[Option[String]]("purchase_type", O.Length(150,varying=true), O.Default(None))
    /** Database column email SqlType(VARCHAR), Length(255,true), Default(None) */
    val email: Rep[Option[String]] = column[Option[String]]("email", O.Length(255,varying=true), O.Default(None))
    /** Database column phone SqlType(VARCHAR), Length(100,true), Default(None) */
    val phone: Rep[Option[String]] = column[Option[String]]("phone", O.Length(100,varying=true), O.Default(None))
    /** Database column opt_in SqlType(BIT), Default(None) */
    val optIn: Rep[Option[Boolean]] = column[Option[Boolean]]("opt_in", O.Default(None))
    /** Database column skip_earn_rule SqlType(BIT), Default(Some(true)) */
    val skipEarnRule: Rep[Option[Boolean]] = column[Option[Boolean]]("skip_earn_rule", O.Default(Some(true)))
    /** Database column mime_url SqlType(VARCHAR), Length(255,true), Default(None) */
    val mimeUrl: Rep[Option[String]] = column[Option[String]]("mime_url", O.Length(255,varying=true), O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column place_id SqlType(INT), Default(None) */
    val placeId: Rep[Option[Int]] = column[Option[Int]]("place_id", O.Default(None))

    /** Index over (attachmentContentType) (database name index_receipts_on_attachment_content_type) */
    val index1 = index("index_receipts_on_attachment_content_type", attachmentContentType :: HNil)
    /** Uniqueness Index over (integrationId) (database name index_receipts_on_integration_id) */
    val index2 = index("index_receipts_on_integration_id", integrationId :: HNil, unique=true)
    /** Index over (memberId) (database name index_receipts_on_member_id) */
    val index3 = index("index_receipts_on_member_id", memberId :: HNil)
    /** Index over (memberId,activitySubmitted) (database name index_receipts_on_member_id_and_activity_submitted) */
    val index4 = index("index_receipts_on_member_id_and_activity_submitted", memberId :: activitySubmitted :: HNil)
    /** Index over (orNumber) (database name index_receipts_on_or_number) */
    val index5 = index("index_receipts_on_or_number", orNumber :: HNil)
    /** Index over (outcome) (database name index_receipts_on_outcome) */
    val index6 = index("index_receipts_on_outcome", outcome :: HNil)
    /** Index over (receiptStatus) (database name index_receipts_on_receipt_status) */
    val index7 = index("index_receipts_on_receipt_status", receiptStatus :: HNil)
    /** Index over (uploadedVia) (database name index_receipts_on_uploaded_via) */
    val index8 = index("index_receipts_on_uploaded_via", uploadedVia :: HNil)
    /** Index over (vendor) (database name index_receipts_on_vendor) */
    val index9 = index("index_receipts_on_vendor", vendor :: HNil)
  }
  /** Collection-like TableQuery object for table Receipts */
  lazy val Receipts = new TableQuery(tag => new Receipts(tag))

  /** Row type of table Redemptions */
  type RedemptionsRow = HCons[Int,HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Int],HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[scala.math.BigDecimal,HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for RedemptionsRow providing default values if available in the database schema. */
  def RedemptionsRow(id: Int, memberId: Option[Int] = None, rewardId: Option[Int] = None, redemptionStatus: Option[String] = None, integrationId: Option[String] = None, responseMetricAmount: Option[scala.math.BigDecimal] = None, processedByBds: Option[String] = Some("N"), exportedAt: Option[java.sql.Timestamp] = None, importedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, responseMetricName: Option[String] = None, exportedBy: Option[Int] = None, importedBy: Option[Int] = None, addressId: Option[Int] = None, rewardConfiguration: Option[String] = None, sku: Option[String] = None, combinationValueId: Option[Int] = None, awardId: Option[Int] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeId: Option[Int] = None, approvalStatus: Option[String] = None, bdsProcessedFlag: Option[Boolean] = Some(false), certificateId: Option[Int] = None, certificateCodes: Option[String] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), responseCurrencyAmount: Option[scala.math.BigDecimal] = None, responseCurrencyName: Option[String] = None, autoReload: Option[Boolean] = None, reloadToken: Option[String] = None, paymentTxnId: Option[String] = None, clippedFromObject: Option[Boolean] = Some(false), grantingObjectId: Option[Int] = None, grantingObjectType: Option[String] = None, activityTs: Option[String] = None): RedemptionsRow = {
    id :: memberId :: rewardId :: redemptionStatus :: integrationId :: responseMetricAmount :: processedByBds :: exportedAt :: importedAt :: createdAt :: updatedAt :: responseMetricName :: exportedBy :: importedBy :: addressId :: rewardConfiguration :: sku :: combinationValueId :: awardId :: prizeType :: prizeMetricName :: prizeMetricAmount :: prizeId :: approvalStatus :: bdsProcessedFlag :: certificateId :: certificateCodes :: metricName :: metricAmount :: businessValue :: responseCurrencyAmount :: responseCurrencyName :: autoReload :: reloadToken :: paymentTxnId :: clippedFromObject :: grantingObjectId :: grantingObjectType :: activityTs :: HNil
  }
  /** GetResult implicit for fetching RedemptionsRow objects using plain SQL queries */
  implicit def GetResultRedemptionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]], e6: GR[scala.math.BigDecimal]): GR[RedemptionsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Int] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[String] :: <<?[Boolean] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Boolean] :: <<?[Int] :: <<?[String] :: <<?[String] :: HNil
  }
  /** Table description of table redemptions. Objects of this class serve as prototypes for rows in queries. */
  class Redemptions(_tableTag: Tag) extends Table[RedemptionsRow](_tableTag, "redemptions") {
    def * = id :: memberId :: rewardId :: redemptionStatus :: integrationId :: responseMetricAmount :: processedByBds :: exportedAt :: importedAt :: createdAt :: updatedAt :: responseMetricName :: exportedBy :: importedBy :: addressId :: rewardConfiguration :: sku :: combinationValueId :: awardId :: prizeType :: prizeMetricName :: prizeMetricAmount :: prizeId :: approvalStatus :: bdsProcessedFlag :: certificateId :: certificateCodes :: metricName :: metricAmount :: businessValue :: responseCurrencyAmount :: responseCurrencyName :: autoReload :: reloadToken :: paymentTxnId :: clippedFromObject :: grantingObjectId :: grantingObjectType :: activityTs :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column reward_id SqlType(INT), Default(None) */
    val rewardId: Rep[Option[Int]] = column[Option[Int]]("reward_id", O.Default(None))
    /** Database column redemption_status SqlType(VARCHAR), Length(100,true), Default(None) */
    val redemptionStatus: Rep[Option[String]] = column[Option[String]]("redemption_status", O.Length(100,varying=true), O.Default(None))
    /** Database column integration_id SqlType(VARCHAR), Length(100,true), Default(None) */
    val integrationId: Rep[Option[String]] = column[Option[String]]("integration_id", O.Length(100,varying=true), O.Default(None))
    /** Database column response_metric_amount SqlType(DECIMAL), Default(None) */
    val responseMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("response_metric_amount", O.Default(None))
    /** Database column processed_by_bds SqlType(VARCHAR), Length(10,true), Default(Some(N)) */
    val processedByBds: Rep[Option[String]] = column[Option[String]]("processed_by_bds", O.Length(10,varying=true), O.Default(Some("N")))
    /** Database column exported_at SqlType(DATETIME), Default(None) */
    val exportedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("exported_at", O.Default(None))
    /** Database column imported_at SqlType(DATETIME), Default(None) */
    val importedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("imported_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column response_metric_name SqlType(VARCHAR), Length(150,true), Default(None) */
    val responseMetricName: Rep[Option[String]] = column[Option[String]]("response_metric_name", O.Length(150,varying=true), O.Default(None))
    /** Database column exported_by SqlType(INT), Default(None) */
    val exportedBy: Rep[Option[Int]] = column[Option[Int]]("exported_by", O.Default(None))
    /** Database column imported_by SqlType(INT), Default(None) */
    val importedBy: Rep[Option[Int]] = column[Option[Int]]("imported_by", O.Default(None))
    /** Database column address_id SqlType(INT), Default(None) */
    val addressId: Rep[Option[Int]] = column[Option[Int]]("address_id", O.Default(None))
    /** Database column reward_configuration SqlType(TEXT), Default(None) */
    val rewardConfiguration: Rep[Option[String]] = column[Option[String]]("reward_configuration", O.Default(None))
    /** Database column sku SqlType(VARCHAR), Length(255,true), Default(None) */
    val sku: Rep[Option[String]] = column[Option[String]]("sku", O.Length(255,varying=true), O.Default(None))
    /** Database column combination_value_id SqlType(INT), Default(None) */
    val combinationValueId: Rep[Option[Int]] = column[Option[Int]]("combination_value_id", O.Default(None))
    /** Database column award_id SqlType(INT), Default(None) */
    val awardId: Rep[Option[Int]] = column[Option[Int]]("award_id", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column approval_status SqlType(VARCHAR), Length(30,true), Default(None) */
    val approvalStatus: Rep[Option[String]] = column[Option[String]]("approval_status", O.Length(30,varying=true), O.Default(None))
    /** Database column bds_processed_flag SqlType(BIT), Default(Some(false)) */
    val bdsProcessedFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("bds_processed_flag", O.Default(Some(false)))
    /** Database column certificate_id SqlType(INT), Default(None) */
    val certificateId: Rep[Option[Int]] = column[Option[Int]]("certificate_id", O.Default(None))
    /** Database column certificate_codes SqlType(TEXT), Default(None) */
    val certificateCodes: Rep[Option[String]] = column[Option[String]]("certificate_codes", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column response_currency_amount SqlType(DECIMAL), Default(None) */
    val responseCurrencyAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("response_currency_amount", O.Default(None))
    /** Database column response_currency_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val responseCurrencyName: Rep[Option[String]] = column[Option[String]]("response_currency_name", O.Length(255,varying=true), O.Default(None))
    /** Database column auto_reload SqlType(BIT), Default(None) */
    val autoReload: Rep[Option[Boolean]] = column[Option[Boolean]]("auto_reload", O.Default(None))
    /** Database column reload_token SqlType(VARCHAR), Length(255,true), Default(None) */
    val reloadToken: Rep[Option[String]] = column[Option[String]]("reload_token", O.Length(255,varying=true), O.Default(None))
    /** Database column payment_txn_id SqlType(VARCHAR), Length(50,true), Default(None) */
    val paymentTxnId: Rep[Option[String]] = column[Option[String]]("payment_txn_id", O.Length(50,varying=true), O.Default(None))
    /** Database column clipped_from_object SqlType(BIT), Default(Some(false)) */
    val clippedFromObject: Rep[Option[Boolean]] = column[Option[Boolean]]("clipped_from_object", O.Default(Some(false)))
    /** Database column granting_object_id SqlType(INT), Default(None) */
    val grantingObjectId: Rep[Option[Int]] = column[Option[Int]]("granting_object_id", O.Default(None))
    /** Database column granting_object_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val grantingObjectType: Rep[Option[String]] = column[Option[String]]("granting_object_type", O.Length(255,varying=true), O.Default(None))
    /** Database column activity_ts SqlType(VARCHAR), Length(50,true), Default(None) */
    val activityTs: Rep[Option[String]] = column[Option[String]]("activity_ts", O.Length(50,varying=true), O.Default(None))

    /** Index over (addressId) (database name index_redemptions_on_address_id) */
    val index1 = index("index_redemptions_on_address_id", addressId :: HNil)
    /** Index over (awardId) (database name index_redemptions_on_award_id) */
    val index2 = index("index_redemptions_on_award_id", awardId :: HNil)
    /** Index over (certificateId) (database name index_redemptions_on_certificate_id) */
    val index3 = index("index_redemptions_on_certificate_id", certificateId :: HNil)
    /** Index over (combinationValueId) (database name index_redemptions_on_combination_value_id) */
    val index4 = index("index_redemptions_on_combination_value_id", combinationValueId :: HNil)
    /** Index over (memberId,rewardId) (database name index_redemptions_on_member_id_and_reward_id) */
    val index5 = index("index_redemptions_on_member_id_and_reward_id", memberId :: rewardId :: HNil)
    /** Index over (rewardId) (database name index_redemptions_on_reward_id) */
    val index6 = index("index_redemptions_on_reward_id", rewardId :: HNil)
  }
  /** Collection-like TableQuery object for table Redemptions */
  lazy val Redemptions = new TableQuery(tag => new Redemptions(tag))

  /** Entity class storing rows of table ReferralCodes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class ReferralCodesRow(id: Int, memberId: Option[Int] = None, code: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching ReferralCodesRow objects using plain SQL queries */
  implicit def GetResultReferralCodesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ReferralCodesRow] = GR{
    prs => import prs._
    ReferralCodesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table referral_codes. Objects of this class serve as prototypes for rows in queries. */
  class ReferralCodes(_tableTag: Tag) extends Table[ReferralCodesRow](_tableTag, "referral_codes") {
    def * = (id, memberId, code, createdAt, updatedAt) <> (ReferralCodesRow.tupled, ReferralCodesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, code, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> ReferralCodesRow.tupled((_1.get, _2, _3, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(255,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (code) (database name index_referral_codes_on_code) */
    val index1 = index("index_referral_codes_on_code", code, unique=true)
    /** Index over (memberId) (database name index_referral_codes_on_member_id) */
    val index2 = index("index_referral_codes_on_member_id", memberId)
  }
  /** Collection-like TableQuery object for table ReferralCodes */
  lazy val ReferralCodes = new TableQuery(tag => new ReferralCodes(tag))

  /** Entity class storing rows of table ResponseTypes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param challengeId Database column challenge_id SqlType(INT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param shareOnActivityFeed Database column share_on_activity_feed SqlType(VARCHAR), Length(50,true), Default(None) */
  case class ResponseTypesRow(id: Int, challengeId: Option[Int] = None, `type`: Option[String] = None, properties: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, shareOnActivityFeed: Option[String] = None)
  /** GetResult implicit for fetching ResponseTypesRow objects using plain SQL queries */
  implicit def GetResultResponseTypesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[ResponseTypesRow] = GR{
    prs => import prs._
    ResponseTypesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table response_types. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class ResponseTypes(_tableTag: Tag) extends Table[ResponseTypesRow](_tableTag, "response_types") {
    def * = (id, challengeId, `type`, properties, createdAt, updatedAt, shareOnActivityFeed) <> (ResponseTypesRow.tupled, ResponseTypesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), challengeId, `type`, properties, createdAt, updatedAt, shareOnActivityFeed).shaped.<>({r=>import r._; _1.map(_=> ResponseTypesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column challenge_id SqlType(INT), Default(None) */
    val challengeId: Rep[Option[Int]] = column[Option[Int]]("challenge_id", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column share_on_activity_feed SqlType(VARCHAR), Length(50,true), Default(None) */
    val shareOnActivityFeed: Rep[Option[String]] = column[Option[String]]("share_on_activity_feed", O.Length(50,varying=true), O.Default(None))

    /** Index over (challengeId) (database name index_response_types_on_challenge_id) */
    val index1 = index("index_response_types_on_challenge_id", challengeId)
  }
  /** Collection-like TableQuery object for table ResponseTypes */
  lazy val ResponseTypes = new TableQuery(tag => new ResponseTypes(tag))

  /** Entity class storing rows of table RewardActions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param rewardId Database column reward_id SqlType(INT), Default(None)
   *  @param viewedAt Database column viewed_at SqlType(DATETIME), Default(None)
   *  @param respondedAt Database column responded_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class RewardActionsRow(id: Int, memberId: Option[Int] = None, rewardId: Option[Int] = None, viewedAt: Option[java.sql.Timestamp] = None, respondedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching RewardActionsRow objects using plain SQL queries */
  implicit def GetResultRewardActionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[RewardActionsRow] = GR{
    prs => import prs._
    RewardActionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table reward_actions. Objects of this class serve as prototypes for rows in queries. */
  class RewardActions(_tableTag: Tag) extends Table[RewardActionsRow](_tableTag, "reward_actions") {
    def * = (id, memberId, rewardId, viewedAt, respondedAt, createdAt, updatedAt) <> (RewardActionsRow.tupled, RewardActionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, rewardId, viewedAt, respondedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> RewardActionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column reward_id SqlType(INT), Default(None) */
    val rewardId: Rep[Option[Int]] = column[Option[Int]]("reward_id", O.Default(None))
    /** Database column viewed_at SqlType(DATETIME), Default(None) */
    val viewedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("viewed_at", O.Default(None))
    /** Database column responded_at SqlType(DATETIME), Default(None) */
    val respondedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("responded_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (memberId,rewardId) (database name index_reward_actions_on_member_id_and_reward_id) */
    val index1 = index("index_reward_actions_on_member_id_and_reward_id", (memberId, rewardId), unique=true)
    /** Index over (rewardId) (database name index_reward_actions_on_reward_id) */
    val index2 = index("index_reward_actions_on_reward_id", rewardId)
  }
  /** Collection-like TableQuery object for table RewardActions */
  lazy val RewardActions = new TableQuery(tag => new RewardActions(tag))

  /** Entity class storing rows of table RewardLocations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param rewardId Database column reward_id SqlType(INT)
   *  @param locationId Database column location_id SqlType(INT)
   *  @param locationType Database column location_type SqlType(VARCHAR), Length(255,true)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class RewardLocationsRow(id: Int, rewardId: Int, locationId: Int, locationType: String, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching RewardLocationsRow objects using plain SQL queries */
  implicit def GetResultRewardLocationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Boolean], e3: GR[Option[java.sql.Timestamp]]): GR[RewardLocationsRow] = GR{
    prs => import prs._
    RewardLocationsRow.tupled((<<[Int], <<[Int], <<[Int], <<[String], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table reward_locations. Objects of this class serve as prototypes for rows in queries. */
  class RewardLocations(_tableTag: Tag) extends Table[RewardLocationsRow](_tableTag, "reward_locations") {
    def * = (id, rewardId, locationId, locationType, included, createdAt, updatedAt) <> (RewardLocationsRow.tupled, RewardLocationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(rewardId), Rep.Some(locationId), Rep.Some(locationType), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> RewardLocationsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5.get, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column reward_id SqlType(INT) */
    val rewardId: Rep[Int] = column[Int]("reward_id")
    /** Database column location_id SqlType(INT) */
    val locationId: Rep[Int] = column[Int]("location_id")
    /** Database column location_type SqlType(VARCHAR), Length(255,true) */
    val locationType: Rep[String] = column[String]("location_type", O.Length(255,varying=true))
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (locationId) (database name index_reward_locations_on_location_id) */
    val index1 = index("index_reward_locations_on_location_id", locationId)
    /** Uniqueness Index over (rewardId,locationId) (database name index_reward_locations_on_reward_id_and_location_id) */
    val index2 = index("index_reward_locations_on_reward_id_and_location_id", (rewardId, locationId), unique=true)
  }
  /** Collection-like TableQuery object for table RewardLocations */
  lazy val RewardLocations = new TableQuery(tag => new RewardLocations(tag))

  /** Entity class storing rows of table RewardPrizes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param rewardId Database column reward_id SqlType(INT), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeId Database column prize_id SqlType(INT), Default(None)
   *  @param prizeMetricAmount Database column prize_metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeMetricName Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param prizeFrequency Database column prize_frequency SqlType(INT), Default(None)
   *  @param prizeProbability Database column prize_probability SqlType(DECIMAL), Default(None)
   *  @param numberOfWinners Database column number_of_winners SqlType(INT), Default(Some(0))
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class RewardPrizesRow(id: Int, rewardId: Option[Int] = None, name: String, label: String, description: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, prizeType: Option[String] = None, prizeId: Option[Int] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeMetricName: Option[String] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[scala.math.BigDecimal] = None, numberOfWinners: Option[Int] = Some(0), createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching RewardPrizesRow objects using plain SQL queries */
  implicit def GetResultRewardPrizesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[scala.math.BigDecimal]]): GR[RewardPrizesRow] = GR{
    prs => import prs._
    RewardPrizesRow.tupled((<<[Int], <<?[Int], <<[String], <<[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[scala.math.BigDecimal], <<?[String], <<?[Int], <<?[scala.math.BigDecimal], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table reward_prizes. Objects of this class serve as prototypes for rows in queries. */
  class RewardPrizes(_tableTag: Tag) extends Table[RewardPrizesRow](_tableTag, "reward_prizes") {
    def * = (id, rewardId, name, label, description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, prizeType, prizeId, prizeMetricAmount, prizeMetricName, prizeFrequency, prizeProbability, numberOfWinners, createdAt, updatedAt) <> (RewardPrizesRow.tupled, RewardPrizesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), rewardId, Rep.Some(name), Rep.Some(label), description, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, prizeType, prizeId, prizeMetricAmount, prizeMetricName, prizeFrequency, prizeProbability, numberOfWinners, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> RewardPrizesRow.tupled((_1.get, _2, _3.get, _4.get, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column reward_id SqlType(INT), Default(None) */
    val rewardId: Rep[Option[Int]] = column[Option[Int]]("reward_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(VARCHAR), Length(255,true), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(DECIMAL), Default(None) */
    val prizeProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_probability", O.Default(None))
    /** Database column number_of_winners SqlType(INT), Default(Some(0)) */
    val numberOfWinners: Rep[Option[Int]] = column[Option[Int]]("number_of_winners", O.Default(Some(0)))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (rewardId) (database name index_reward_prizes_on_reward_id) */
    val index1 = index("index_reward_prizes_on_reward_id", rewardId)
  }
  /** Collection-like TableQuery object for table RewardPrizes */
  lazy val RewardPrizes = new TableQuery(tag => new RewardPrizes(tag))

  /** Entity class storing rows of table RewardResponsePrizes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param rewardResponseId Database column reward_response_id SqlType(INT), Default(None)
   *  @param rewardPrizeId Database column reward_prize_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param prizeType Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param prizeMetricName Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param prizeMetricAmount Database column prize_metric_amount SqlType(DECIMAL), Default(None)
   *  @param prizeId Database column prize_id SqlType(INT), Default(None) */
  case class RewardResponsePrizesRow(id: Int, rewardResponseId: Option[Int] = None, rewardPrizeId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, prizeType: Option[String] = None, prizeMetricName: Option[String] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeId: Option[Int] = None)
  /** GetResult implicit for fetching RewardResponsePrizesRow objects using plain SQL queries */
  implicit def GetResultRewardResponsePrizesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]], e4: GR[Option[scala.math.BigDecimal]]): GR[RewardResponsePrizesRow] = GR{
    prs => import prs._
    RewardResponsePrizesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[scala.math.BigDecimal], <<?[Int]))
  }
  /** Table description of table reward_response_prizes. Objects of this class serve as prototypes for rows in queries. */
  class RewardResponsePrizes(_tableTag: Tag) extends Table[RewardResponsePrizesRow](_tableTag, "reward_response_prizes") {
    def * = (id, rewardResponseId, rewardPrizeId, createdAt, updatedAt, prizeType, prizeMetricName, prizeMetricAmount, prizeId) <> (RewardResponsePrizesRow.tupled, RewardResponsePrizesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), rewardResponseId, rewardPrizeId, createdAt, updatedAt, prizeType, prizeMetricName, prizeMetricAmount, prizeId).shaped.<>({r=>import r._; _1.map(_=> RewardResponsePrizesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column reward_response_id SqlType(INT), Default(None) */
    val rewardResponseId: Rep[Option[Int]] = column[Option[Int]]("reward_response_id", O.Default(None))
    /** Database column reward_prize_id SqlType(INT), Default(None) */
    val rewardPrizeId: Rep[Option[Int]] = column[Option[Int]]("reward_prize_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))

    /** Index over (rewardPrizeId) (database name index_reward_response_prizes_on_reward_prize_id) */
    val index1 = index("index_reward_response_prizes_on_reward_prize_id", rewardPrizeId)
    /** Index over (rewardResponseId) (database name index_reward_response_prizes_on_reward_response_id) */
    val index2 = index("index_reward_response_prizes_on_reward_response_id", rewardResponseId)
  }
  /** Collection-like TableQuery object for table RewardResponsePrizes */
  lazy val RewardResponsePrizes = new TableQuery(tag => new RewardResponsePrizes(tag))

  /** Row type of table Rewards */
  type RewardsRow = HCons[Int,HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[Boolean],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[String,HCons[Option[Boolean],HCons[Option[String],HCons[Option[Int],HCons[String,HCons[Option[Boolean],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[Int],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[scala.math.BigDecimal,HCons[scala.math.BigDecimal,HCons[Int,HCons[scala.math.BigDecimal,HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HCons[Option[String],HCons[Option[scala.math.BigDecimal],HCons[Option[scala.math.BigDecimal],HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for RewardsRow providing default values if available in the database schema. */
  def RewardsRow(id: Int, programId: Option[Int] = None, name: Option[String] = None, description: Option[String] = None, sku: Option[String] = None, responseMetricAmount: Option[scala.math.BigDecimal] = None, responseMaxPerMember: Option[Int] = None, responseMaxPerMemberUnit: Option[String] = None, responseInterval: Option[Int] = None, responseIntervalUnit: Option[String] = None, responseMaxOverall: Option[Int] = None, responseMaxOverallUnit: Option[String] = None, responseTier: Option[String] = None, showInGallery: Option[Boolean] = Some(true), showInRewards: Option[Boolean] = Some(true), allowResponses: Option[Boolean] = Some(true), imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, status: Option[String] = Some("draft"), publishedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, responseMetricName: Option[String] = None, label: String, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, templateSetVersionId: Option[Int] = Some(0), rewardType: String, showToPublic: Option[Boolean] = Some(false), certificateDisplayText: Option[String] = None, newsFeedId: Option[Int] = None, shareOnNewsFeed: Option[String] = None, prizeType: Option[String] = None, prizeId: Option[Int] = None, prizeMetricAmount: Option[scala.math.BigDecimal] = None, prizeMetricName: Option[String] = None, prizeFrequency: Option[Int] = None, prizeProbability: Option[scala.math.BigDecimal] = None, properties: Option[String] = None, contestDrawDate: Option[java.sql.Timestamp] = None, certificateExternalSite: Option[String] = None, certificateExternalUrl: Option[String] = None, metricName: Option[String] = None, metricAmount: Option[scala.math.BigDecimal] = None, businessValue: scala.math.BigDecimal = BigDecimal("0.00"), aggregatedBusinessValue: scala.math.BigDecimal = BigDecimal("0.00"), responsesCount: Int = 0, aggregatedMetricAmount: scala.math.BigDecimal = BigDecimal("0.00"), responseCurrencyAmount: Option[scala.math.BigDecimal] = None, responseCurrencyName: Option[String] = None, currencyStep: Option[scala.math.BigDecimal] = None, paymentType: Option[String] = None, discountType: Option[String] = None, discountValue: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), discountMinSubtotal: Option[scala.math.BigDecimal] = Some(BigDecimal("0.00")), contestDrawDateTimezone: Option[String] = None): RewardsRow = {
    id :: programId :: name :: description :: sku :: responseMetricAmount :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: showInGallery :: showInRewards :: allowResponses :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: effectivityStart :: effectivityEnd :: effectivityTimezone :: status :: publishedAt :: createdAt :: updatedAt :: responseMetricName :: label :: recurring :: recurringSchedule :: templateSetVersionId :: rewardType :: showToPublic :: certificateDisplayText :: newsFeedId :: shareOnNewsFeed :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: properties :: contestDrawDate :: certificateExternalSite :: certificateExternalUrl :: metricName :: metricAmount :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: responseCurrencyAmount :: responseCurrencyName :: currencyStep :: paymentType :: discountType :: discountValue :: discountMinSubtotal :: contestDrawDateTimezone :: HNil
  }
  /** GetResult implicit for fetching RewardsRow objects using plain SQL queries */
  implicit def GetResultRewardsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[scala.math.BigDecimal]], e4: GR[Option[Boolean]], e5: GR[Option[java.sql.Timestamp]], e6: GR[String], e7: GR[scala.math.BigDecimal]): GR[RewardsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Boolean] :: <<?[Boolean] :: <<?[Boolean] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<[String] :: <<?[Boolean] :: <<?[String] :: <<?[Int] :: <<[String] :: <<?[Boolean] :: <<?[String] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[Int] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<[scala.math.BigDecimal] :: <<[Int] :: <<[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[String] :: <<?[String] :: <<?[scala.math.BigDecimal] :: <<?[scala.math.BigDecimal] :: <<?[String] :: HNil
  }
  /** Table description of table rewards. Objects of this class serve as prototypes for rows in queries. */
  class Rewards(_tableTag: Tag) extends Table[RewardsRow](_tableTag, "rewards") {
    def * = id :: programId :: name :: description :: sku :: responseMetricAmount :: responseMaxPerMember :: responseMaxPerMemberUnit :: responseInterval :: responseIntervalUnit :: responseMaxOverall :: responseMaxOverallUnit :: responseTier :: showInGallery :: showInRewards :: allowResponses :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: effectivityStart :: effectivityEnd :: effectivityTimezone :: status :: publishedAt :: createdAt :: updatedAt :: responseMetricName :: label :: recurring :: recurringSchedule :: templateSetVersionId :: rewardType :: showToPublic :: certificateDisplayText :: newsFeedId :: shareOnNewsFeed :: prizeType :: prizeId :: prizeMetricAmount :: prizeMetricName :: prizeFrequency :: prizeProbability :: properties :: contestDrawDate :: certificateExternalSite :: certificateExternalUrl :: metricName :: metricAmount :: businessValue :: aggregatedBusinessValue :: responsesCount :: aggregatedMetricAmount :: responseCurrencyAmount :: responseCurrencyName :: currencyStep :: paymentType :: discountType :: discountValue :: discountMinSubtotal :: contestDrawDateTimezone :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(100,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(100,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column sku SqlType(VARCHAR), Length(100,true), Default(None) */
    val sku: Rep[Option[String]] = column[Option[String]]("sku", O.Length(100,varying=true), O.Default(None))
    /** Database column response_metric_amount SqlType(DECIMAL), Default(None) */
    val responseMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("response_metric_amount", O.Default(None))
    /** Database column response_max_per_member SqlType(INT), Default(None) */
    val responseMaxPerMember: Rep[Option[Int]] = column[Option[Int]]("response_max_per_member", O.Default(None))
    /** Database column response_max_per_member_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxPerMemberUnit: Rep[Option[String]] = column[Option[String]]("response_max_per_member_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_interval SqlType(INT), Default(None) */
    val responseInterval: Rep[Option[Int]] = column[Option[Int]]("response_interval", O.Default(None))
    /** Database column response_interval_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseIntervalUnit: Rep[Option[String]] = column[Option[String]]("response_interval_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_max_overall SqlType(INT), Default(None) */
    val responseMaxOverall: Rep[Option[Int]] = column[Option[Int]]("response_max_overall", O.Default(None))
    /** Database column response_max_overall_unit SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseMaxOverallUnit: Rep[Option[String]] = column[Option[String]]("response_max_overall_unit", O.Length(25,varying=true), O.Default(None))
    /** Database column response_tier SqlType(VARCHAR), Length(25,true), Default(None) */
    val responseTier: Rep[Option[String]] = column[Option[String]]("response_tier", O.Length(25,varying=true), O.Default(None))
    /** Database column show_in_gallery SqlType(BIT), Default(Some(true)) */
    val showInGallery: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_gallery", O.Default(Some(true)))
    /** Database column show_in_rewards SqlType(BIT), Default(Some(true)) */
    val showInRewards: Rep[Option[Boolean]] = column[Option[Boolean]]("show_in_rewards", O.Default(Some(true)))
    /** Database column allow_responses SqlType(BIT), Default(Some(true)) */
    val allowResponses: Rep[Option[Boolean]] = column[Option[Boolean]]("allow_responses", O.Default(Some(true)))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(Some(draft)) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(Some("draft")))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column response_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val responseMetricName: Rep[Option[String]] = column[Option[String]]("response_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column template_set_version_id SqlType(INT), Default(Some(0)) */
    val templateSetVersionId: Rep[Option[Int]] = column[Option[Int]]("template_set_version_id", O.Default(Some(0)))
    /** Database column reward_type SqlType(VARCHAR), Length(50,true) */
    val rewardType: Rep[String] = column[String]("reward_type", O.Length(50,varying=true))
    /** Database column show_to_public SqlType(BIT), Default(Some(false)) */
    val showToPublic: Rep[Option[Boolean]] = column[Option[Boolean]]("show_to_public", O.Default(Some(false)))
    /** Database column certificate_display_text SqlType(TEXT), Default(None) */
    val certificateDisplayText: Rep[Option[String]] = column[Option[String]]("certificate_display_text", O.Default(None))
    /** Database column news_feed_id SqlType(INT), Default(None) */
    val newsFeedId: Rep[Option[Int]] = column[Option[Int]]("news_feed_id", O.Default(None))
    /** Database column share_on_news_feed SqlType(VARCHAR), Length(25,true), Default(None) */
    val shareOnNewsFeed: Rep[Option[String]] = column[Option[String]]("share_on_news_feed", O.Length(25,varying=true), O.Default(None))
    /** Database column prize_type SqlType(VARCHAR), Length(50,true), Default(None) */
    val prizeType: Rep[Option[String]] = column[Option[String]]("prize_type", O.Length(50,varying=true), O.Default(None))
    /** Database column prize_id SqlType(INT), Default(None) */
    val prizeId: Rep[Option[Int]] = column[Option[Int]]("prize_id", O.Default(None))
    /** Database column prize_metric_amount SqlType(DECIMAL), Default(None) */
    val prizeMetricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_metric_amount", O.Default(None))
    /** Database column prize_metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val prizeMetricName: Rep[Option[String]] = column[Option[String]]("prize_metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column prize_frequency SqlType(INT), Default(None) */
    val prizeFrequency: Rep[Option[Int]] = column[Option[Int]]("prize_frequency", O.Default(None))
    /** Database column prize_probability SqlType(DECIMAL), Default(None) */
    val prizeProbability: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("prize_probability", O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column contest_draw_date SqlType(DATETIME), Default(None) */
    val contestDrawDate: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("contest_draw_date", O.Default(None))
    /** Database column certificate_external_site SqlType(VARCHAR), Length(25,true), Default(None) */
    val certificateExternalSite: Rep[Option[String]] = column[Option[String]]("certificate_external_site", O.Length(25,varying=true), O.Default(None))
    /** Database column certificate_external_url SqlType(TEXT), Default(None) */
    val certificateExternalUrl: Rep[Option[String]] = column[Option[String]]("certificate_external_url", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_amount SqlType(DECIMAL), Default(None) */
    val metricAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("metric_amount", O.Default(None))
    /** Database column business_value SqlType(DECIMAL), Default(0.00) */
    val businessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("business_value", O.Default(BigDecimal("0.00")))
    /** Database column aggregated_business_value SqlType(DECIMAL), Default(0.00) */
    val aggregatedBusinessValue: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_business_value", O.Default(BigDecimal("0.00")))
    /** Database column responses_count SqlType(INT), Default(0) */
    val responsesCount: Rep[Int] = column[Int]("responses_count", O.Default(0))
    /** Database column aggregated_metric_amount SqlType(DECIMAL), Default(0.00) */
    val aggregatedMetricAmount: Rep[scala.math.BigDecimal] = column[scala.math.BigDecimal]("aggregated_metric_amount", O.Default(BigDecimal("0.00")))
    /** Database column response_currency_amount SqlType(DECIMAL), Default(None) */
    val responseCurrencyAmount: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("response_currency_amount", O.Default(None))
    /** Database column response_currency_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val responseCurrencyName: Rep[Option[String]] = column[Option[String]]("response_currency_name", O.Length(255,varying=true), O.Default(None))
    /** Database column currency_step SqlType(DECIMAL), Default(None) */
    val currencyStep: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("currency_step", O.Default(None))
    /** Database column payment_type SqlType(VARCHAR), Length(10,true), Default(None) */
    val paymentType: Rep[Option[String]] = column[Option[String]]("payment_type", O.Length(10,varying=true), O.Default(None))
    /** Database column discount_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val discountType: Rep[Option[String]] = column[Option[String]]("discount_type", O.Length(25,varying=true), O.Default(None))
    /** Database column discount_value SqlType(DECIMAL), Default(Some(0.00)) */
    val discountValue: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_value", O.Default(Some(BigDecimal("0.00"))))
    /** Database column discount_min_subtotal SqlType(DECIMAL), Default(Some(0.00)) */
    val discountMinSubtotal: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("discount_min_subtotal", O.Default(Some(BigDecimal("0.00"))))
    /** Database column contest_draw_date_timezone SqlType(VARCHAR), Length(255,true), Default(None) */
    val contestDrawDateTimezone: Rep[Option[String]] = column[Option[String]]("contest_draw_date_timezone", O.Length(255,varying=true), O.Default(None))

    /** Index over (newsFeedId) (database name index_rewards_on_news_feed_id) */
    val index1 = index("index_rewards_on_news_feed_id", newsFeedId :: HNil)
    /** Index over (templateSetVersionId) (database name index_rewards_on_template_set_version_id) */
    val index2 = index("index_rewards_on_template_set_version_id", templateSetVersionId :: HNil)
  }
  /** Collection-like TableQuery object for table Rewards */
  lazy val Rewards = new TableQuery(tag => new Rewards(tag))

  /** Entity class storing rows of table RewardSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param rewardId Database column reward_id SqlType(INT)
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(false)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class RewardSegmentsRow(id: Int, rewardId: Int, segmentId: Int, included: Boolean = false, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching RewardSegmentsRow objects using plain SQL queries */
  implicit def GetResultRewardSegmentsRow(implicit e0: GR[Int], e1: GR[Boolean], e2: GR[Option[java.sql.Timestamp]]): GR[RewardSegmentsRow] = GR{
    prs => import prs._
    RewardSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table reward_segments. Objects of this class serve as prototypes for rows in queries. */
  class RewardSegments(_tableTag: Tag) extends Table[RewardSegmentsRow](_tableTag, "reward_segments") {
    def * = (id, rewardId, segmentId, included, createdAt, updatedAt) <> (RewardSegmentsRow.tupled, RewardSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(rewardId), Rep.Some(segmentId), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> RewardSegmentsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column reward_id SqlType(INT) */
    val rewardId: Rep[Int] = column[Int]("reward_id")
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column included SqlType(BIT), Default(false) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(false))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (rewardId,segmentId) (database name index_reward_segments_on_reward_id_and_segment_id) */
    val index1 = index("index_reward_segments_on_reward_id_and_segment_id", (rewardId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_reward_segments_on_segment_id) */
    val index2 = index("index_reward_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table RewardSegments */
  lazy val RewardSegments = new TableQuery(tag => new RewardSegments(tag))

  /** Entity class storing rows of table RuleGroupCombinations
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(100,true)
   *  @param expression Database column expression SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param expressionType Database column expression_type SqlType(INT), Default(0)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
  case class RuleGroupCombinationsRow(id: Int, name: String, expression: Option[String] = None, expressionType: Int = 0, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Int, description: Option[String] = None, label: Option[String] = None)
  /** GetResult implicit for fetching RuleGroupCombinationsRow objects using plain SQL queries */
  implicit def GetResultRuleGroupCombinationsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[RuleGroupCombinationsRow] = GR{
    prs => import prs._
    RuleGroupCombinationsRow.tupled((<<[Int], <<[String], <<?[String], <<[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[Int], <<?[String], <<?[String]))
  }
  /** Table description of table rule_group_combinations. Objects of this class serve as prototypes for rows in queries. */
  class RuleGroupCombinations(_tableTag: Tag) extends Table[RuleGroupCombinationsRow](_tableTag, "rule_group_combinations") {
    def * = (id, name, expression, expressionType, createdAt, updatedAt, programId, description, label) <> (RuleGroupCombinationsRow.tupled, RuleGroupCombinationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), expression, Rep.Some(expressionType), createdAt, updatedAt, Rep.Some(programId), description, label).shaped.<>({r=>import r._; _1.map(_=> RuleGroupCombinationsRow.tupled((_1.get, _2.get, _3, _4.get, _5, _6, _7.get, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(100,true) */
    val name: Rep[String] = column[String]("name", O.Length(100,varying=true))
    /** Database column expression SqlType(VARCHAR), Length(255,true), Default(None) */
    val expression: Rep[Option[String]] = column[Option[String]]("expression", O.Length(255,varying=true), O.Default(None))
    /** Database column expression_type SqlType(INT), Default(0) */
    val expressionType: Rep[Int] = column[Int]("expression_type", O.Default(0))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT) */
    val programId: Rep[Int] = column[Int]("program_id")
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
  }
  /** Collection-like TableQuery object for table RuleGroupCombinations */
  lazy val RuleGroupCombinations = new TableQuery(tag => new RuleGroupCombinations(tag))

  /** Entity class storing rows of table RuleGroups
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param ruleGroupStrategyId Database column rule_group_strategy_id SqlType(INT), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(100,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class RuleGroupsRow(id: Int, ruleGroupStrategyId: Option[Int] = None, name: String, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Int, label: Option[String] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching RuleGroupsRow objects using plain SQL queries */
  implicit def GetResultRuleGroupsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[String], e3: GR[Option[String]], e4: GR[Option[java.sql.Timestamp]]): GR[RuleGroupsRow] = GR{
    prs => import prs._
    RuleGroupsRow.tupled((<<[Int], <<?[Int], <<[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[Int], <<?[String], <<?[Int]))
  }
  /** Table description of table rule_groups. Objects of this class serve as prototypes for rows in queries. */
  class RuleGroups(_tableTag: Tag) extends Table[RuleGroupsRow](_tableTag, "rule_groups") {
    def * = (id, ruleGroupStrategyId, name, description, createdAt, updatedAt, programId, label, rowOrder) <> (RuleGroupsRow.tupled, RuleGroupsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), ruleGroupStrategyId, Rep.Some(name), description, createdAt, updatedAt, Rep.Some(programId), label, rowOrder).shaped.<>({r=>import r._; _1.map(_=> RuleGroupsRow.tupled((_1.get, _2, _3.get, _4, _5, _6, _7.get, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column rule_group_strategy_id SqlType(INT), Default(None) */
    val ruleGroupStrategyId: Rep[Option[Int]] = column[Option[Int]]("rule_group_strategy_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(100,true) */
    val name: Rep[String] = column[String]("name", O.Length(100,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT) */
    val programId: Rep[Int] = column[Int]("program_id")
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))

    /** Index over (ruleGroupStrategyId) (database name index_rule_groups_on_rule_group_strategy_id) */
    val index1 = index("index_rule_groups_on_rule_group_strategy_id", ruleGroupStrategyId)
  }
  /** Collection-like TableQuery object for table RuleGroups */
  lazy val RuleGroups = new TableQuery(tag => new RuleGroups(tag))

  /** Entity class storing rows of table SchemaMigrations
   *  @param version Database column version SqlType(VARCHAR), Length(255,true) */
  case class SchemaMigrationsRow(version: String)
  /** GetResult implicit for fetching SchemaMigrationsRow objects using plain SQL queries */
  implicit def GetResultSchemaMigrationsRow(implicit e0: GR[String]): GR[SchemaMigrationsRow] = GR{
    prs => import prs._
    SchemaMigrationsRow(<<[String])
  }
  /** Table description of table schema_migrations. Objects of this class serve as prototypes for rows in queries. */
  class SchemaMigrations(_tableTag: Tag) extends Table[SchemaMigrationsRow](_tableTag, "schema_migrations") {
    def * = version <> (SchemaMigrationsRow, SchemaMigrationsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = Rep.Some(version).shaped.<>(r => r.map(_=> SchemaMigrationsRow(r.get)), (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column version SqlType(VARCHAR), Length(255,true) */
    val version: Rep[String] = column[String]("version", O.Length(255,varying=true))

    /** Uniqueness Index over (version) (database name unique_schema_migrations) */
    val index1 = index("unique_schema_migrations", version, unique=true)
  }
  /** Collection-like TableQuery object for table SchemaMigrations */
  lazy val SchemaMigrations = new TableQuery(tag => new SchemaMigrations(tag))

  /** Entity class storing rows of table ScoreBoards
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param metricId Database column metric_id SqlType(INT), Default(None)
   *  @param period Database column period SqlType(VARCHAR), Length(100,true), Default(Some(life_time))
   *  @param rankType Database column rank_type SqlType(VARCHAR), Length(100,true), Default(Some(default))
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param seedStatus Database column seed_status SqlType(VARCHAR), Length(100,true), Default(Some(pending))
   *  @param `type` Database column type SqlType(VARCHAR), Length(100,true), Default(Some(UserScoreBoard))
   *  @param calculation Database column calculation SqlType(VARCHAR), Length(100,true), Default(Some(sum))
   *  @param nameFormat Database column name_format SqlType(VARCHAR), Length(50,true), Default(Some(full_name))
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param memberClassId Database column member_class_id SqlType(INT), Default(None) */
  case class ScoreBoardsRow(id: Int, metricId: Option[Int] = None, period: Option[String] = Some("life_time"), rankType: Option[String] = Some("default"), name: String, label: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Option[Int] = None, description: Option[String] = None, metricName: Option[String] = None, seedStatus: Option[String] = Some("pending"), `type`: Option[String] = Some("UserScoreBoard"), calculation: Option[String] = Some("sum"), nameFormat: Option[String] = Some("full_name"), imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, memberClassId: Option[Int] = None)
  /** GetResult implicit for fetching ScoreBoardsRow objects using plain SQL queries */
  implicit def GetResultScoreBoardsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[String], e4: GR[Option[java.sql.Timestamp]]): GR[ScoreBoardsRow] = GR{
    prs => import prs._
    ScoreBoardsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table score_boards. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class ScoreBoards(_tableTag: Tag) extends Table[ScoreBoardsRow](_tableTag, "score_boards") {
    def * = (id, metricId, period, rankType, name, label, createdAt, updatedAt, programId, description, metricName, seedStatus, `type`, calculation, nameFormat, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, memberClassId) <> (ScoreBoardsRow.tupled, ScoreBoardsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), metricId, period, rankType, Rep.Some(name), Rep.Some(label), createdAt, updatedAt, programId, description, metricName, seedStatus, `type`, calculation, nameFormat, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, memberClassId).shaped.<>({r=>import r._; _1.map(_=> ScoreBoardsRow.tupled((_1.get, _2, _3, _4, _5.get, _6.get, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column metric_id SqlType(INT), Default(None) */
    val metricId: Rep[Option[Int]] = column[Option[Int]]("metric_id", O.Default(None))
    /** Database column period SqlType(VARCHAR), Length(100,true), Default(Some(life_time)) */
    val period: Rep[Option[String]] = column[Option[String]]("period", O.Length(100,varying=true), O.Default(Some("life_time")))
    /** Database column rank_type SqlType(VARCHAR), Length(100,true), Default(Some(default)) */
    val rankType: Rep[Option[String]] = column[Option[String]]("rank_type", O.Length(100,varying=true), O.Default(Some("default")))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))
    /** Database column seed_status SqlType(VARCHAR), Length(100,true), Default(Some(pending)) */
    val seedStatus: Rep[Option[String]] = column[Option[String]]("seed_status", O.Length(100,varying=true), O.Default(Some("pending")))
    /** Database column type SqlType(VARCHAR), Length(100,true), Default(Some(UserScoreBoard))
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(100,varying=true), O.Default(Some("UserScoreBoard")))
    /** Database column calculation SqlType(VARCHAR), Length(100,true), Default(Some(sum)) */
    val calculation: Rep[Option[String]] = column[Option[String]]("calculation", O.Length(100,varying=true), O.Default(Some("sum")))
    /** Database column name_format SqlType(VARCHAR), Length(50,true), Default(Some(full_name)) */
    val nameFormat: Rep[Option[String]] = column[Option[String]]("name_format", O.Length(50,varying=true), O.Default(Some("full_name")))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column member_class_id SqlType(INT), Default(None) */
    val memberClassId: Rep[Option[Int]] = column[Option[Int]]("member_class_id", O.Default(None))

    /** Index over (memberClassId) (database name index_score_boards_on_member_class_id) */
    val index1 = index("index_score_boards_on_member_class_id", memberClassId)
  }
  /** Collection-like TableQuery object for table ScoreBoards */
  lazy val ScoreBoards = new TableQuery(tag => new ScoreBoards(tag))

  /** Entity class storing rows of table ScoringRules
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param offerId Database column offer_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param score Database column score SqlType(INT), Default(None)
   *  @param manageScoreId Database column manage_score_id SqlType(INT), Default(Some(0))
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None) */
  case class ScoringRulesRow(id: Int, name: Option[String] = None, description: Option[String] = None, offerId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, score: Option[Int] = None, manageScoreId: Option[Int] = Some(0), status: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None)
  /** GetResult implicit for fetching ScoringRulesRow objects using plain SQL queries */
  implicit def GetResultScoringRulesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[Boolean]]): GR[ScoringRulesRow] = GR{
    prs => import prs._
    ScoringRulesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[Boolean], <<?[String]))
  }
  /** Table description of table scoring_rules. Objects of this class serve as prototypes for rows in queries. */
  class ScoringRules(_tableTag: Tag) extends Table[ScoringRulesRow](_tableTag, "scoring_rules") {
    def * = (id, name, description, offerId, createdAt, updatedAt, effectivityStart, effectivityEnd, effectivityTimezone, score, manageScoreId, status, publishedAt, recurring, recurringSchedule) <> (ScoringRulesRow.tupled, ScoringRulesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, offerId, createdAt, updatedAt, effectivityStart, effectivityEnd, effectivityTimezone, score, manageScoreId, status, publishedAt, recurring, recurringSchedule).shaped.<>({r=>import r._; _1.map(_=> ScoringRulesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column offer_id SqlType(INT), Default(None) */
    val offerId: Rep[Option[Int]] = column[Option[Int]]("offer_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column score SqlType(INT), Default(None) */
    val score: Rep[Option[Int]] = column[Option[Int]]("score", O.Default(None))
    /** Database column manage_score_id SqlType(INT), Default(Some(0)) */
    val manageScoreId: Rep[Option[Int]] = column[Option[Int]]("manage_score_id", O.Default(Some(0)))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))

    /** Index over (offerId) (database name index_scoring_rules_on_offer_id) */
    val index1 = index("index_scoring_rules_on_offer_id", offerId)
  }
  /** Collection-like TableQuery object for table ScoringRules */
  lazy val ScoringRules = new TableQuery(tag => new ScoringRules(tag))

  /** Entity class storing rows of table Segments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param effective Database column effective SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None)
   *  @param staticFlag Database column static_flag SqlType(BIT), Default(Some(false))
   *  @param membersIncludedCount Database column members_included_count SqlType(INT), Default(None)
   *  @param membersExcludedCount Database column members_excluded_count SqlType(INT), Default(None)
   *  @param lastSyncedAt Database column last_synced_at SqlType(DATETIME), Default(None)
   *  @param system Database column system SqlType(BIT), Default(None)
   *  @param executionType Database column execution_type SqlType(VARCHAR), Length(25,true), Default(None) */
  case class SegmentsRow(id: Int, effective: Option[String] = None, name: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, status: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, label: String, description: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, staticFlag: Option[Boolean] = Some(false), membersIncludedCount: Option[Int] = None, membersExcludedCount: Option[Int] = None, lastSyncedAt: Option[java.sql.Timestamp] = None, system: Option[Boolean] = None, executionType: Option[String] = None)
  /** GetResult implicit for fetching SegmentsRow objects using plain SQL queries */
  implicit def GetResultSegmentsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[String], e4: GR[Option[Boolean]], e5: GR[Option[Int]]): GR[SegmentsRow] = GR{
    prs => import prs._
    SegmentsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<[String], <<?[String], <<?[Boolean], <<?[String], <<?[Boolean], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[Boolean], <<?[String]))
  }
  /** Table description of table segments. Objects of this class serve as prototypes for rows in queries. */
  class Segments(_tableTag: Tag) extends Table[SegmentsRow](_tableTag, "segments") {
    def * = (id, effective, name, createdAt, updatedAt, effectivityStart, effectivityEnd, effectivityTimezone, status, publishedAt, label, description, recurring, recurringSchedule, staticFlag, membersIncludedCount, membersExcludedCount, lastSyncedAt, system, executionType) <> (SegmentsRow.tupled, SegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), effective, name, createdAt, updatedAt, effectivityStart, effectivityEnd, effectivityTimezone, status, publishedAt, Rep.Some(label), description, recurring, recurringSchedule, staticFlag, membersIncludedCount, membersExcludedCount, lastSyncedAt, system, executionType).shaped.<>({r=>import r._; _1.map(_=> SegmentsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11.get, _12, _13, _14, _15, _16, _17, _18, _19, _20)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column effective SqlType(VARCHAR), Length(255,true), Default(None) */
    val effective: Rep[Option[String]] = column[Option[String]]("effective", O.Length(255,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(100,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(100,varying=true), O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column static_flag SqlType(BIT), Default(Some(false)) */
    val staticFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("static_flag", O.Default(Some(false)))
    /** Database column members_included_count SqlType(INT), Default(None) */
    val membersIncludedCount: Rep[Option[Int]] = column[Option[Int]]("members_included_count", O.Default(None))
    /** Database column members_excluded_count SqlType(INT), Default(None) */
    val membersExcludedCount: Rep[Option[Int]] = column[Option[Int]]("members_excluded_count", O.Default(None))
    /** Database column last_synced_at SqlType(DATETIME), Default(None) */
    val lastSyncedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("last_synced_at", O.Default(None))
    /** Database column system SqlType(BIT), Default(None) */
    val system: Rep[Option[Boolean]] = column[Option[Boolean]]("system", O.Default(None))
    /** Database column execution_type SqlType(VARCHAR), Length(25,true), Default(None) */
    val executionType: Rep[Option[String]] = column[Option[String]]("execution_type", O.Length(25,varying=true), O.Default(None))
  }
  /** Collection-like TableQuery object for table Segments */
  lazy val Segments = new TableQuery(tag => new Segments(tag))

  /** Entity class storing rows of table SetEntities
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param targetingSetId Database column targeting_set_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param weight Database column weight SqlType(DECIMAL), Default(None) */
  case class SetEntitiesRow(id: Int, entityId: Option[Int] = None, entityType: Option[String] = None, targetingSetId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, rowOrder: Option[Int] = None, weight: Option[scala.math.BigDecimal] = None)
  /** GetResult implicit for fetching SetEntitiesRow objects using plain SQL queries */
  implicit def GetResultSetEntitiesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Option[scala.math.BigDecimal]]): GR[SetEntitiesRow] = GR{
    prs => import prs._
    SetEntitiesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[scala.math.BigDecimal]))
  }
  /** Table description of table set_entities. Objects of this class serve as prototypes for rows in queries. */
  class SetEntities(_tableTag: Tag) extends Table[SetEntitiesRow](_tableTag, "set_entities") {
    def * = (id, entityId, entityType, targetingSetId, createdAt, updatedAt, rowOrder, weight) <> (SetEntitiesRow.tupled, SetEntitiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), entityId, entityType, targetingSetId, createdAt, updatedAt, rowOrder, weight).shaped.<>({r=>import r._; _1.map(_=> SetEntitiesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column targeting_set_id SqlType(INT), Default(None) */
    val targetingSetId: Rep[Option[Int]] = column[Option[Int]]("targeting_set_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column weight SqlType(DECIMAL), Default(None) */
    val weight: Rep[Option[scala.math.BigDecimal]] = column[Option[scala.math.BigDecimal]]("weight", O.Default(None))
  }
  /** Collection-like TableQuery object for table SetEntities */
  lazy val SetEntities = new TableQuery(tag => new SetEntities(tag))

  /** Entity class storing rows of table SetEntityConditions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param setRuleId Database column set_rule_id SqlType(INT), Default(None)
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param entityLabel Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param conditionType Database column condition_type SqlType(VARCHAR), Length(100,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param active Database column active SqlType(BIT), Default(Some(true))
   *  @param operator Database column operator SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param operatorType Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None) */
  case class SetEntityConditionsRow(id: Int, setRuleId: Option[Int] = None, entityId: Option[Int] = None, entityType: Option[String] = None, entityLabel: Option[String] = None, conditionType: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, active: Option[Boolean] = Some(true), operator: Option[String] = None, operatorType: Option[String] = None)
  /** GetResult implicit for fetching SetEntityConditionsRow objects using plain SQL queries */
  implicit def GetResultSetEntityConditionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[String], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]]): GR[SetEntityConditionsRow] = GR{
    prs => import prs._
    SetEntityConditionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean], <<?[String], <<?[String]))
  }
  /** Table description of table set_entity_conditions. Objects of this class serve as prototypes for rows in queries. */
  class SetEntityConditions(_tableTag: Tag) extends Table[SetEntityConditionsRow](_tableTag, "set_entity_conditions") {
    def * = (id, setRuleId, entityId, entityType, entityLabel, conditionType, createdAt, updatedAt, active, operator, operatorType) <> (SetEntityConditionsRow.tupled, SetEntityConditionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), setRuleId, entityId, entityType, entityLabel, Rep.Some(conditionType), createdAt, updatedAt, active, operator, operatorType).shaped.<>({r=>import r._; _1.map(_=> SetEntityConditionsRow.tupled((_1.get, _2, _3, _4, _5, _6.get, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column set_rule_id SqlType(INT), Default(None) */
    val setRuleId: Rep[Option[Int]] = column[Option[Int]]("set_rule_id", O.Default(None))
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityLabel: Rep[Option[String]] = column[Option[String]]("entity_label", O.Length(255,varying=true), O.Default(None))
    /** Database column condition_type SqlType(VARCHAR), Length(100,true) */
    val conditionType: Rep[String] = column[String]("condition_type", O.Length(100,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column active SqlType(BIT), Default(Some(true)) */
    val active: Rep[Option[Boolean]] = column[Option[Boolean]]("active", O.Default(Some(true)))
    /** Database column operator SqlType(VARCHAR), Length(100,true), Default(None) */
    val operator: Rep[Option[String]] = column[Option[String]]("operator", O.Length(100,varying=true), O.Default(None))
    /** Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None) */
    val operatorType: Rep[Option[String]] = column[Option[String]]("operator_type", O.Length(100,varying=true), O.Default(None))

    /** Index over (setRuleId) (database name index_set_entity_conditions_on_set_rule_id) */
    val index1 = index("index_set_entity_conditions_on_set_rule_id", setRuleId)
  }
  /** Collection-like TableQuery object for table SetEntityConditions */
  lazy val SetEntityConditions = new TableQuery(tag => new SetEntityConditions(tag))

  /** Entity class storing rows of table SetMemberConditions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param setRuleId Database column set_rule_id SqlType(INT), Default(None)
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param operator Database column operator SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param matchValue Database column match_value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param conditionType Database column condition_type SqlType(VARCHAR), Length(100,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param active Database column active SqlType(BIT), Default(Some(true))
   *  @param entityLabel Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param operatorType Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None) */
  case class SetMemberConditionsRow(id: Int, setRuleId: Option[Int] = None, entityId: Option[Int] = None, entityType: Option[String] = None, operator: Option[String] = None, matchValue: Option[String] = None, conditionType: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, active: Option[Boolean] = Some(true), entityLabel: Option[String] = None, operatorType: Option[String] = None)
  /** GetResult implicit for fetching SetMemberConditionsRow objects using plain SQL queries */
  implicit def GetResultSetMemberConditionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[String], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]]): GR[SetMemberConditionsRow] = GR{
    prs => import prs._
    SetMemberConditionsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean], <<?[String], <<?[String]))
  }
  /** Table description of table set_member_conditions. Objects of this class serve as prototypes for rows in queries. */
  class SetMemberConditions(_tableTag: Tag) extends Table[SetMemberConditionsRow](_tableTag, "set_member_conditions") {
    def * = (id, setRuleId, entityId, entityType, operator, matchValue, conditionType, createdAt, updatedAt, active, entityLabel, operatorType) <> (SetMemberConditionsRow.tupled, SetMemberConditionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), setRuleId, entityId, entityType, operator, matchValue, Rep.Some(conditionType), createdAt, updatedAt, active, entityLabel, operatorType).shaped.<>({r=>import r._; _1.map(_=> SetMemberConditionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7.get, _8, _9, _10, _11, _12)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column set_rule_id SqlType(INT), Default(None) */
    val setRuleId: Rep[Option[Int]] = column[Option[Int]]("set_rule_id", O.Default(None))
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column operator SqlType(VARCHAR), Length(100,true), Default(None) */
    val operator: Rep[Option[String]] = column[Option[String]]("operator", O.Length(100,varying=true), O.Default(None))
    /** Database column match_value SqlType(VARCHAR), Length(255,true), Default(None) */
    val matchValue: Rep[Option[String]] = column[Option[String]]("match_value", O.Length(255,varying=true), O.Default(None))
    /** Database column condition_type SqlType(VARCHAR), Length(100,true) */
    val conditionType: Rep[String] = column[String]("condition_type", O.Length(100,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column active SqlType(BIT), Default(Some(true)) */
    val active: Rep[Option[Boolean]] = column[Option[Boolean]]("active", O.Default(Some(true)))
    /** Database column entity_label SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityLabel: Rep[Option[String]] = column[Option[String]]("entity_label", O.Length(255,varying=true), O.Default(None))
    /** Database column operator_type SqlType(VARCHAR), Length(100,true), Default(None) */
    val operatorType: Rep[Option[String]] = column[Option[String]]("operator_type", O.Length(100,varying=true), O.Default(None))
  }
  /** Collection-like TableQuery object for table SetMemberConditions */
  lazy val SetMemberConditions = new TableQuery(tag => new SetMemberConditions(tag))

  /** Entity class storing rows of table SetOverrideEntities
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param setOverrideId Database column set_override_id SqlType(INT), Default(None)
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class SetOverrideEntitiesRow(id: Int, setOverrideId: Option[Int] = None, entityId: Option[Int] = None, entityType: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching SetOverrideEntitiesRow objects using plain SQL queries */
  implicit def GetResultSetOverrideEntitiesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[SetOverrideEntitiesRow] = GR{
    prs => import prs._
    SetOverrideEntitiesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table set_override_entities. Objects of this class serve as prototypes for rows in queries. */
  class SetOverrideEntities(_tableTag: Tag) extends Table[SetOverrideEntitiesRow](_tableTag, "set_override_entities") {
    def * = (id, setOverrideId, entityId, entityType, createdAt, updatedAt, rowOrder) <> (SetOverrideEntitiesRow.tupled, SetOverrideEntitiesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), setOverrideId, entityId, entityType, createdAt, updatedAt, rowOrder).shaped.<>({r=>import r._; _1.map(_=> SetOverrideEntitiesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column set_override_id SqlType(INT), Default(None) */
    val setOverrideId: Rep[Option[Int]] = column[Option[Int]]("set_override_id", O.Default(None))
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
  }
  /** Collection-like TableQuery object for table SetOverrideEntities */
  lazy val SetOverrideEntities = new TableQuery(tag => new SetOverrideEntities(tag))

  /** Entity class storing rows of table SetOverrides
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param targetingSetId Database column targeting_set_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class SetOverridesRow(id: Int, memberId: Option[Int] = None, targetingSetId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching SetOverridesRow objects using plain SQL queries */
  implicit def GetResultSetOverridesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[SetOverridesRow] = GR{
    prs => import prs._
    SetOverridesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table set_overrides. Objects of this class serve as prototypes for rows in queries. */
  class SetOverrides(_tableTag: Tag) extends Table[SetOverridesRow](_tableTag, "set_overrides") {
    def * = (id, memberId, targetingSetId, createdAt, updatedAt, rowOrder) <> (SetOverridesRow.tupled, SetOverridesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, targetingSetId, createdAt, updatedAt, rowOrder).shaped.<>({r=>import r._; _1.map(_=> SetOverridesRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column targeting_set_id SqlType(INT), Default(None) */
    val targetingSetId: Rep[Option[Int]] = column[Option[Int]]("targeting_set_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
  }
  /** Collection-like TableQuery object for table SetOverrides */
  lazy val SetOverrides = new TableQuery(tag => new SetOverrides(tag))

  /** Entity class storing rows of table SetRules
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param targetingSetId Database column targeting_set_id SqlType(INT), Default(None)
   *  @param score Database column score SqlType(INT), Default(None)
   *  @param memberMatchingRule Database column member_matching_rule SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param string Database column string SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param entityMatchingRule Database column entity_matching_rule SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class SetRulesRow(id: Int, targetingSetId: Option[Int] = None, score: Option[Int] = None, memberMatchingRule: Option[String] = None, string: Option[String] = None, entityMatchingRule: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching SetRulesRow objects using plain SQL queries */
  implicit def GetResultSetRulesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[SetRulesRow] = GR{
    prs => import prs._
    SetRulesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table set_rules. Objects of this class serve as prototypes for rows in queries. */
  class SetRules(_tableTag: Tag) extends Table[SetRulesRow](_tableTag, "set_rules") {
    def * = (id, targetingSetId, score, memberMatchingRule, string, entityMatchingRule, createdAt, updatedAt, rowOrder) <> (SetRulesRow.tupled, SetRulesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), targetingSetId, score, memberMatchingRule, string, entityMatchingRule, createdAt, updatedAt, rowOrder).shaped.<>({r=>import r._; _1.map(_=> SetRulesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column targeting_set_id SqlType(INT), Default(None) */
    val targetingSetId: Rep[Option[Int]] = column[Option[Int]]("targeting_set_id", O.Default(None))
    /** Database column score SqlType(INT), Default(None) */
    val score: Rep[Option[Int]] = column[Option[Int]]("score", O.Default(None))
    /** Database column member_matching_rule SqlType(VARCHAR), Length(100,true), Default(None) */
    val memberMatchingRule: Rep[Option[String]] = column[Option[String]]("member_matching_rule", O.Length(100,varying=true), O.Default(None))
    /** Database column string SqlType(VARCHAR), Length(100,true), Default(None) */
    val string: Rep[Option[String]] = column[Option[String]]("string", O.Length(100,varying=true), O.Default(None))
    /** Database column entity_matching_rule SqlType(VARCHAR), Length(100,true), Default(None) */
    val entityMatchingRule: Rep[Option[String]] = column[Option[String]]("entity_matching_rule", O.Length(100,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
  }
  /** Collection-like TableQuery object for table SetRules */
  lazy val SetRules = new TableQuery(tag => new SetRules(tag))

  /** Entity class storing rows of table SocialSources
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param platform Database column platform SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param hashtags Database column hashtags SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None) */
  case class SocialSourcesRow(id: Int, programId: Option[Int] = None, label: Option[String] = None, name: Option[String] = None, platform: Option[String] = None, hashtags: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, description: Option[String] = None)
  /** GetResult implicit for fetching SocialSourcesRow objects using plain SQL queries */
  implicit def GetResultSocialSourcesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[SocialSourcesRow] = GR{
    prs => import prs._
    SocialSourcesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table social_sources. Objects of this class serve as prototypes for rows in queries. */
  class SocialSources(_tableTag: Tag) extends Table[SocialSourcesRow](_tableTag, "social_sources") {
    def * = (id, programId, label, name, platform, hashtags, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt, description) <> (SocialSourcesRow.tupled, SocialSourcesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), programId, label, name, platform, hashtags, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, createdAt, updatedAt, description).shaped.<>({r=>import r._; _1.map(_=> SocialSourcesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column platform SqlType(VARCHAR), Length(255,true), Default(None) */
    val platform: Rep[Option[String]] = column[Option[String]]("platform", O.Length(255,varying=true), O.Default(None))
    /** Database column hashtags SqlType(VARCHAR), Length(255,true), Default(None) */
    val hashtags: Rep[Option[String]] = column[Option[String]]("hashtags", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
  }
  /** Collection-like TableQuery object for table SocialSources */
  lazy val SocialSources = new TableQuery(tag => new SocialSources(tag))

  /** Entity class storing rows of table StellarCategories
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileName Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageContentType Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param imageFileSize Database column image_file_size SqlType(INT), Default(None)
   *  @param imageUpdatedAt Database column image_updated_at SqlType(DATETIME), Default(None)
   *  @param system Database column system SqlType(BIT), Default(Some(false)) */
  case class StellarCategoriesRow(id: Int, name: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, `type`: Option[String] = None, programId: Option[Int] = None, label: Option[String] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, system: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching StellarCategoriesRow objects using plain SQL queries */
  implicit def GetResultStellarCategoriesRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]], e4: GR[Option[Boolean]]): GR[StellarCategoriesRow] = GR{
    prs => import prs._
    StellarCategoriesRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[Boolean]))
  }
  /** Table description of table stellar_categories. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class StellarCategories(_tableTag: Tag) extends Table[StellarCategoriesRow](_tableTag, "stellar_categories") {
    def * = (id, name, description, createdAt, updatedAt, `type`, programId, label, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, system) <> (StellarCategoriesRow.tupled, StellarCategoriesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, createdAt, updatedAt, `type`, programId, label, imageFileName, imageContentType, imageFileSize, imageUpdatedAt, system).shaped.<>({r=>import r._; _1.map(_=> StellarCategoriesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column system SqlType(BIT), Default(Some(false)) */
    val system: Rep[Option[Boolean]] = column[Option[Boolean]]("system", O.Default(Some(false)))
  }
  /** Collection-like TableQuery object for table StellarCategories */
  lazy val StellarCategories = new TableQuery(tag => new StellarCategories(tag))

  /** Entity class storing rows of table StellarCategoryMappings
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param stellarCategoryId Database column stellar_category_id SqlType(INT), Default(None)
   *  @param entityId Database column entity_id SqlType(INT), Default(None)
   *  @param entityType Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
  case class StellarCategoryMappingsRow(id: Int, stellarCategoryId: Option[Int] = None, entityId: Option[Int] = None, entityType: Option[String] = None)
  /** GetResult implicit for fetching StellarCategoryMappingsRow objects using plain SQL queries */
  implicit def GetResultStellarCategoryMappingsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]]): GR[StellarCategoryMappingsRow] = GR{
    prs => import prs._
    StellarCategoryMappingsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String]))
  }
  /** Table description of table stellar_category_mappings. Objects of this class serve as prototypes for rows in queries. */
  class StellarCategoryMappings(_tableTag: Tag) extends Table[StellarCategoryMappingsRow](_tableTag, "stellar_category_mappings") {
    def * = (id, stellarCategoryId, entityId, entityType) <> (StellarCategoryMappingsRow.tupled, StellarCategoryMappingsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), stellarCategoryId, entityId, entityType).shaped.<>({r=>import r._; _1.map(_=> StellarCategoryMappingsRow.tupled((_1.get, _2, _3, _4)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column stellar_category_id SqlType(INT), Default(None) */
    val stellarCategoryId: Rep[Option[Int]] = column[Option[Int]]("stellar_category_id", O.Default(None))
    /** Database column entity_id SqlType(INT), Default(None) */
    val entityId: Rep[Option[Int]] = column[Option[Int]]("entity_id", O.Default(None))
    /** Database column entity_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val entityType: Rep[Option[String]] = column[Option[String]]("entity_type", O.Length(255,varying=true), O.Default(None))

    /** Index over (stellarCategoryId) (database name index_stellar_category_mappings_on_stellar_category_id) */
    val index1 = index("index_stellar_category_mappings_on_stellar_category_id", stellarCategoryId)
  }
  /** Collection-like TableQuery object for table StellarCategoryMappings */
  lazy val StellarCategoryMappings = new TableQuery(tag => new StellarCategoryMappings(tag))

  /** Entity class storing rows of table Taggings
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param tagId Database column tag_id SqlType(INT), Default(None)
   *  @param taggableId Database column taggable_id SqlType(INT), Default(None)
   *  @param taggableType Database column taggable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param taggerId Database column tagger_id SqlType(INT), Default(None)
   *  @param taggerType Database column tagger_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param context Database column context SqlType(VARCHAR), Length(128,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None) */
  case class TaggingsRow(id: Int, tagId: Option[Int] = None, taggableId: Option[Int] = None, taggableType: Option[String] = None, taggerId: Option[Int] = None, taggerType: Option[String] = None, context: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching TaggingsRow objects using plain SQL queries */
  implicit def GetResultTaggingsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[TaggingsRow] = GR{
    prs => import prs._
    TaggingsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp]))
  }
  /** Table description of table taggings. Objects of this class serve as prototypes for rows in queries. */
  class Taggings(_tableTag: Tag) extends Table[TaggingsRow](_tableTag, "taggings") {
    def * = (id, tagId, taggableId, taggableType, taggerId, taggerType, context, createdAt) <> (TaggingsRow.tupled, TaggingsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), tagId, taggableId, taggableType, taggerId, taggerType, context, createdAt).shaped.<>({r=>import r._; _1.map(_=> TaggingsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column tag_id SqlType(INT), Default(None) */
    val tagId: Rep[Option[Int]] = column[Option[Int]]("tag_id", O.Default(None))
    /** Database column taggable_id SqlType(INT), Default(None) */
    val taggableId: Rep[Option[Int]] = column[Option[Int]]("taggable_id", O.Default(None))
    /** Database column taggable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val taggableType: Rep[Option[String]] = column[Option[String]]("taggable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column tagger_id SqlType(INT), Default(None) */
    val taggerId: Rep[Option[Int]] = column[Option[Int]]("tagger_id", O.Default(None))
    /** Database column tagger_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val taggerType: Rep[Option[String]] = column[Option[String]]("tagger_type", O.Length(255,varying=true), O.Default(None))
    /** Database column context SqlType(VARCHAR), Length(128,true), Default(None) */
    val context: Rep[Option[String]] = column[Option[String]]("context", O.Length(128,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))

    /** Index over (taggableId,taggableType,context) (database name index_taggings_on_taggable_id_and_taggable_type_and_context) */
    val index1 = index("index_taggings_on_taggable_id_and_taggable_type_and_context", (taggableId, taggableType, context))
    /** Uniqueness Index over (tagId,taggableId,taggableType,context,taggerId,taggerType) (database name taggings_idx) */
    val index2 = index("taggings_idx", (tagId, taggableId, taggableType, context, taggerId, taggerType), unique=true)
  }
  /** Collection-like TableQuery object for table Taggings */
  lazy val Taggings = new TableQuery(tag => new Taggings(tag))

  /** Entity class storing rows of table Tags
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param taggingsCount Database column taggings_count SqlType(INT), Default(Some(0)) */
  case class TagsRow(id: Int, name: Option[String] = None, taggingsCount: Option[Int] = Some(0))
  /** GetResult implicit for fetching TagsRow objects using plain SQL queries */
  implicit def GetResultTagsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]]): GR[TagsRow] = GR{
    prs => import prs._
    TagsRow.tupled((<<[Int], <<?[String], <<?[Int]))
  }
  /** Table description of table tags. Objects of this class serve as prototypes for rows in queries. */
  class Tags(_tableTag: Tag) extends Table[TagsRow](_tableTag, "tags") {
    def * = (id, name, taggingsCount) <> (TagsRow.tupled, TagsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, taggingsCount).shaped.<>({r=>import r._; _1.map(_=> TagsRow.tupled((_1.get, _2, _3)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column taggings_count SqlType(INT), Default(Some(0)) */
    val taggingsCount: Rep[Option[Int]] = column[Option[Int]]("taggings_count", O.Default(Some(0)))

    /** Uniqueness Index over (name) (database name index_tags_on_name) */
    val index1 = index("index_tags_on_name", name, unique=true)
  }
  /** Collection-like TableQuery object for table Tags */
  lazy val Tags = new TableQuery(tag => new Tags(tag))

  /** Row type of table TargetingSets */
  type TargetingSetsRow = HCons[Int,HCons[Option[Int],HCons[Option[String],HCons[Option[String],HCons[String,HCons[String,HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[Boolean],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[String],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[java.sql.Timestamp],HCons[Option[String],HCons[Option[String],HCons[Option[Int],HCons[Option[String],HNil]]]]]]]]]]]]]]]]]]]]]]]]]
  /** Constructor for TargetingSetsRow providing default values if available in the database schema. */
  def TargetingSetsRow(id: Int, programId: Option[Int] = None, setType: Option[String] = Some("static"), ranking: Option[String] = Some("manual"), name: String, label: String, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, `type`: Option[String] = None, description: Option[String] = None, status: Option[String] = Some("draft"), publishedAt: Option[java.sql.Timestamp] = None, imageFileName: Option[String] = None, imageContentType: Option[String] = None, imageFileSize: Option[Int] = None, imageUpdatedAt: Option[java.sql.Timestamp] = None, multipleMatchRule: Option[String] = None, tieBreakerRule: Option[String] = None, winnerSelectionCount: Option[Int] = None, winnerSelectionMetric: Option[String] = None): TargetingSetsRow = {
    id :: programId :: setType :: ranking :: name :: label :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: createdAt :: updatedAt :: `type` :: description :: status :: publishedAt :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: multipleMatchRule :: tieBreakerRule :: winnerSelectionCount :: winnerSelectionMetric :: HNil
  }
  /** GetResult implicit for fetching TargetingSetsRow objects using plain SQL queries */
  implicit def GetResultTargetingSetsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[String], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]]): GR[TargetingSetsRow] = GR{
    prs => import prs._
    <<[Int] :: <<?[Int] :: <<?[String] :: <<?[String] :: <<[String] :: <<[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[Boolean] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[String] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[java.sql.Timestamp] :: <<?[String] :: <<?[String] :: <<?[Int] :: <<?[String] :: HNil
  }
  /** Table description of table targeting_sets. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class TargetingSets(_tableTag: Tag) extends Table[TargetingSetsRow](_tableTag, "targeting_sets") {
    def * = id :: programId :: setType :: ranking :: name :: label :: effectivityStart :: effectivityEnd :: effectivityTimezone :: recurring :: recurringSchedule :: createdAt :: updatedAt :: `type` :: description :: status :: publishedAt :: imageFileName :: imageContentType :: imageFileSize :: imageUpdatedAt :: multipleMatchRule :: tieBreakerRule :: winnerSelectionCount :: winnerSelectionMetric :: HNil

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column set_type SqlType(VARCHAR), Length(100,true), Default(Some(static)) */
    val setType: Rep[Option[String]] = column[Option[String]]("set_type", O.Length(100,varying=true), O.Default(Some("static")))
    /** Database column ranking SqlType(VARCHAR), Length(100,true), Default(Some(manual)) */
    val ranking: Rep[Option[String]] = column[Option[String]]("ranking", O.Length(100,varying=true), O.Default(Some("manual")))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(Some(draft)) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(Some("draft")))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column image_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageFileName: Rep[Option[String]] = column[Option[String]]("image_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column image_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val imageContentType: Rep[Option[String]] = column[Option[String]]("image_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column image_file_size SqlType(INT), Default(None) */
    val imageFileSize: Rep[Option[Int]] = column[Option[Int]]("image_file_size", O.Default(None))
    /** Database column image_updated_at SqlType(DATETIME), Default(None) */
    val imageUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("image_updated_at", O.Default(None))
    /** Database column multiple_match_rule SqlType(VARCHAR), Length(255,true), Default(None) */
    val multipleMatchRule: Rep[Option[String]] = column[Option[String]]("multiple_match_rule", O.Length(255,varying=true), O.Default(None))
    /** Database column tie_breaker_rule SqlType(VARCHAR), Length(255,true), Default(None) */
    val tieBreakerRule: Rep[Option[String]] = column[Option[String]]("tie_breaker_rule", O.Length(255,varying=true), O.Default(None))
    /** Database column winner_selection_count SqlType(INT), Default(None) */
    val winnerSelectionCount: Rep[Option[Int]] = column[Option[Int]]("winner_selection_count", O.Default(None))
    /** Database column winner_selection_metric SqlType(VARCHAR), Length(50,true), Default(None) */
    val winnerSelectionMetric: Rep[Option[String]] = column[Option[String]]("winner_selection_metric", O.Length(50,varying=true), O.Default(None))
  }
  /** Collection-like TableQuery object for table TargetingSets */
  lazy val TargetingSets = new TableQuery(tag => new TargetingSets(tag))

  /** Entity class storing rows of table TemplateSets
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param contentTypeId Database column content_type_id SqlType(INT), Default(None)
   *  @param localFileUrl Database column local_file_url SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param system Database column system SqlType(BIT), Default(Some(false)) */
  case class TemplateSetsRow(id: Int, description: Option[String] = None, contentTypeId: Option[Int] = None, localFileUrl: Option[String] = None, status: String = "draft", publishedAt: Option[java.sql.Timestamp] = None, name: String, label: String, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, system: Option[Boolean] = Some(false))
  /** GetResult implicit for fetching TemplateSetsRow objects using plain SQL queries */
  implicit def GetResultTemplateSetsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[String], e4: GR[Option[java.sql.Timestamp]], e5: GR[Option[Boolean]]): GR[TemplateSetsRow] = GR{
    prs => import prs._
    TemplateSetsRow.tupled((<<[Int], <<?[String], <<?[Int], <<?[String], <<[String], <<?[java.sql.Timestamp], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Boolean]))
  }
  /** Table description of table template_sets. Objects of this class serve as prototypes for rows in queries. */
  class TemplateSets(_tableTag: Tag) extends Table[TemplateSetsRow](_tableTag, "template_sets") {
    def * = (id, description, contentTypeId, localFileUrl, status, publishedAt, name, label, createdAt, updatedAt, system) <> (TemplateSetsRow.tupled, TemplateSetsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), description, contentTypeId, localFileUrl, Rep.Some(status), publishedAt, Rep.Some(name), Rep.Some(label), createdAt, updatedAt, system).shaped.<>({r=>import r._; _1.map(_=> TemplateSetsRow.tupled((_1.get, _2, _3, _4, _5.get, _6, _7.get, _8.get, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column content_type_id SqlType(INT), Default(None) */
    val contentTypeId: Rep[Option[Int]] = column[Option[Int]]("content_type_id", O.Default(None))
    /** Database column local_file_url SqlType(VARCHAR), Length(255,true), Default(None) */
    val localFileUrl: Rep[Option[String]] = column[Option[String]]("local_file_url", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column system SqlType(BIT), Default(Some(false)) */
    val system: Rep[Option[Boolean]] = column[Option[Boolean]]("system", O.Default(Some(false)))

    /** Index over (contentTypeId) (database name index_template_sets_on_content_type_id) */
    val index1 = index("index_template_sets_on_content_type_id", contentTypeId)
  }
  /** Collection-like TableQuery object for table TemplateSets */
  lazy val TemplateSets = new TableQuery(tag => new TemplateSets(tag))

  /** Entity class storing rows of table TemplateSetVersions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param templateSetId Database column template_set_id SqlType(INT), Default(None)
   *  @param fileFileName Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileContentType Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileSize Database column file_file_size SqlType(INT), Default(None)
   *  @param fileUpdatedAt Database column file_updated_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param versionNumber Database column version_number SqlType(INT)
   *  @param summary Database column summary SqlType(TEXT), Default(None)
   *  @param creatorId Database column creator_id SqlType(INT)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None) */
  case class TemplateSetVersionsRow(id: Int, templateSetId: Option[Int] = None, fileFileName: Option[String] = None, fileContentType: Option[String] = None, fileFileSize: Option[Int] = None, fileUpdatedAt: Option[java.sql.Timestamp] = None, status: String = "draft", versionNumber: Int, summary: Option[String] = None, creatorId: Int, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, publishedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching TemplateSetVersionsRow objects using plain SQL queries */
  implicit def GetResultTemplateSetVersionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String]): GR[TemplateSetVersionsRow] = GR{
    prs => import prs._
    TemplateSetVersionsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<[String], <<[Int], <<?[String], <<[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table template_set_versions. Objects of this class serve as prototypes for rows in queries. */
  class TemplateSetVersions(_tableTag: Tag) extends Table[TemplateSetVersionsRow](_tableTag, "template_set_versions") {
    def * = (id, templateSetId, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, status, versionNumber, summary, creatorId, createdAt, updatedAt, publishedAt) <> (TemplateSetVersionsRow.tupled, TemplateSetVersionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), templateSetId, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, Rep.Some(status), Rep.Some(versionNumber), summary, Rep.Some(creatorId), createdAt, updatedAt, publishedAt).shaped.<>({r=>import r._; _1.map(_=> TemplateSetVersionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7.get, _8.get, _9, _10.get, _11, _12, _13)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column template_set_id SqlType(INT), Default(None) */
    val templateSetId: Rep[Option[Int]] = column[Option[Int]]("template_set_id", O.Default(None))
    /** Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileFileName: Rep[Option[String]] = column[Option[String]]("file_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileContentType: Rep[Option[String]] = column[Option[String]]("file_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_size SqlType(INT), Default(None) */
    val fileFileSize: Rep[Option[Int]] = column[Option[Int]]("file_file_size", O.Default(None))
    /** Database column file_updated_at SqlType(DATETIME), Default(None) */
    val fileUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("file_updated_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column version_number SqlType(INT) */
    val versionNumber: Rep[Int] = column[Int]("version_number")
    /** Database column summary SqlType(TEXT), Default(None) */
    val summary: Rep[Option[String]] = column[Option[String]]("summary", O.Default(None))
    /** Database column creator_id SqlType(INT) */
    val creatorId: Rep[Int] = column[Int]("creator_id")
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))

    /** Index over (creatorId) (database name index_template_set_versions_on_creator_id) */
    val index1 = index("index_template_set_versions_on_creator_id", creatorId)
    /** Index over (templateSetId) (database name index_template_set_versions_on_template_set_id) */
    val index2 = index("index_template_set_versions_on_template_set_id", templateSetId)
  }
  /** Collection-like TableQuery object for table TemplateSetVersions */
  lazy val TemplateSetVersions = new TableQuery(tag => new TemplateSetVersions(tag))

  /** Entity class storing rows of table TierActionEvents
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param condition Database column condition SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param action Database column action SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
  case class TierActionEventsRow(id: Int, name: Option[String] = None, condition: Option[String] = None, action: Option[String] = None, programId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, description: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None)
  /** GetResult implicit for fetching TierActionEventsRow objects using plain SQL queries */
  implicit def GetResultTierActionEventsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]]): GR[TierActionEventsRow] = GR{
    prs => import prs._
    TierActionEventsRow.tupled((<<[Int], <<?[String], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table tier_action_events. Objects of this class serve as prototypes for rows in queries. */
  class TierActionEvents(_tableTag: Tag) extends Table[TierActionEventsRow](_tableTag, "tier_action_events") {
    def * = (id, name, condition, action, programId, createdAt, updatedAt, description, effectivityStart, effectivityEnd, effectivityTimezone) <> (TierActionEventsRow.tupled, TierActionEventsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, condition, action, programId, createdAt, updatedAt, description, effectivityStart, effectivityEnd, effectivityTimezone).shaped.<>({r=>import r._; _1.map(_=> TierActionEventsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column condition SqlType(VARCHAR), Length(255,true), Default(None) */
    val condition: Rep[Option[String]] = column[Option[String]]("condition", O.Length(255,varying=true), O.Default(None))
    /** Database column action SqlType(VARCHAR), Length(255,true), Default(None) */
    val action: Rep[Option[String]] = column[Option[String]]("action", O.Length(255,varying=true), O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
  }
  /** Collection-like TableQuery object for table TierActionEvents */
  lazy val TierActionEvents = new TableQuery(tag => new TierActionEvents(tag))

  /** Entity class storing rows of table TierColumnMetrics
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param tierColumnId Database column tier_column_id SqlType(INT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param included Database column included SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
  case class TierColumnMetricsRow(id: Int, tierColumnId: Option[Int] = None, rowOrder: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, included: Option[String] = None, metricName: Option[String] = None)
  /** GetResult implicit for fetching TierColumnMetricsRow objects using plain SQL queries */
  implicit def GetResultTierColumnMetricsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]]): GR[TierColumnMetricsRow] = GR{
    prs => import prs._
    TierColumnMetricsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[String], <<?[String]))
  }
  /** Table description of table tier_column_metrics. Objects of this class serve as prototypes for rows in queries. */
  class TierColumnMetrics(_tableTag: Tag) extends Table[TierColumnMetricsRow](_tableTag, "tier_column_metrics") {
    def * = (id, tierColumnId, rowOrder, createdAt, updatedAt, effectivityStart, effectivityEnd, effectivityTimezone, included, metricName) <> (TierColumnMetricsRow.tupled, TierColumnMetricsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), tierColumnId, rowOrder, createdAt, updatedAt, effectivityStart, effectivityEnd, effectivityTimezone, included, metricName).shaped.<>({r=>import r._; _1.map(_=> TierColumnMetricsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column tier_column_id SqlType(INT), Default(None) */
    val tierColumnId: Rep[Option[Int]] = column[Option[Int]]("tier_column_id", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column included SqlType(VARCHAR), Length(255,true), Default(None) */
    val included: Rep[Option[String]] = column[Option[String]]("included", O.Length(255,varying=true), O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))

    /** Index over (tierColumnId) (database name index_tier_column_metrics_on_tier_column_id) */
    val index1 = index("index_tier_column_metrics_on_tier_column_id", tierColumnId)
  }
  /** Collection-like TableQuery object for table TierColumnMetrics */
  lazy val TierColumnMetrics = new TableQuery(tag => new TierColumnMetrics(tag))

  /** Entity class storing rows of table TierColumns
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param columnType Database column column_type SqlType(INT), Default(Some(0))
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true) */
  case class TierColumnsRow(id: Int, name: String, columnType: Option[Int] = Some(0), rowOrder: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, programId: Option[Int] = None, label: String)
  /** GetResult implicit for fetching TierColumnsRow objects using plain SQL queries */
  implicit def GetResultTierColumnsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[Int]], e3: GR[Option[java.sql.Timestamp]]): GR[TierColumnsRow] = GR{
    prs => import prs._
    TierColumnsRow.tupled((<<[Int], <<[String], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<[String]))
  }
  /** Table description of table tier_columns. Objects of this class serve as prototypes for rows in queries. */
  class TierColumns(_tableTag: Tag) extends Table[TierColumnsRow](_tableTag, "tier_columns") {
    def * = (id, name, columnType, rowOrder, createdAt, updatedAt, programId, label) <> (TierColumnsRow.tupled, TierColumnsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), columnType, rowOrder, createdAt, updatedAt, programId, Rep.Some(label)).shaped.<>({r=>import r._; _1.map(_=> TierColumnsRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column column_type SqlType(INT), Default(Some(0)) */
    val columnType: Rep[Option[Int]] = column[Option[Int]]("column_type", O.Default(Some(0)))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
  }
  /** Collection-like TableQuery object for table TierColumns */
  lazy val TierColumns = new TableQuery(tag => new TierColumns(tag))

  /** Entity class storing rows of table TierColumnValues
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param tierId Database column tier_id SqlType(INT), Default(None)
   *  @param tierColumnMetricId Database column tier_column_metric_id SqlType(INT), Default(None)
   *  @param value Database column value SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class TierColumnValuesRow(id: Int, tierId: Option[Int] = None, tierColumnMetricId: Option[Int] = None, value: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching TierColumnValuesRow objects using plain SQL queries */
  implicit def GetResultTierColumnValuesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[TierColumnValuesRow] = GR{
    prs => import prs._
    TierColumnValuesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table tier_column_values. Objects of this class serve as prototypes for rows in queries. */
  class TierColumnValues(_tableTag: Tag) extends Table[TierColumnValuesRow](_tableTag, "tier_column_values") {
    def * = (id, tierId, tierColumnMetricId, value, createdAt, updatedAt) <> (TierColumnValuesRow.tupled, TierColumnValuesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), tierId, tierColumnMetricId, value, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> TierColumnValuesRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column tier_id SqlType(INT), Default(None) */
    val tierId: Rep[Option[Int]] = column[Option[Int]]("tier_id", O.Default(None))
    /** Database column tier_column_metric_id SqlType(INT), Default(None) */
    val tierColumnMetricId: Rep[Option[Int]] = column[Option[Int]]("tier_column_metric_id", O.Default(None))
    /** Database column value SqlType(TEXT), Default(None) */
    val value: Rep[Option[String]] = column[Option[String]]("value", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (tierColumnMetricId) (database name index_tier_column_values_on_tier_column_metric_id) */
    val index1 = index("index_tier_column_values_on_tier_column_metric_id", tierColumnMetricId)
    /** Index over (tierId) (database name index_tier_column_values_on_tier_id) */
    val index2 = index("index_tier_column_values_on_tier_id", tierId)
  }
  /** Collection-like TableQuery object for table TierColumnValues */
  lazy val TierColumnValues = new TableQuery(tag => new TierColumnValues(tag))

  /** Entity class storing rows of table TierRules
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param authoringMode Database column authoring_mode SqlType(INT), Default(Some(0))
   *  @param tierId Database column tier_id SqlType(INT), Default(None)
   *  @param expression Database column expression SqlType(TEXT), Default(None)
   *  @param expirationScheme Database column expiration_scheme SqlType(INT), Default(None)
   *  @param expirationDate Database column expiration_date SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param periodLength Database column period_length SqlType(INT), Default(None)
   *  @param periodUnit Database column period_unit SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None) */
  case class TierRulesRow(id: Int, programId: Option[Int] = None, name: Option[String] = None, description: Option[String] = None, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, authoringMode: Option[Int] = Some(0), tierId: Option[Int] = None, expression: Option[String] = None, expirationScheme: Option[Int] = None, expirationDate: Option[String] = None, periodLength: Option[Int] = None, periodUnit: Option[String] = None, status: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, label: String, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None)
  /** GetResult implicit for fetching TierRulesRow objects using plain SQL queries */
  implicit def GetResultTierRulesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[String], e5: GR[Option[Boolean]]): GR[TierRulesRow] = GR{
    prs => import prs._
    TierRulesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<[String], <<?[Boolean], <<?[String]))
  }
  /** Table description of table tier_rules. Objects of this class serve as prototypes for rows in queries. */
  class TierRules(_tableTag: Tag) extends Table[TierRulesRow](_tableTag, "tier_rules") {
    def * = (id, programId, name, description, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, authoringMode, tierId, expression, expirationScheme, expirationDate, periodLength, periodUnit, status, publishedAt, label, recurring, recurringSchedule) <> (TierRulesRow.tupled, TierRulesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), programId, name, description, effectivityStart, effectivityEnd, effectivityTimezone, createdAt, updatedAt, authoringMode, tierId, expression, expirationScheme, expirationDate, periodLength, periodUnit, status, publishedAt, Rep.Some(label), recurring, recurringSchedule).shaped.<>({r=>import r._; _1.map(_=> TierRulesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19.get, _20, _21)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(255,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(255,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column authoring_mode SqlType(INT), Default(Some(0)) */
    val authoringMode: Rep[Option[Int]] = column[Option[Int]]("authoring_mode", O.Default(Some(0)))
    /** Database column tier_id SqlType(INT), Default(None) */
    val tierId: Rep[Option[Int]] = column[Option[Int]]("tier_id", O.Default(None))
    /** Database column expression SqlType(TEXT), Default(None) */
    val expression: Rep[Option[String]] = column[Option[String]]("expression", O.Default(None))
    /** Database column expiration_scheme SqlType(INT), Default(None) */
    val expirationScheme: Rep[Option[Int]] = column[Option[Int]]("expiration_scheme", O.Default(None))
    /** Database column expiration_date SqlType(VARCHAR), Length(255,true), Default(None) */
    val expirationDate: Rep[Option[String]] = column[Option[String]]("expiration_date", O.Length(255,varying=true), O.Default(None))
    /** Database column period_length SqlType(INT), Default(None) */
    val periodLength: Rep[Option[Int]] = column[Option[Int]]("period_length", O.Default(None))
    /** Database column period_unit SqlType(VARCHAR), Length(255,true), Default(None) */
    val periodUnit: Rep[Option[String]] = column[Option[String]]("period_unit", O.Length(255,varying=true), O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))

    /** Index over (tierId) (database name index_tier_rules_on_tier_id) */
    val index1 = index("index_tier_rules_on_tier_id", tierId)
  }
  /** Collection-like TableQuery object for table TierRules */
  lazy val TierRules = new TableQuery(tag => new TierRules(tag))

  /** Entity class storing rows of table Tiers
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param value Database column value SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class TiersRow(id: Int, name: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, value: Option[Int] = None, label: Option[String] = None, programId: Option[Int] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching TiersRow objects using plain SQL queries */
  implicit def GetResultTiersRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[Int]]): GR[TiersRow] = GR{
    prs => import prs._
    TiersRow.tupled((<<[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int], <<?[String], <<?[Int], <<?[Int]))
  }
  /** Table description of table tiers. Objects of this class serve as prototypes for rows in queries. */
  class Tiers(_tableTag: Tag) extends Table[TiersRow](_tableTag, "tiers") {
    def * = (id, name, description, createdAt, updatedAt, value, label, programId, rowOrder) <> (TiersRow.tupled, TiersRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), name, description, createdAt, updatedAt, value, label, programId, rowOrder).shaped.<>({r=>import r._; _1.map(_=> TiersRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(100,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(100,varying=true), O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column value SqlType(INT), Default(None) */
    val value: Rep[Option[Int]] = column[Option[Int]]("value", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(100,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(100,varying=true), O.Default(None))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))

    /** Uniqueness Index over (name) (database name index_tiers_on_name) */
    val index1 = index("index_tiers_on_name", name, unique=true)
  }
  /** Collection-like TableQuery object for table Tiers */
  lazy val Tiers = new TableQuery(tag => new Tiers(tag))

  /** Entity class storing rows of table TrackingCodes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param traceableId Database column traceable_id SqlType(INT), Default(None)
   *  @param traceableType Database column traceable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param code Database column code SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class TrackingCodesRow(id: Int, traceableId: Option[Int] = None, traceableType: Option[String] = None, code: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching TrackingCodesRow objects using plain SQL queries */
  implicit def GetResultTrackingCodesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[TrackingCodesRow] = GR{
    prs => import prs._
    TrackingCodesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table tracking_codes. Objects of this class serve as prototypes for rows in queries. */
  class TrackingCodes(_tableTag: Tag) extends Table[TrackingCodesRow](_tableTag, "tracking_codes") {
    def * = (id, traceableId, traceableType, code, createdAt, updatedAt) <> (TrackingCodesRow.tupled, TrackingCodesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), traceableId, traceableType, code, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> TrackingCodesRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column traceable_id SqlType(INT), Default(None) */
    val traceableId: Rep[Option[Int]] = column[Option[Int]]("traceable_id", O.Default(None))
    /** Database column traceable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val traceableType: Rep[Option[String]] = column[Option[String]]("traceable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column code SqlType(VARCHAR), Length(255,true), Default(None) */
    val code: Rep[Option[String]] = column[Option[String]]("code", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table TrackingCodes */
  lazy val TrackingCodes = new TableQuery(tag => new TrackingCodes(tag))

  /** Entity class storing rows of table TriggeredActionParameters
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param triggeredActionId Database column triggered_action_id SqlType(INT), Default(None)
   *  @param label Database column label SqlType(VARCHAR), Length(150,true), Default(None)
   *  @param parameterValue Database column parameter_value SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param enabled Database column enabled SqlType(BIT), Default(Some(true))
   *  @param static Database column static SqlType(BIT), Default(Some(true)) */
  case class TriggeredActionParametersRow(id: Int, triggeredActionId: Option[Int] = None, label: Option[String] = None, parameterValue: Option[String] = None, enabled: Option[Boolean] = Some(true), static: Option[Boolean] = Some(true))
  /** GetResult implicit for fetching TriggeredActionParametersRow objects using plain SQL queries */
  implicit def GetResultTriggeredActionParametersRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]]): GR[TriggeredActionParametersRow] = GR{
    prs => import prs._
    TriggeredActionParametersRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[Boolean], <<?[Boolean]))
  }
  /** Table description of table triggered_action_parameters. Objects of this class serve as prototypes for rows in queries. */
  class TriggeredActionParameters(_tableTag: Tag) extends Table[TriggeredActionParametersRow](_tableTag, "triggered_action_parameters") {
    def * = (id, triggeredActionId, label, parameterValue, enabled, static) <> (TriggeredActionParametersRow.tupled, TriggeredActionParametersRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), triggeredActionId, label, parameterValue, enabled, static).shaped.<>({r=>import r._; _1.map(_=> TriggeredActionParametersRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column triggered_action_id SqlType(INT), Default(None) */
    val triggeredActionId: Rep[Option[Int]] = column[Option[Int]]("triggered_action_id", O.Default(None))
    /** Database column label SqlType(VARCHAR), Length(150,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(150,varying=true), O.Default(None))
    /** Database column parameter_value SqlType(VARCHAR), Length(255,true), Default(None) */
    val parameterValue: Rep[Option[String]] = column[Option[String]]("parameter_value", O.Length(255,varying=true), O.Default(None))
    /** Database column enabled SqlType(BIT), Default(Some(true)) */
    val enabled: Rep[Option[Boolean]] = column[Option[Boolean]]("enabled", O.Default(Some(true)))
    /** Database column static SqlType(BIT), Default(Some(true)) */
    val static: Rep[Option[Boolean]] = column[Option[Boolean]]("static", O.Default(Some(true)))

    /** Index over (triggeredActionId) (database name index_triggered_action_parameters_on_triggered_action_id) */
    val index1 = index("index_triggered_action_parameters_on_triggered_action_id", triggeredActionId)
  }
  /** Collection-like TableQuery object for table TriggeredActionParameters */
  lazy val TriggeredActionParameters = new TableQuery(tag => new TriggeredActionParameters(tag))

  /** Entity class storing rows of table TriggeredActions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param triggerId Database column trigger_id SqlType(INT), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None)
   *  @param customParameters Database column custom_parameters SqlType(TEXT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param jobId Database column job_id SqlType(INT), Default(None) */
  case class TriggeredActionsRow(id: Int, triggerId: Option[Int] = None, properties: Option[String] = None, customParameters: Option[String] = None, `type`: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, jobId: Option[Int] = None)
  /** GetResult implicit for fetching TriggeredActionsRow objects using plain SQL queries */
  implicit def GetResultTriggeredActionsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[TriggeredActionsRow] = GR{
    prs => import prs._
    TriggeredActionsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table triggered_actions. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class TriggeredActions(_tableTag: Tag) extends Table[TriggeredActionsRow](_tableTag, "triggered_actions") {
    def * = (id, triggerId, properties, customParameters, `type`, createdAt, updatedAt, jobId) <> (TriggeredActionsRow.tupled, TriggeredActionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), triggerId, properties, customParameters, `type`, createdAt, updatedAt, jobId).shaped.<>({r=>import r._; _1.map(_=> TriggeredActionsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column trigger_id SqlType(INT), Default(None) */
    val triggerId: Rep[Option[Int]] = column[Option[Int]]("trigger_id", O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
    /** Database column custom_parameters SqlType(TEXT), Default(None) */
    val customParameters: Rep[Option[String]] = column[Option[String]]("custom_parameters", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(100,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(100,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column job_id SqlType(INT), Default(None) */
    val jobId: Rep[Option[Int]] = column[Option[Int]]("job_id", O.Default(None))

    /** Index over (jobId) (database name index_triggered_actions_on_job_id) */
    val index1 = index("index_triggered_actions_on_job_id", jobId)
    /** Index over (triggerId) (database name index_triggered_actions_on_trigger_id) */
    val index2 = index("index_triggered_actions_on_trigger_id", triggerId)
  }
  /** Collection-like TableQuery object for table TriggeredActions */
  lazy val TriggeredActions = new TableQuery(tag => new TriggeredActions(tag))

  /** Entity class storing rows of table TriggerGroups
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param label Database column label SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param name Database column name SqlType(VARCHAR), Length(100,true)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param programId Database column program_id SqlType(INT)
   *  @param triggerGroupStrategyId Database column trigger_group_strategy_id SqlType(INT), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class TriggerGroupsRow(id: Int, label: Option[String] = None, name: String, description: Option[String] = None, programId: Int, triggerGroupStrategyId: Option[Int] = None, rowOrder: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching TriggerGroupsRow objects using plain SQL queries */
  implicit def GetResultTriggerGroupsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[String], e3: GR[Option[Int]], e4: GR[Option[java.sql.Timestamp]]): GR[TriggerGroupsRow] = GR{
    prs => import prs._
    TriggerGroupsRow.tupled((<<[Int], <<?[String], <<[String], <<?[String], <<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table trigger_groups. Objects of this class serve as prototypes for rows in queries. */
  class TriggerGroups(_tableTag: Tag) extends Table[TriggerGroupsRow](_tableTag, "trigger_groups") {
    def * = (id, label, name, description, programId, triggerGroupStrategyId, rowOrder, createdAt, updatedAt) <> (TriggerGroupsRow.tupled, TriggerGroupsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), label, Rep.Some(name), description, Rep.Some(programId), triggerGroupStrategyId, rowOrder, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> TriggerGroupsRow.tupled((_1.get, _2, _3.get, _4, _5.get, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column label SqlType(VARCHAR), Length(255,true), Default(None) */
    val label: Rep[Option[String]] = column[Option[String]]("label", O.Length(255,varying=true), O.Default(None))
    /** Database column name SqlType(VARCHAR), Length(100,true) */
    val name: Rep[String] = column[String]("name", O.Length(100,varying=true))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column program_id SqlType(INT) */
    val programId: Rep[Int] = column[Int]("program_id")
    /** Database column trigger_group_strategy_id SqlType(INT), Default(None) */
    val triggerGroupStrategyId: Rep[Option[Int]] = column[Option[Int]]("trigger_group_strategy_id", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (triggerGroupStrategyId) (database name index_trigger_groups_on_trigger_group_strategy_id) */
    val index1 = index("index_trigger_groups_on_trigger_group_strategy_id", triggerGroupStrategyId)
  }
  /** Collection-like TableQuery object for table TriggerGroups */
  lazy val TriggerGroups = new TableQuery(tag => new TriggerGroups(tag))

  /** Entity class storing rows of table Triggers
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param name Database column name SqlType(VARCHAR), Length(255,true)
   *  @param label Database column label SqlType(VARCHAR), Length(255,true)
   *  @param effectivityStart Database column effectivity_start SqlType(DATETIME), Default(None)
   *  @param effectivityEnd Database column effectivity_end SqlType(DATETIME), Default(None)
   *  @param effectivityTimezone Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param recurring Database column recurring SqlType(BIT), Default(Some(false))
   *  @param recurringSchedule Database column recurring_schedule SqlType(TEXT), Default(None)
   *  @param publishedAt Database column published_at SqlType(DATETIME), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(draft)
   *  @param programId Database column program_id SqlType(INT), Default(None)
   *  @param subjectId Database column subject_id SqlType(INT), Default(None)
   *  @param subjectType Database column subject_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param authoringMode Database column authoring_mode SqlType(INT), Default(None)
   *  @param triggerGroupId Database column trigger_group_id SqlType(INT), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param definition Database column definition SqlType(TEXT), Default(None)
   *  @param description Database column description SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param rowOrder Database column row_order SqlType(INT), Default(None) */
  case class TriggersRow(id: Int, name: String, label: String, effectivityStart: Option[java.sql.Timestamp] = None, effectivityEnd: Option[java.sql.Timestamp] = None, effectivityTimezone: Option[String] = None, recurring: Option[Boolean] = Some(false), recurringSchedule: Option[String] = None, publishedAt: Option[java.sql.Timestamp] = None, status: String = "draft", programId: Option[Int] = None, subjectId: Option[Int] = None, subjectType: Option[String] = None, authoringMode: Option[Int] = None, triggerGroupId: Option[Int] = None, `type`: Option[String] = None, definition: Option[String] = None, description: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, rowOrder: Option[Int] = None)
  /** GetResult implicit for fetching TriggersRow objects using plain SQL queries */
  implicit def GetResultTriggersRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[java.sql.Timestamp]], e3: GR[Option[String]], e4: GR[Option[Boolean]], e5: GR[Option[Int]]): GR[TriggersRow] = GR{
    prs => import prs._
    TriggersRow.tupled((<<[Int], <<[String], <<[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Boolean], <<?[String], <<?[java.sql.Timestamp], <<[String], <<?[Int], <<?[Int], <<?[String], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table triggers. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class Triggers(_tableTag: Tag) extends Table[TriggersRow](_tableTag, "triggers") {
    def * = (id, name, label, effectivityStart, effectivityEnd, effectivityTimezone, recurring, recurringSchedule, publishedAt, status, programId, subjectId, subjectType, authoringMode, triggerGroupId, `type`, definition, description, createdAt, updatedAt, rowOrder) <> (TriggersRow.tupled, TriggersRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(name), Rep.Some(label), effectivityStart, effectivityEnd, effectivityTimezone, recurring, recurringSchedule, publishedAt, Rep.Some(status), programId, subjectId, subjectType, authoringMode, triggerGroupId, `type`, definition, description, createdAt, updatedAt, rowOrder).shaped.<>({r=>import r._; _1.map(_=> TriggersRow.tupled((_1.get, _2.get, _3.get, _4, _5, _6, _7, _8, _9, _10.get, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column name SqlType(VARCHAR), Length(255,true) */
    val name: Rep[String] = column[String]("name", O.Length(255,varying=true))
    /** Database column label SqlType(VARCHAR), Length(255,true) */
    val label: Rep[String] = column[String]("label", O.Length(255,varying=true))
    /** Database column effectivity_start SqlType(DATETIME), Default(None) */
    val effectivityStart: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_start", O.Default(None))
    /** Database column effectivity_end SqlType(DATETIME), Default(None) */
    val effectivityEnd: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("effectivity_end", O.Default(None))
    /** Database column effectivity_timezone SqlType(VARCHAR), Length(50,true), Default(None) */
    val effectivityTimezone: Rep[Option[String]] = column[Option[String]]("effectivity_timezone", O.Length(50,varying=true), O.Default(None))
    /** Database column recurring SqlType(BIT), Default(Some(false)) */
    val recurring: Rep[Option[Boolean]] = column[Option[Boolean]]("recurring", O.Default(Some(false)))
    /** Database column recurring_schedule SqlType(TEXT), Default(None) */
    val recurringSchedule: Rep[Option[String]] = column[Option[String]]("recurring_schedule", O.Default(None))
    /** Database column published_at SqlType(DATETIME), Default(None) */
    val publishedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("published_at", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(draft) */
    val status: Rep[String] = column[String]("status", O.Length(50,varying=true), O.Default("draft"))
    /** Database column program_id SqlType(INT), Default(None) */
    val programId: Rep[Option[Int]] = column[Option[Int]]("program_id", O.Default(None))
    /** Database column subject_id SqlType(INT), Default(None) */
    val subjectId: Rep[Option[Int]] = column[Option[Int]]("subject_id", O.Default(None))
    /** Database column subject_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val subjectType: Rep[Option[String]] = column[Option[String]]("subject_type", O.Length(255,varying=true), O.Default(None))
    /** Database column authoring_mode SqlType(INT), Default(None) */
    val authoringMode: Rep[Option[Int]] = column[Option[Int]]("authoring_mode", O.Default(None))
    /** Database column trigger_group_id SqlType(INT), Default(None) */
    val triggerGroupId: Rep[Option[Int]] = column[Option[Int]]("trigger_group_id", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(100,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(100,varying=true), O.Default(None))
    /** Database column definition SqlType(TEXT), Default(None) */
    val definition: Rep[Option[String]] = column[Option[String]]("definition", O.Default(None))
    /** Database column description SqlType(TEXT), Default(None) */
    val description: Rep[Option[String]] = column[Option[String]]("description", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column row_order SqlType(INT), Default(None) */
    val rowOrder: Rep[Option[Int]] = column[Option[Int]]("row_order", O.Default(None))

    /** Index over (triggerGroupId) (database name index_triggers_on_trigger_group_id) */
    val index1 = index("index_triggers_on_trigger_group_id", triggerGroupId)
  }
  /** Collection-like TableQuery object for table Triggers */
  lazy val Triggers = new TableQuery(tag => new Triggers(tag))

  /** Entity class storing rows of table UserAddresses
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param addressId Database column address_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class UserAddressesRow(id: Int, memberId: Option[Int] = None, addressId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching UserAddressesRow objects using plain SQL queries */
  implicit def GetResultUserAddressesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[UserAddressesRow] = GR{
    prs => import prs._
    UserAddressesRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table user_addresses. Objects of this class serve as prototypes for rows in queries. */
  class UserAddresses(_tableTag: Tag) extends Table[UserAddressesRow](_tableTag, "user_addresses") {
    def * = (id, memberId, addressId, createdAt, updatedAt) <> (UserAddressesRow.tupled, UserAddressesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, addressId, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> UserAddressesRow.tupled((_1.get, _2, _3, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column address_id SqlType(INT), Default(None) */
    val addressId: Rep[Option[Int]] = column[Option[Int]]("address_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (addressId) (database name index_user_addresses_on_address_id) */
    val index1 = index("index_user_addresses_on_address_id", addressId)
    /** Index over (memberId) (database name index_user_addresses_on_member_id) */
    val index2 = index("index_user_addresses_on_member_id", memberId)
  }
  /** Collection-like TableQuery object for table UserAddresses */
  lazy val UserAddresses = new TableQuery(tag => new UserAddresses(tag))

  /** Entity class storing rows of table UserConnects
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param senderId Database column sender_id SqlType(INT), Default(None)
   *  @param recipientId Database column recipient_id SqlType(INT), Default(None)
   *  @param status Database column status SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param message Database column message SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param approved Database column approved SqlType(BIT), Default(false) */
  case class UserConnectsRow(id: Int, senderId: Option[Int] = None, recipientId: Option[Int] = None, status: Option[String] = None, message: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, approved: Boolean = false)
  /** GetResult implicit for fetching UserConnectsRow objects using plain SQL queries */
  implicit def GetResultUserConnectsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]], e4: GR[Boolean]): GR[UserConnectsRow] = GR{
    prs => import prs._
    UserConnectsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<[Boolean]))
  }
  /** Table description of table user_connects. Objects of this class serve as prototypes for rows in queries. */
  class UserConnects(_tableTag: Tag) extends Table[UserConnectsRow](_tableTag, "user_connects") {
    def * = (id, senderId, recipientId, status, message, createdAt, updatedAt, approved) <> (UserConnectsRow.tupled, UserConnectsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), senderId, recipientId, status, message, createdAt, updatedAt, Rep.Some(approved)).shaped.<>({r=>import r._; _1.map(_=> UserConnectsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8.get)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column sender_id SqlType(INT), Default(None) */
    val senderId: Rep[Option[Int]] = column[Option[Int]]("sender_id", O.Default(None))
    /** Database column recipient_id SqlType(INT), Default(None) */
    val recipientId: Rep[Option[Int]] = column[Option[Int]]("recipient_id", O.Default(None))
    /** Database column status SqlType(VARCHAR), Length(50,true), Default(None) */
    val status: Rep[Option[String]] = column[Option[String]]("status", O.Length(50,varying=true), O.Default(None))
    /** Database column message SqlType(VARCHAR), Length(255,true), Default(None) */
    val message: Rep[Option[String]] = column[Option[String]]("message", O.Length(255,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column approved SqlType(BIT), Default(false) */
    val approved: Rep[Boolean] = column[Boolean]("approved", O.Default(false))

    /** Index over (recipientId) (database name index_user_connects_on_recipient_id) */
    val index1 = index("index_user_connects_on_recipient_id", recipientId)
    /** Index over (recipientId,status) (database name index_user_connects_on_recipient_id_and_status) */
    val index2 = index("index_user_connects_on_recipient_id_and_status", (recipientId, status))
    /** Index over (senderId) (database name index_user_connects_on_sender_id) */
    val index3 = index("index_user_connects_on_sender_id", senderId)
    /** Uniqueness Index over (senderId,recipientId) (database name index_user_connects_on_sender_id_and_recipient_id) */
    val index4 = index("index_user_connects_on_sender_id_and_recipient_id", (senderId, recipientId), unique=true)
    /** Index over (senderId,status) (database name index_user_connects_on_sender_id_and_status) */
    val index5 = index("index_user_connects_on_sender_id_and_status", (senderId, status))
  }
  /** Collection-like TableQuery object for table UserConnects */
  lazy val UserConnects = new TableQuery(tag => new UserConnects(tag))

  /** Entity class storing rows of table UserDevices
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param deviceId Database column device_id SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param token Database column token SqlType(VARCHAR), Length(180,true), Default(None)
   *  @param endpointArn Database column endpoint_arn SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param platform Database column platform SqlType(VARCHAR), Length(25,true), Default(None) */
  case class UserDevicesRow(id: Int, memberId: Option[Int] = None, deviceId: Option[String] = None, token: Option[String] = None, endpointArn: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, platform: Option[String] = None)
  /** GetResult implicit for fetching UserDevicesRow objects using plain SQL queries */
  implicit def GetResultUserDevicesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[UserDevicesRow] = GR{
    prs => import prs._
    UserDevicesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table user_devices. Objects of this class serve as prototypes for rows in queries. */
  class UserDevices(_tableTag: Tag) extends Table[UserDevicesRow](_tableTag, "user_devices") {
    def * = (id, memberId, deviceId, token, endpointArn, createdAt, updatedAt, platform) <> (UserDevicesRow.tupled, UserDevicesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, deviceId, token, endpointArn, createdAt, updatedAt, platform).shaped.<>({r=>import r._; _1.map(_=> UserDevicesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column device_id SqlType(VARCHAR), Length(100,true), Default(None) */
    val deviceId: Rep[Option[String]] = column[Option[String]]("device_id", O.Length(100,varying=true), O.Default(None))
    /** Database column token SqlType(VARCHAR), Length(180,true), Default(None) */
    val token: Rep[Option[String]] = column[Option[String]]("token", O.Length(180,varying=true), O.Default(None))
    /** Database column endpoint_arn SqlType(TEXT), Default(None) */
    val endpointArn: Rep[Option[String]] = column[Option[String]]("endpoint_arn", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column platform SqlType(VARCHAR), Length(25,true), Default(None) */
    val platform: Rep[Option[String]] = column[Option[String]]("platform", O.Length(25,varying=true), O.Default(None))

    /** Index over (memberId) (database name index_user_devices_on_member_id) */
    val index1 = index("index_user_devices_on_member_id", memberId)
    /** Uniqueness Index over (memberId,deviceId) (database name index_user_devices_on_member_id_and_device_id) */
    val index2 = index("index_user_devices_on_member_id_and_device_id", (memberId, deviceId), unique=true)
  }
  /** Collection-like TableQuery object for table UserDevices */
  lazy val UserDevices = new TableQuery(tag => new UserDevices(tag))

  /** Entity class storing rows of table UserFriends
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param friendId Database column friend_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class UserFriendsRow(id: Int, memberId: Option[Int] = None, friendId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching UserFriendsRow objects using plain SQL queries */
  implicit def GetResultUserFriendsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[UserFriendsRow] = GR{
    prs => import prs._
    UserFriendsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table user_friends. Objects of this class serve as prototypes for rows in queries. */
  class UserFriends(_tableTag: Tag) extends Table[UserFriendsRow](_tableTag, "user_friends") {
    def * = (id, memberId, friendId, createdAt, updatedAt) <> (UserFriendsRow.tupled, UserFriendsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, friendId, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> UserFriendsRow.tupled((_1.get, _2, _3, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column friend_id SqlType(INT), Default(None) */
    val friendId: Rep[Option[Int]] = column[Option[Int]]("friend_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (friendId) (database name index_user_friends_on_friend_id) */
    val index1 = index("index_user_friends_on_friend_id", friendId)
    /** Index over (memberId) (database name index_user_friends_on_member_id) */
    val index2 = index("index_user_friends_on_member_id", memberId)
    /** Uniqueness Index over (memberId,friendId) (database name index_user_friends_on_member_id_and_friend_id) */
    val index3 = index("index_user_friends_on_member_id_and_friend_id", (memberId, friendId), unique=true)
  }
  /** Collection-like TableQuery object for table UserFriends */
  lazy val UserFriends = new TableQuery(tag => new UserFriends(tag))

  /** Entity class storing rows of table UserMessages
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT)
   *  @param messageId Database column message_id SqlType(INT)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class UserMessagesRow(id: Int, memberId: Int, messageId: Int, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching UserMessagesRow objects using plain SQL queries */
  implicit def GetResultUserMessagesRow(implicit e0: GR[Int], e1: GR[Option[java.sql.Timestamp]]): GR[UserMessagesRow] = GR{
    prs => import prs._
    UserMessagesRow.tupled((<<[Int], <<[Int], <<[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table user_messages. Objects of this class serve as prototypes for rows in queries. */
  class UserMessages(_tableTag: Tag) extends Table[UserMessagesRow](_tableTag, "user_messages") {
    def * = (id, memberId, messageId, createdAt, updatedAt) <> (UserMessagesRow.tupled, UserMessagesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(memberId), Rep.Some(messageId), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> UserMessagesRow.tupled((_1.get, _2.get, _3.get, _4, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT) */
    val memberId: Rep[Int] = column[Int]("member_id")
    /** Database column message_id SqlType(INT) */
    val messageId: Rep[Int] = column[Int]("message_id")
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (memberId) (database name index_user_messages_on_member_id) */
    val index1 = index("index_user_messages_on_member_id", memberId)
    /** Index over (messageId,memberId) (database name index_user_messages_on_message_id_and_member_id) */
    val index2 = index("index_user_messages_on_message_id_and_member_id", (messageId, memberId))
  }
  /** Collection-like TableQuery object for table UserMessages */
  lazy val UserMessages = new TableQuery(tag => new UserMessages(tag))

  /** Entity class storing rows of table UserMetrics
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param userId Database column user_id SqlType(INT)
   *  @param hourToDate Database column hour_to_date SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param dayToDate Database column day_to_date SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param yearToDate Database column year_to_date SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param allTimeToDate Database column all_time_to_date SqlType(VARCHAR), Length(50,true), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param metricName Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
  case class UserMetricsRow(id: Int, userId: Int, hourToDate: Option[String] = None, dayToDate: Option[String] = None, yearToDate: Option[String] = None, allTimeToDate: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, metricName: Option[String] = None)
  /** GetResult implicit for fetching UserMetricsRow objects using plain SQL queries */
  implicit def GetResultUserMetricsRow(implicit e0: GR[Int], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]]): GR[UserMetricsRow] = GR{
    prs => import prs._
    UserMetricsRow.tupled((<<[Int], <<[Int], <<?[String], <<?[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table user_metrics. Objects of this class serve as prototypes for rows in queries. */
  class UserMetrics(_tableTag: Tag) extends Table[UserMetricsRow](_tableTag, "user_metrics") {
    def * = (id, userId, hourToDate, dayToDate, yearToDate, allTimeToDate, createdAt, updatedAt, metricName) <> (UserMetricsRow.tupled, UserMetricsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(userId), hourToDate, dayToDate, yearToDate, allTimeToDate, createdAt, updatedAt, metricName).shaped.<>({r=>import r._; _1.map(_=> UserMetricsRow.tupled((_1.get, _2.get, _3, _4, _5, _6, _7, _8, _9)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column user_id SqlType(INT) */
    val userId: Rep[Int] = column[Int]("user_id")
    /** Database column hour_to_date SqlType(VARCHAR), Length(50,true), Default(None) */
    val hourToDate: Rep[Option[String]] = column[Option[String]]("hour_to_date", O.Length(50,varying=true), O.Default(None))
    /** Database column day_to_date SqlType(VARCHAR), Length(50,true), Default(None) */
    val dayToDate: Rep[Option[String]] = column[Option[String]]("day_to_date", O.Length(50,varying=true), O.Default(None))
    /** Database column year_to_date SqlType(VARCHAR), Length(50,true), Default(None) */
    val yearToDate: Rep[Option[String]] = column[Option[String]]("year_to_date", O.Length(50,varying=true), O.Default(None))
    /** Database column all_time_to_date SqlType(VARCHAR), Length(50,true), Default(None) */
    val allTimeToDate: Rep[Option[String]] = column[Option[String]]("all_time_to_date", O.Length(50,varying=true), O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column metric_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val metricName: Rep[Option[String]] = column[Option[String]]("metric_name", O.Length(255,varying=true), O.Default(None))

    /** Index over (userId) (database name index_user_metrics_on_user_id) */
    val index1 = index("index_user_metrics_on_user_id", userId)
  }
  /** Collection-like TableQuery object for table UserMetrics */
  lazy val UserMetrics = new TableQuery(tag => new UserMetrics(tag))

  /** Entity class storing rows of table UserReferrals
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT), Default(None)
   *  @param referralCodeId Database column referral_code_id SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param referrerId Database column referrer_id SqlType(INT), Default(None) */
  case class UserReferralsRow(id: Int, memberId: Option[Int] = None, referralCodeId: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, referrerId: Option[Int] = None)
  /** GetResult implicit for fetching UserReferralsRow objects using plain SQL queries */
  implicit def GetResultUserReferralsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[java.sql.Timestamp]]): GR[UserReferralsRow] = GR{
    prs => import prs._
    UserReferralsRow.tupled((<<[Int], <<?[Int], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[Int]))
  }
  /** Table description of table user_referrals. Objects of this class serve as prototypes for rows in queries. */
  class UserReferrals(_tableTag: Tag) extends Table[UserReferralsRow](_tableTag, "user_referrals") {
    def * = (id, memberId, referralCodeId, createdAt, updatedAt, referrerId) <> (UserReferralsRow.tupled, UserReferralsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), memberId, referralCodeId, createdAt, updatedAt, referrerId).shaped.<>({r=>import r._; _1.map(_=> UserReferralsRow.tupled((_1.get, _2, _3, _4, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT), Default(None) */
    val memberId: Rep[Option[Int]] = column[Option[Int]]("member_id", O.Default(None))
    /** Database column referral_code_id SqlType(INT), Default(None) */
    val referralCodeId: Rep[Option[Int]] = column[Option[Int]]("referral_code_id", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column referrer_id SqlType(INT), Default(None) */
    val referrerId: Rep[Option[Int]] = column[Option[Int]]("referrer_id", O.Default(None))

    /** Index over (memberId) (database name index_user_referrals_on_member_id) */
    val index1 = index("index_user_referrals_on_member_id", memberId)
    /** Index over (referralCodeId) (database name index_user_referrals_on_referral_code_id) */
    val index2 = index("index_user_referrals_on_referral_code_id", referralCodeId)
    /** Index over (referrerId) (database name index_user_referrals_on_referrer_id) */
    val index3 = index("index_user_referrals_on_referrer_id", referrerId)
  }
  /** Collection-like TableQuery object for table UserReferrals */
  lazy val UserReferrals = new TableQuery(tag => new UserReferrals(tag))

  /** Entity class storing rows of table UserSegments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param memberId Database column member_id SqlType(INT)
   *  @param segmentId Database column segment_id SqlType(INT)
   *  @param included Database column included SqlType(BIT), Default(true)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class UserSegmentsRow(id: Int, memberId: Int, segmentId: Int, included: Boolean = true, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching UserSegmentsRow objects using plain SQL queries */
  implicit def GetResultUserSegmentsRow(implicit e0: GR[Int], e1: GR[Boolean], e2: GR[Option[java.sql.Timestamp]]): GR[UserSegmentsRow] = GR{
    prs => import prs._
    UserSegmentsRow.tupled((<<[Int], <<[Int], <<[Int], <<[Boolean], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table user_segments. Objects of this class serve as prototypes for rows in queries. */
  class UserSegments(_tableTag: Tag) extends Table[UserSegmentsRow](_tableTag, "user_segments") {
    def * = (id, memberId, segmentId, included, createdAt, updatedAt) <> (UserSegmentsRow.tupled, UserSegmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(memberId), Rep.Some(segmentId), Rep.Some(included), createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> UserSegmentsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5, _6)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column member_id SqlType(INT) */
    val memberId: Rep[Int] = column[Int]("member_id")
    /** Database column segment_id SqlType(INT) */
    val segmentId: Rep[Int] = column[Int]("segment_id")
    /** Database column included SqlType(BIT), Default(true) */
    val included: Rep[Boolean] = column[Boolean]("included", O.Default(true))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Uniqueness Index over (memberId,segmentId) (database name index_user_segments_on_member_id_and_segment_id) */
    val index1 = index("index_user_segments_on_member_id_and_segment_id", (memberId, segmentId), unique=true)
    /** Index over (segmentId) (database name index_user_segments_on_segment_id) */
    val index2 = index("index_user_segments_on_segment_id", segmentId)
  }
  /** Collection-like TableQuery object for table UserSegments */
  lazy val UserSegments = new TableQuery(tag => new UserSegments(tag))

  /** Entity class storing rows of table Versions
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param itemType Database column item_type SqlType(VARCHAR), Length(255,true)
   *  @param itemId Database column item_id SqlType(INT)
   *  @param event Database column event SqlType(VARCHAR), Length(255,true)
   *  @param whodunnit Database column whodunnit SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param `object` Database column object SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param objectChanges Database column object_changes SqlType(TEXT), Default(None) */
  case class VersionsRow(id: Int, itemType: String, itemId: Int, event: String, whodunnit: Option[String] = None, `object`: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, objectChanges: Option[String] = None)
  /** GetResult implicit for fetching VersionsRow objects using plain SQL queries */
  implicit def GetResultVersionsRow(implicit e0: GR[Int], e1: GR[String], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[VersionsRow] = GR{
    prs => import prs._
    VersionsRow.tupled((<<[Int], <<[String], <<[Int], <<[String], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[String]))
  }
  /** Table description of table versions. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: object */
  class Versions(_tableTag: Tag) extends Table[VersionsRow](_tableTag, "versions") {
    def * = (id, itemType, itemId, event, whodunnit, `object`, createdAt, objectChanges) <> (VersionsRow.tupled, VersionsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), Rep.Some(itemType), Rep.Some(itemId), Rep.Some(event), whodunnit, `object`, createdAt, objectChanges).shaped.<>({r=>import r._; _1.map(_=> VersionsRow.tupled((_1.get, _2.get, _3.get, _4.get, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column item_type SqlType(VARCHAR), Length(255,true) */
    val itemType: Rep[String] = column[String]("item_type", O.Length(255,varying=true))
    /** Database column item_id SqlType(INT) */
    val itemId: Rep[Int] = column[Int]("item_id")
    /** Database column event SqlType(VARCHAR), Length(255,true) */
    val event: Rep[String] = column[String]("event", O.Length(255,varying=true))
    /** Database column whodunnit SqlType(VARCHAR), Length(255,true), Default(None) */
    val whodunnit: Rep[Option[String]] = column[Option[String]]("whodunnit", O.Length(255,varying=true), O.Default(None))
    /** Database column object SqlType(TEXT), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `object`: Rep[Option[String]] = column[Option[String]]("object", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column object_changes SqlType(TEXT), Default(None) */
    val objectChanges: Rep[Option[String]] = column[Option[String]]("object_changes", O.Default(None))

    /** Index over (itemType,itemId) (database name index_versions_on_item_type_and_item_id) */
    val index1 = index("index_versions_on_item_type_and_item_id", (itemType, itemId))
  }
  /** Collection-like TableQuery object for table Versions */
  lazy val Versions = new TableQuery(tag => new Versions(tag))

  /** Entity class storing rows of table Votes
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param votableId Database column votable_id SqlType(INT), Default(None)
   *  @param votableType Database column votable_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param voterId Database column voter_id SqlType(INT), Default(None)
   *  @param voterType Database column voter_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param voteFlag Database column vote_flag SqlType(BIT), Default(None)
   *  @param voteScope Database column vote_scope SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param voteWeight Database column vote_weight SqlType(INT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class VotesRow(id: Int, votableId: Option[Int] = None, votableType: Option[String] = None, voterId: Option[Int] = None, voterType: Option[String] = None, voteFlag: Option[Boolean] = None, voteScope: Option[String] = None, voteWeight: Option[Int] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching VotesRow objects using plain SQL queries */
  implicit def GetResultVotesRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[Boolean]], e4: GR[Option[java.sql.Timestamp]]): GR[VotesRow] = GR{
    prs => import prs._
    VotesRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[Int], <<?[String], <<?[Boolean], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table votes. Objects of this class serve as prototypes for rows in queries. */
  class Votes(_tableTag: Tag) extends Table[VotesRow](_tableTag, "votes") {
    def * = (id, votableId, votableType, voterId, voterType, voteFlag, voteScope, voteWeight, createdAt, updatedAt) <> (VotesRow.tupled, VotesRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), votableId, votableType, voterId, voterType, voteFlag, voteScope, voteWeight, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> VotesRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column votable_id SqlType(INT), Default(None) */
    val votableId: Rep[Option[Int]] = column[Option[Int]]("votable_id", O.Default(None))
    /** Database column votable_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val votableType: Rep[Option[String]] = column[Option[String]]("votable_type", O.Length(255,varying=true), O.Default(None))
    /** Database column voter_id SqlType(INT), Default(None) */
    val voterId: Rep[Option[Int]] = column[Option[Int]]("voter_id", O.Default(None))
    /** Database column voter_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val voterType: Rep[Option[String]] = column[Option[String]]("voter_type", O.Length(255,varying=true), O.Default(None))
    /** Database column vote_flag SqlType(BIT), Default(None) */
    val voteFlag: Rep[Option[Boolean]] = column[Option[Boolean]]("vote_flag", O.Default(None))
    /** Database column vote_scope SqlType(VARCHAR), Length(255,true), Default(None) */
    val voteScope: Rep[Option[String]] = column[Option[String]]("vote_scope", O.Length(255,varying=true), O.Default(None))
    /** Database column vote_weight SqlType(INT), Default(None) */
    val voteWeight: Rep[Option[Int]] = column[Option[Int]]("vote_weight", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))

    /** Index over (votableId,votableType,voteScope) (database name index_votes_on_votable_id_and_votable_type_and_vote_scope) */
    val index1 = index("index_votes_on_votable_id_and_votable_type_and_vote_scope", (votableId, votableType, voteScope))
    /** Index over (voterId,voterType,voteScope) (database name index_votes_on_voter_id_and_voter_type_and_vote_scope) */
    val index2 = index("index_votes_on_voter_id_and_voter_type_and_vote_scope", (voterId, voterType, voteScope))
  }
  /** Collection-like TableQuery object for table Votes */
  lazy val Votes = new TableQuery(tag => new Votes(tag))

  /** Entity class storing rows of table WallPostAttachments
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param postId Database column post_id SqlType(INT), Default(None)
   *  @param fileFileName Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileContentType Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param fileFileSize Database column file_file_size SqlType(INT), Default(None)
   *  @param fileUpdatedAt Database column file_updated_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None) */
  case class WallPostAttachmentsRow(id: Int, postId: Option[Int] = None, fileFileName: Option[String] = None, fileContentType: Option[String] = None, fileFileSize: Option[Int] = None, fileUpdatedAt: Option[java.sql.Timestamp] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None)
  /** GetResult implicit for fetching WallPostAttachmentsRow objects using plain SQL queries */
  implicit def GetResultWallPostAttachmentsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[WallPostAttachmentsRow] = GR{
    prs => import prs._
    WallPostAttachmentsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[Int], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp]))
  }
  /** Table description of table wall_post_attachments. Objects of this class serve as prototypes for rows in queries. */
  class WallPostAttachments(_tableTag: Tag) extends Table[WallPostAttachmentsRow](_tableTag, "wall_post_attachments") {
    def * = (id, postId, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, createdAt, updatedAt) <> (WallPostAttachmentsRow.tupled, WallPostAttachmentsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), postId, fileFileName, fileContentType, fileFileSize, fileUpdatedAt, createdAt, updatedAt).shaped.<>({r=>import r._; _1.map(_=> WallPostAttachmentsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column post_id SqlType(INT), Default(None) */
    val postId: Rep[Option[Int]] = column[Option[Int]]("post_id", O.Default(None))
    /** Database column file_file_name SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileFileName: Rep[Option[String]] = column[Option[String]]("file_file_name", O.Length(255,varying=true), O.Default(None))
    /** Database column file_content_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val fileContentType: Rep[Option[String]] = column[Option[String]]("file_content_type", O.Length(255,varying=true), O.Default(None))
    /** Database column file_file_size SqlType(INT), Default(None) */
    val fileFileSize: Rep[Option[Int]] = column[Option[Int]]("file_file_size", O.Default(None))
    /** Database column file_updated_at SqlType(DATETIME), Default(None) */
    val fileUpdatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("file_updated_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
  }
  /** Collection-like TableQuery object for table WallPostAttachments */
  lazy val WallPostAttachments = new TableQuery(tag => new WallPostAttachments(tag))

  /** Entity class storing rows of table WallPosts
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey
   *  @param ownerId Database column owner_id SqlType(INT), Default(None)
   *  @param ownerType Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param body Database column body SqlType(TEXT), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME), Default(None)
   *  @param updatedAt Database column updated_at SqlType(DATETIME), Default(None)
   *  @param `type` Database column type SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param newsFeedId Database column news_feed_id SqlType(INT), Default(None)
   *  @param sourceUid Database column source_uid SqlType(VARCHAR), Length(255,true), Default(None)
   *  @param properties Database column properties SqlType(TEXT), Default(None) */
  case class WallPostsRow(id: Int, ownerId: Option[Int] = None, ownerType: Option[String] = None, body: Option[String] = None, createdAt: Option[java.sql.Timestamp] = None, updatedAt: Option[java.sql.Timestamp] = None, `type`: Option[String] = None, newsFeedId: Option[Int] = None, sourceUid: Option[String] = None, properties: Option[String] = None)
  /** GetResult implicit for fetching WallPostsRow objects using plain SQL queries */
  implicit def GetResultWallPostsRow(implicit e0: GR[Int], e1: GR[Option[Int]], e2: GR[Option[String]], e3: GR[Option[java.sql.Timestamp]]): GR[WallPostsRow] = GR{
    prs => import prs._
    WallPostsRow.tupled((<<[Int], <<?[Int], <<?[String], <<?[String], <<?[java.sql.Timestamp], <<?[java.sql.Timestamp], <<?[String], <<?[Int], <<?[String], <<?[String]))
  }
  /** Table description of table wall_posts. Objects of this class serve as prototypes for rows in queries.
   *  NOTE: The following names collided with Scala keywords and were escaped: type */
  class WallPosts(_tableTag: Tag) extends Table[WallPostsRow](_tableTag, "wall_posts") {
    def * = (id, ownerId, ownerType, body, createdAt, updatedAt, `type`, newsFeedId, sourceUid, properties) <> (WallPostsRow.tupled, WallPostsRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(id), ownerId, ownerType, body, createdAt, updatedAt, `type`, newsFeedId, sourceUid, properties).shaped.<>({r=>import r._; _1.map(_=> WallPostsRow.tupled((_1.get, _2, _3, _4, _5, _6, _7, _8, _9, _10)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
    /** Database column owner_id SqlType(INT), Default(None) */
    val ownerId: Rep[Option[Int]] = column[Option[Int]]("owner_id", O.Default(None))
    /** Database column owner_type SqlType(VARCHAR), Length(255,true), Default(None) */
    val ownerType: Rep[Option[String]] = column[Option[String]]("owner_type", O.Length(255,varying=true), O.Default(None))
    /** Database column body SqlType(TEXT), Default(None) */
    val body: Rep[Option[String]] = column[Option[String]]("body", O.Default(None))
    /** Database column created_at SqlType(DATETIME), Default(None) */
    val createdAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("created_at", O.Default(None))
    /** Database column updated_at SqlType(DATETIME), Default(None) */
    val updatedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("updated_at", O.Default(None))
    /** Database column type SqlType(VARCHAR), Length(255,true), Default(None)
     *  NOTE: The name was escaped because it collided with a Scala keyword. */
    val `type`: Rep[Option[String]] = column[Option[String]]("type", O.Length(255,varying=true), O.Default(None))
    /** Database column news_feed_id SqlType(INT), Default(None) */
    val newsFeedId: Rep[Option[Int]] = column[Option[Int]]("news_feed_id", O.Default(None))
    /** Database column source_uid SqlType(VARCHAR), Length(255,true), Default(None) */
    val sourceUid: Rep[Option[String]] = column[Option[String]]("source_uid", O.Length(255,varying=true), O.Default(None))
    /** Database column properties SqlType(TEXT), Default(None) */
    val properties: Rep[Option[String]] = column[Option[String]]("properties", O.Default(None))
  }
  /** Collection-like TableQuery object for table WallPosts */
  lazy val WallPosts = new TableQuery(tag => new WallPosts(tag))
}
